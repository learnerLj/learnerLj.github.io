<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Haskell(一)入门 | Logic's Tech Blog</title><meta name="author" content="Michael L"><meta name="copyright" content="Michael L"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><meta name="description" content="Haskell函数式编程语言入门指南，介绍安装配置、基本语法、数据类型、函数定义、模式匹配等核心概念，帮助初学者掌握函数式编程思维。">
<meta property="og:type" content="article">
<meta property="og:title" content="Haskell(一)入门">
<meta property="og:url" content="https://www.blog-blockchain.xyz/fp/FP-haskell-1/index.html">
<meta property="og:site_name" content="Logic's Tech Blog">
<meta property="og:description" content="Haskell函数式编程语言入门指南，介绍安装配置、基本语法、数据类型、函数定义、模式匹配等核心概念，帮助初学者掌握函数式编程思维。">
<meta property="og:locale">
<meta property="og:image" content="https://www.blog-blockchain.xyz/images/haskell.png">
<meta property="article:published_time" content="2022-08-29T13:30:33.000Z">
<meta property="article:modified_time" content="2026-02-19T16:18:01.155Z">
<meta property="article:author" content="Michael L">
<meta property="article:tag" content="Haskell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.blog-blockchain.xyz/images/haskell.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Haskell(一)入门",
  "url": "https://www.blog-blockchain.xyz/fp/FP-haskell-1/",
  "image": "https://www.blog-blockchain.xyz/images/haskell.png",
  "datePublished": "2022-08-29T13:30:33.000Z",
  "dateModified": "2026-02-19T16:18:01.155Z",
  "author": [
    {
      "@type": "Person",
      "name": "Michael L",
      "url": "https://www.blog-blockchain.xyz"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://www.blog-blockchain.xyz/fp/FP-haskell-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?372b8854d18acf62880149b1e08e1901";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=QXcJQjXxTMeUwnWykFW2xw"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'QXcJQjXxTMeUwnWykFW2xw')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'QXcJQjXxTMeUwnWykFW2xw', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Haskell(一)入门',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="Logic's Tech Blog" type="application/atom+xml">
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css');loadCss('https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css');loadCss('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css"></noscript></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">102</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">32</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Logic's Tech Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Haskell(一)入门</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Haskell(一)入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-08-29T13:30:33.000Z" title="Created 2022-08-29 21:30:33">2022-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-19T16:18:01.155Z" title="Updated 2026-02-20 00:18:01">2026-02-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/functional-language/">functional language</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>27mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><blockquote>
<ol class="series-items"><li><a href="/fp/FP-haskell-1/" title="Haskell(一)入门">Haskell(一)入门</a></li><li><a href="/fp/FP-haskell-2/" title="Haskell(二)函数式编程">Haskell(二)函数式编程</a></li><li><a href="/fp/monad/" title="Haskell(三) Monad">Haskell(三) Monad</a></li><li><a href="/fp/Haskell-summary-toolchain/" title="Haskell(四)总结和工具链">Haskell(四)总结和工具链</a></li><li><a href="/fp/Haskell-epilogue/" title="Haskell(五) 总结和展望">Haskell(五) 总结和展望</a></li><li><a href="/fp/project-euler/" title="Haskell(六) Project Euler 练习1-26">Haskell(六) Project Euler 练习1-26</a></li></ol>
</blockquote>
<h2 id="前言">前言</h2>
<p>这个系列主要介绍典型的<strong>函数式程序设计语言</strong>（Functional programming languages，FP）和<strong>逻辑式程序设计语言</strong>（Logic programming languages，LP），将会分别以 Haskell 和 datalog（主要是 souffle）作为例子，简单的入门和理解。</p>
<p>理解典型的 FP 对于深入学习程序设计语言挺好处的。我们先从 haskell 开始</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.haskell.org/">haskell 官网</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://flaneur2020.github.io/lyah/chapters.htm">Haskell 趣学指南</a>，<a target="_blank" rel="noopener external nofollow noreferrer" href="http://learnyouahaskell.com/">英文原版</a>也很不错。</li>
<li>快速查阅<a target="_blank" rel="noopener external nofollow noreferrer" href="https://downloads.haskell.org/ghc/latest/docs/libraries/">库文档</a></li>
<li>最推荐的查阅手册，能够直接点击 Quick Jump 搜索关键词，这也是我最常用的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html">文档</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://wiki.haskell.org/Haskell">官方 WiKi</a>如果有不懂的术语，那么很推荐先在 wiki 上查找。</li>
<li>可以参考的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.seas.upenn.edu/~cis1940/spring13/lectures.html">入门课程</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://t.me/haskellzh/4310">资源汇总</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://t.me/haskellzh">交流学习群</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="https://t.me/haskell_zh_2">交流学习群 2</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://tryhaskell.org/">在线交互解释器</a>，适合不配置环境就开始学习。</li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://youtu.be/vn1IOxVplKQ">视频教程</a>和对应<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/dalvescb/LearningHaskell_Exercises">练习答案</a></li>
</ul>
<hr>
<p>Haskell 的设计思路和普通命令式语言不同，读者将会遇到思维上的转变，从类 C 语言的变量、指针、内存、控制流的基本思想，到递归、表达式、变量替换和绑定的基本思想。我粗浅的理解里，印象最深的是无处不在的递归思维，递归贯穿了整个设计理念。并且放弃变量控制状态+控制流的传统命令式语言方式，彻底的用函数表现所有流程。</p>
<p>为了与 lambda 演算匹配，Functor 的思想也贯穿着整个表达式替换的过程，函数柯里化的过程让表达式嵌套变得更加自然，这些语法糖的支持，使得 Haskell 能够完成一般的任务。</p>
<p>然而，表达式嵌套的过程，各种新奇的语法糖，增大了从 C 系语言迁移到函数式语言的难度，而且函子(functor)的引入使得初学者难以把握抽象表达式的嵌套。学习新的语言设计范式可能理论价值高于实际价值。</p>
<p>我从这些天的学习中，提升的能力大致是：</p>
<ul>
<li>初步从编程的角度理解 lambda 演算，有利于后续可能的深入学习。</li>
<li>自然而然地养成了递归思想，写程序往往会优先考虑递归。对于有规律地过程，递归和模式匹配的表现力很强。但是对于描述流程来说，可能 C 系语言更加自然。</li>
<li>这是程序设计语言的三大范式之一，有利于深入学习程序设计语言和程序分析方向。</li>
</ul>
<h2 id="安装和下载">安装和下载</h2>
<p>Haskell 式函数式编程语言，安装教程详情见<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.haskell.org/downloads/">官网</a>。除了官网推荐的安装方式，还可以使用包管理工具，尽量避免自行下载安装。</p>
<p>之后建议使用 VScode 编辑，如果已经完全安装了 Haskell 后，直接下载<a target="_blank" rel="noopener external nofollow noreferrer" href="https://marketplace.visualstudio.com/items?itemName=haskell.haskell">插件</a>，即可有代码智能提示。其他 IDE 可见 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://wiki.haskell.org/IDEs">wiki</a>。</p>
<h2 id="haskell-简介">haskell 简介</h2>
<p>官网就写的很好</p>
<ul>
<li>
<p>Statically typed——强静态类型</p>
<p><strong>Every expression in Haskell has a type which is determined at compile time</strong>. All the types composed together by function application have to match up. If they don’t, the program will be rejected by the compiler. Types become not only a form of guarantee, but a language for expressing the construction of programs.</p>
<p>也就是说静态的强类型系统。</p>
</li>
<li>
<p>Purely functional——纯函数式</p>
<p>Every function in Haskell is a function in the mathematical sense (i.e., “pure”). Even side-effecting IO operations are but a description of what to do, produced by pure code. There are no statements or instructions, only expressions which cannot mutate variables (local or global) nor access state like time or random numbers.</p>
<p>函数不存在“状态”，只有“如何处理”的逻辑，基础是<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%CE%BB%E6%BC%94%E7%AE%97">λ 演算</a></p>
</li>
<li>
<p>Type inference——一定的类型推断</p>
<p>You don’t have to explicitly write out every type in a Haskell program. Types will be inferred by unifying every type bidirectionally. However, you can write out types if you choose, or ask the compiler to write them for you for handy documentation.</p>
</li>
<li>
<p>Concurrent</p>
<p>Haskell lends itself well to concurrent programming <strong>due to its explicit handling of effects</strong>. Its flagship compiler, GHC, comes with <strong>a high-performance parallel garbage collector</strong> and light-weight concurrency library containing a number of useful concurrency primitives and abstractions.</p>
</li>
</ul>
<h2 id="运算符">运算符</h2>
<p>主要来自 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://rwh.readthedocs.io/en/latest/index.html">Real World Haskell 中文版</a>，也是写的不错的书。</p>
<p><strong>ghci</strong> 程序是 GHC 的交互式解析器。它可以让用户输入 Haskell 表达式并对其求值，浏览模块以及调试代码。如果你熟悉 Python 或是 Ruby，那么 ghci 一定程度上和 <code>python</code>，<code>irb</code> 很像，这两者分别是 Python 和 Ruby 的交互式解析器。</p>
<ol>
<li><code>+</code> <code>-</code> <code>*</code> <code>/</code> 都是常见的二元运算符，基本和其他语言一致。<code>-</code> 作为负号时，这个一元运算符需要添加括号。注意 <code>/</code> jie’gu</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; 2+-3</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:2:2: error:</span><br><span class="line">    • Variable not in scope: (+-) :: t0 -&gt; t1 -&gt; t</span><br><span class="line">    • Perhaps you meant one of these:</span><br><span class="line">        ‘+’ (imported from Prelude), ‘-’ (imported from Prelude),</span><br><span class="line">        ‘++’ (imported from Prelude)</span><br><span class="line">Prelude&gt; 2+(-3)</span><br><span class="line">-1</span><br></pre></td></tr></tbody></table></figure>
<p>总而言之，符号 在 Haskell 中非常重要。</p>
<ol start="2">
<li>
<p>Haskell 中表示布尔逻辑的值有这么两个：<code>True</code>和<code>False</code>。名字中的大写很重要。作用于布尔值得操作符类似于 C 语言的情况：<code>(&amp;&amp;)</code>表示“逻辑与”，<code>(||)</code>表示“逻辑或”。<strong>需要注意，0 /= False</strong>，这是强类型的语言，非 0 值也不是 True</p>
</li>
<li>
<p><code>!=</code> 在这里的写法不同，而是<code>/=</code></p>
</li>
<li>
<p><code>++</code> 表示为列表连接。<code>Prelude&gt; [1,2,3]++[4,5,6]</code> 结果是 <code> [1,2,3,4,5,6]</code></p>
</li>
<li>
<p><code>:</code> 是二元操作符，用于增加一个元素到列表的头部，第一个操数是元素，第二个操作数是列表，<code>Prelude&gt; 0:[1,2,3]++[4,5,6] </code> 结果是 <code> [0,1,2,3,4,5,6]</code></p>
</li>
</ol>
<p>更多的，建议读者多<a target="_blank" rel="noopener external nofollow noreferrer" href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html">阅读文档</a>，官方的文档永远是最好的参考手册。</p>
<h2 id="数据类型">数据类型</h2>
<p><strong>在 Haskell 里，所有类型名字都以大写字母开头，而所有变量名字都以小写字母开头。它不会自动地将值从一个类型转换到另一个类型（转换有时又称为强制或变换）</strong></p>
<ol>
<li>
<p>列表：<code>[1,2,3]</code>，和 python 类似，但是列表的元素类型需要一致。</p>
<p>列表可以使用枚举符号，也就是说 <code>[1,2..6]</code> 会自动补全为<code>[1,2,3,4,5,6]</code>。<code>[1,4..15]</code> 补全为<code>[1,4,7,10,13]</code></p>
<p>新建列表也可以写成集合的形式，例如</p>
</li>
<li>
<p>字符和字符串和 C 语言类似。 <code>'a'</code> 是字符， <code>"a"</code> 是字符串。<strong>字符串也是列表，可以当作字符的列表，是等价的。</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; let a = ['l', 'o', 't', 's', ' ', 'o', 'f', ' ', 'w', 'o', 'r', 'k']</span><br><span class="line">ghci&gt; a</span><br><span class="line">"lots of work"</span><br><span class="line">ghci&gt; a == "lots of work"</span><br><span class="line">True</span><br></pre></td></tr></tbody></table></figure>
<p>所以可以得到类似的结论</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; "123"++"abc"</span><br><span class="line">"123abc"</span><br><span class="line">Prelude&gt; 'x':"123"++"abc"</span><br><span class="line">"x123abc"</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>元组的长度是固定的，但可以包含不同类型的值。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; (1964, "Labyrinths")</span><br><span class="line">(1964,"Labyrinths")</span><br></pre></td></tr></tbody></table></figure>
<p>元组是有顺序的，比较的时候是对应元素比较</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; :type (False, 'a')</span><br><span class="line">(False, 'a') :: (Bool, Char)</span><br><span class="line">Prelude&gt; :type ('a',False)</span><br><span class="line">('a',False) :: (Char, Bool)</span><br><span class="line">Prelude&gt; (False, 'a') == (False, 'a')</span><br><span class="line">True</span><br><span class="line">Prelude&gt; (False, 'a') == ('a',False)</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:10:18: error:</span><br><span class="line">• Couldn't match expected type ‘Bool’ with actual type ‘Char’</span><br><span class="line">• In the expression: 'a'</span><br><span class="line">In the second argument of ‘(==)’, namely ‘('a', False)’</span><br><span class="line">In the expression: (False, 'a') == ('a', False)</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:10:22: error:</span><br><span class="line">• Couldn't match expected type ‘Char’ with actual type ‘Bool’</span><br><span class="line">• In the expression: False</span><br><span class="line">In the second argument of ‘(==)’, namely ‘('a', False)’</span><br><span class="line">In the expression: (False, 'a') == ('a', False)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>分数表示比较特殊，<code>1/2</code> 表示为 <code>1%2</code>，它实际上是比较精确的比例，<code>:m +Data.Ratio</code> 表示引入 Data.Ratio module。相应的，也可以撤销引入的模块 <code>:m -Data.Ratio</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; :m +Data.Ratio</span><br><span class="line">Prelude Data.Ratio&gt; 11%29</span><br><span class="line">11 % 29</span><br><span class="line">it :: Integral a =&gt; Ratio a</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><code>Char</code>：单个 Unicode 字符。</p>
</li>
<li>
<p><code>Bool</code>表示一个布尔逻辑值。这个类型只有两个值： <code>True</code> 和 <code>False</code> 。</p>
</li>
<li>
<p><code>Int</code> 带符号的定长（fixed-width）整数。这个值的准确范围由机器决定：在 32 位机器里， <code>Int</code> 为 32 位宽，在 64 位机器里， <code>Int</code> 为 64 位宽。Haskell 保证 <code>Int</code> 的宽度不少于 28 位。（数值类型还可以是 8 位、16 位，等等，也可以是带符号和无符号的，以后会介绍。）</p>
</li>
<li>
<p><code>Integer</code> 不限长度的带符号整数。 <code>Integer</code> 并不像 <code>Int</code> 那么常用，因为它们需要更多的内存和更大的计算量。另一方面，对 <code>Integer</code> 的计算不会造成溢出，因此使用 <code>Integer</code> 的计算结果更可靠。</p>
</li>
<li>
<p><code>Double</code> 用于表示浮点数。长度由机器决定，通常是 64 位。（Haskell 也有 <code>Float</code> 类型，但是并不推荐使用，因为编译器都是针对 <code>Double</code> 来进行优化的，而 <code>Float</code> 类型值的计算要慢得多。）</p>
</li>
</ol>
<p>还有一类是容器类型，最常见的容器类型是列表（List），它可以包含任何类型的元素，例如<code>[Int]</code>表示整数列表，<code>[Char]</code>表示字符列表（也就是 String）。Haskell 中的其他常见容器类型包括：</p>
<ul>
<li><code>Maybe</code>：一个可能包含元素也可能为空的容器。<code>Maybe Int</code>可以包含一个<code>Int</code>或者什么都不包含。</li>
<li><code>Either</code>：一个可以包含两种类型之一的元素的容器。<code>Either String Int</code>可以包含一个<code>String</code>或一个<code>Int</code>。</li>
<li><code>Set</code>：一个包含不重复元素的容器。</li>
<li><code>Map</code>：一个键值对的容器，你可以根据键找到对应的值。</li>
<li><code>Tree</code>：一个树形结构的容器，每个节点都可以包含一个值。</li>
</ul>
<hr>
<p>ghci 也可以设置命令行的参数，可以执行 <code>:set +t</code> 让打印变量时也打印类型</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; :set +t</span><br><span class="line">Prelude&gt; 'c'</span><br><span class="line">'c'</span><br><span class="line">it :: Char</span><br><span class="line"></span><br><span class="line">Prelude&gt; [1,2,3]</span><br><span class="line">[1,2,3]</span><br><span class="line">it :: Num a =&gt; [a]</span><br><span class="line"></span><br><span class="line">Prelude&gt; "abc"</span><br><span class="line">"abc"</span><br><span class="line">it :: [Char]</span><br><span class="line"></span><br><span class="line">Prelude&gt; 1</span><br><span class="line">1</span><br><span class="line">it :: Num p =&gt; p</span><br><span class="line"></span><br><span class="line">Prelude&gt; 0.5</span><br><span class="line">0.5</span><br><span class="line">it :: Fractional p =&gt; p</span><br><span class="line"></span><br><span class="line">Prelude&gt; :m +Data.Ratio</span><br><span class="line">Prelude Data.Ratio&gt; 11%29</span><br><span class="line">11 % 29</span><br><span class="line">it :: Integral a =&gt; Ratio a</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>x :: y</code> 表示表达式 <code>x</code> 的类型为 <code>y</code></li>
<li>[Char] 表示由 char 类型的元素构成的数组。</li>
<li><code>=&gt;</code> 左边表示·变量的类型约束，比如 <code>Num</code> 是类型类，它约束了 <code>p</code> 必须是 <code>Num</code> 类型的变量。右边是表示函数类型。我们看一个复杂的例子</li>
</ul>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">squareSum</span> :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">squareSum</span> x y = (x + y) * (x + y)</span><br></pre></td></tr></tbody></table></figure>
<p>这里 <code>=&gt;</code> 规定 <code>a</code> 是 <code>Num</code> 类型的变量，函数类型是 <code> a -&gt; a -&gt; a</code>。其中函数类型是由 <code>-&gt;</code> 构成的，它表示可以接受一个参数，然后返回一个函数。当接受到 2 个参数后，它就会返回 <code>a</code>。<code>-&gt;</code> 的作用就是将参数和函数返回类型链接在一起。</p>
<p>另外的命令行参数 <code>:type</code> 可以直接地看到变量的类型。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Prelude Data.Ratio&gt; :type 1</span><br><span class="line">1 :: Num p =&gt; p</span><br></pre></td></tr></tbody></table></figure>
<p><strong>显式指定类型</strong></p>
<p><code>::</code> 可以显式指定类型，叫做类型签名。<code>'a' :: Char</code></p>
<h2 id="变量">变量</h2>
<p>如果你曾经用过命令式语言（如 C、C++、Java 等），就会发现 Haskell 的变量和命令式语言的变量很不同：在命令式语言里，一个变量通常用于标识一个内存位置（或者其他类似的东西），并且在任何时候，都可以随意修改这个变量的值。因此在不同时间点上，访问这个变量得出的值可能是完全不同的。</p>
<p>在 Haskell 里，可以使用变量来赋予表达式名字：一旦变量绑定了（也即是，关联起）某个表达式，那么这个变量的值就不会改变。文件 assign.hs 内容是</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">x</span>=<span class="number">1</span></span><br><span class="line"><span class="title">x</span>=<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
<p>结果如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  vim assign.hs</span><br><span class="line">(base) ➜  ghci</span><br><span class="line">Prelude&gt; :load assign.hs</span><br><span class="line">[1 of 1] Compiling Main             ( assign.hs, interpreted )</span><br><span class="line"></span><br><span class="line">assign.hs:2:1: error:</span><br><span class="line">    Multiple declarations of ‘x’</span><br><span class="line">    Declared at: assign.hs:1:1</span><br><span class="line">                 assign.hs:2:1</span><br><span class="line">  |</span><br><span class="line">2 | x=2</span><br><span class="line">  | ^</span><br><span class="line">Failed, no modules loaded.</span><br></pre></td></tr></tbody></table></figure>
<h2 id="函数调用">函数调用</h2>
<p>基本格式是函数名和参数，如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; odd 3</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">Prelude&gt; odd 6</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">Prelude&gt; compare 2 3</span><br><span class="line">LT</span><br><span class="line"></span><br><span class="line">Prelude&gt; compare 3 3</span><br><span class="line">EQ</span><br><span class="line"></span><br><span class="line">Prelude&gt; compare 3 2</span><br><span class="line">GT</span><br></pre></td></tr></tbody></table></figure>
<p><strong>函数的优先级比操作符要高</strong></p>
<p>函数也具有类型，表示输入到输出的映射</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; add a b = a+b</span><br><span class="line">Prelude&gt; add 2 3</span><br><span class="line">5</span><br><span class="line">Prelude&gt; :type add</span><br><span class="line">add :: Num a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></tbody></table></figure>
<p>这里很多的箭头表示，一个数 a 映射到 <code>a -&gt; (a -&gt; a)</code> 函数，也就是返回了 <code>a -&gt; (a -&gt; a)</code> 函数，接着根据 <code>a</code> 的值返回 <code>a -&gt; a</code> 函数，直到最后返回一个数。</p>
<h2 id="函数定义">函数定义</h2>
<p><code>add a b = a + b</code> 中， <code>add</code> 是函数名，后面是参数，<code>=</code> 之后是函数体。可以加载定义好的函数，也就是加载模块。</p>
<p>add.hs 里是上述代码，然后</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  vim add.hs</span><br><span class="line">(base) ➜  ghci</span><br><span class="line">Prelude&gt; :load add.hs</span><br><span class="line">[1 of 1] Compiling Main             ( add.hs, interpreted )</span><br><span class="line">Ok, one module loaded.</span><br><span class="line">*Main&gt; add 4.1 5</span><br><span class="line">9.1</span><br></pre></td></tr></tbody></table></figure>
<p>在 Haskell 里，<strong>代码的缩进非常重要</strong>：它会延续（continue）一个已存在的定义，而不是新创建一个。所以，不要省略缩进！</p>
<p>Haskell 也是使用缩进来表示一个表达式或者块延伸的范围的，这点与 Python 类似。Haskell 的缩进规则简单总结起来只用下面三条：</p>
<ol>
<li>源文件中第一个顶级的定义或者声明的缩进，定义了该文件中所有顶级定义或者声明的缩进；</li>
<li>空白行（只有注释的行也认为是空白行）和比前面某一行更加向右的缩进都表示对前面那一行所在块或者表达式的继续；</li>
<li>由 let 和 where 开始的一个块，在 let 或者 where 关键字后第一个定义或者声明的缩进，定义了该块中所有定义或者声明应该具有的缩进。</li>
</ol>
<p>定义函数如下：</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myDrop</span> n xs = <span class="keyword">if</span> n&lt;= <span class="number">0</span> || null xs</span><br><span class="line">    <span class="keyword">then</span> xs</span><br><span class="line">    <span class="keyword">else</span> myDrop (n-<span class="number">1</span>) (tail xs)</span><br><span class="line"><span class="comment">-- null 判断是否是空值，这里是列表是否为空</span></span><br><span class="line"><span class="comment">-- 这里是递归的形式，实际上还是很清楚的</span></span><br></pre></td></tr></tbody></table></figure>
<p>上述代码也支持写成一行：</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myDropX</span> n xs = <span class="keyword">if</span> n &lt;= <span class="number">0</span> || null xs <span class="keyword">then</span> xs <span class="keyword">else</span> myDropX (n - <span class="number">1</span>) (tail xs)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="操作列表的函数">操作列表的函数</h3>
<p><code>head</code> 函数取出列表的第一个元素：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; head [1, 2, 3, 4]</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Prelude&gt; head ['a', 'b', 'c']</span><br><span class="line">'a'</span><br></pre></td></tr></tbody></table></figure>
<p><code>tail</code> 取出列表里<em>除了第一个元素之外的其他元素</em>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; tail [1, 2, 3, 4]</span><br><span class="line">[2,3,4]</span><br><span class="line"></span><br><span class="line">Prelude&gt; tail [2, 3, 4]</span><br><span class="line">[3,4]</span><br><span class="line"></span><br><span class="line">Prelude&gt; tail [True, False]</span><br><span class="line">[False]</span><br></pre></td></tr></tbody></table></figure>
<p><code>take</code> 返回一个包含 <code>l</code> 前 <code>n</code> 个元素的列表：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; take 2 [1, 2, 3, 4, 5]</span><br><span class="line">[1,2]</span><br></pre></td></tr></tbody></table></figure>
<p><code>drop</code> 则返回一个包含 <code>l</code> 丢弃了前 <code>n</code> 个元素之后，剩余元素的列表：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; drop 2 [1, 2, 3, 4, 5]</span><br><span class="line">[3,4,5]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="操作元组的函数">操作元组的函数</h3>
<p>函数 <code>fst</code> 和 <code>snd</code> 接受一个<strong>元组</strong>作为参数，返回该元组的第一个元素和第二个元素：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; fst (1, 'a')</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Prelude&gt; snd (1, 'a')</span><br><span class="line">'a'</span><br></pre></td></tr></tbody></table></figure>
<h2 id="惰性求值">惰性求值</h2>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file: ch02/isOdd.hs</span></span><br><span class="line"><span class="title">isOdd</span> n = mod n <span class="number">2</span> == <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>这是 Haskell 很重要的特性。先说一般的编程语言（命令式编程语言），他们采用严格求值的方法，也就是：函数的参数总是在应用函数之前被求值。以 <code>isOdd</code> 为例子：子表达式 <code>(1 + 2)</code> 会首先被求值，得出结果 <code>3</code> 。接着，将 <code>3</code> 绑定到变量 <code>n</code> ，应用到函数 <code>isOdd</code> 。最后， <code>mod 3 2</code> 返回 <code>1</code> ，而 <code>1 == 1</code> 返回 <code>True</code> 。</p>
<p>但是 Haskell 采用非严格求值，求值 <code>isOdd (1 + 2)</code> 并不会即刻使得子表达式 <code>1 + 2</code> 被求值为 <code>3</code> ，相反，编译器做出了一个“承诺”，说，“当真正有需要的时候，我有办法计算出 <code>isOdd (1 + 2)</code> 的值”。</p>
<h2 id="面向表达式编程">面向表达式编程</h2>
<p>记住，Haskell 是一门以<strong>表达式为主导（expression-oriented）的语言，所有分支都是表达式，所有逻辑都是表达式嵌套表达式</strong>。在命令式语言中，代码由陈述（statement）而不是表达式组成，因此在省略 <code>if</code> 语句的 <code>else</code> 分支的情况下，程序仍是有意义的。但是，当代码由表达式组成时，一个缺少 <code>else</code> 分支的 <code>if</code> 语句，在条件部分为 <code>False</code> 时，是没有办法给出一个结果的，当然这个 <code>else</code> 分支也不会有任何类型，因此，省略 <code>else</code> 分支对于 Haskell 是无意义的，编译器也不会允许这么做。</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myDropX</span> n xs = <span class="keyword">if</span> n &lt;= <span class="number">0</span> || null xs <span class="keyword">then</span> xs <span class="keyword">else</span> myDropX (n - <span class="number">1</span>) (tail xs)</span><br></pre></td></tr></tbody></table></figure>
<p>当执行表达式 <code>myDrop 2 "abcd"</code> 时，函数 <code>myDrop</code> 应用于值 <code>2</code> 和 <code>"abcd"</code> ，变量 <code>n</code> 被绑定为 <code>2</code> ，而变量 <code>xs</code> 被绑定为 <code>"abcd"</code> 。将这两个变量代换到 <code>myDrop</code> 的条件判断部分，就得出了以下表达式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; :type 2 &lt;= 0 || null "abcd"</span><br><span class="line">2 &lt;= 0 || null "abcd" :: Bool</span><br></pre></td></tr></tbody></table></figure>
<p>编译器需要对表达式 <code>2 &lt;= 0 || null "abcd"</code> 进行求值，从而决定 <code>if</code> 该执行哪一个分支。这需要对 <code>(||)</code> 表达式进行求值，而要求值这个表达式，又需要对它的左操作符进行求值：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; 2 &lt;= 0</span><br><span class="line">False</span><br></pre></td></tr></tbody></table></figure>
<p>将值 <code>False</code> 代换到 <code>(||)</code> 表达式当中，得出以下表达式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; :type False || null "abcd"</span><br><span class="line">False || null "abcd" :: Bool</span><br></pre></td></tr></tbody></table></figure>
<p>如果 <code>(||)</code> 左操作符的值为 <code>True</code> ，那么 <code>(||)</code> 就不需要对右操作符进行求值，因为整个 <code>(||)</code> 表达式的值已经由左操作符决定了。[译注：在逻辑或计算中，只要有一个变量的值为真，那么结果就为真。]另一方面，因为这里左操作符的值为 <code>False</code> ，那么 <code>(||)</code> 表达式的值由右操作符的值来决定：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; null "abcd"</span><br><span class="line">False</span><br></pre></td></tr></tbody></table></figure>
<p>最后，将左右两个操作对象的值分别替换回 <code>(||)</code> 表达式，得出以下表达式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; False || False</span><br><span class="line">False</span><br></pre></td></tr></tbody></table></figure>
<p>这个结果表明，下一步要求值的应该是 <code>if</code> 表达式的 <code>else</code> 分支，而这个分支包含一个对 <code>myDrop</code> 函数自身的递归调用： <code>myDrop (2 - 1) (tail "abcd")</code> 。</p>
<h2 id="自定义类型">自定义类型</h2>
<h3 id="基本语法结构">基本语法结构</h3>
<p>以一个在线书店为例子，展示如何去进行类型定义。</p>
<p>使用 <code>data</code> 关键字可以定义新的数据类型：</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file: BookStore.hs</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">BookInfo</span> = <span class="type">Book</span> <span class="type">Int</span> <span class="type">String</span> [<span class="type">String</span>] <span class="keyword">deriving</span>(<span class="type">Show</span>)</span></span><br><span class="line"><span class="title">myInfo</span> = <span class="type">Book</span> <span class="number">9780135072455</span> <span class="string">"Algebra of Programming"</span></span><br><span class="line">              [<span class="string">"Richard Bird"</span>, <span class="string">"Oege de Moor"</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>跟在 <code>data</code> 关键字之后的 <code>BookInfo</code> 就是新类型的名字，我们称 <code>BookInfo</code> 为<strong>类型构造器</strong>。类型构造器用于指代（refer）类型。正如前面提到过的，类型名字的首字母必须大写，因此，类型构造器的首字母也必须大写。</p>
<p>接下来的 <code>Book</code> 是<strong>值构造器</strong>（有时候也称为数据构造器）的名字，也就是声明变量时用的名字。类型的值就是由值构造器创建的。值构造器名字的首字母也必须大写。</p>
<p><strong>在 Haskell 里，类型的名字（类型构造器）和值构造器的名字是相互独立的。类型构造器只能出现在类型的定义，或者类型签名当中。而值构造器只能出现在实际的代码中。值构造器既可以是一般意义上的值，也可以是函数。</strong></p>
<p>在 <code>Book</code> 之后的 <code>Int</code> ， <code>String</code> 和 <code>[String]</code> 是类型的<em>组成部分</em>。组成部分的作用，和面向对象语言的类中的域作用一致：它是一个储存值的槽。（为了方便起见，我们通常也将组成部分称为域。）</p>
<p>在这个例子中， <code>Int</code> 表示一本书的 ID ，而 <code>String</code> 表示书名，而 <code>[String]</code> 则代表作者。<code>deriving (Show)</code> 表示继承了 Show 的属性，可以被打印出来。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; :load BookStore.hs</span><br><span class="line">[1 of 1] Compiling Main             ( BookStore.hs, interpreted )</span><br><span class="line">Ok, one module loaded.</span><br><span class="line">*Main&gt; myInfo</span><br><span class="line">Book 9780135072455 "Algebra of Programming" ["Richard Bird","Oege de Moor"]</span><br><span class="line"></span><br><span class="line">*Main&gt; a = Book 0 "The Book of Imaginary Beings" ["Jorge Luis Borges"]</span><br><span class="line">*Main&gt; a</span><br><span class="line">Book 0 "The Book of Imaginary Beings" ["Jorge Luis Borges"]</span><br></pre></td></tr></tbody></table></figure>
<p>可以获取相关信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; :info BookInfo</span><br><span class="line">type BookInfo :: *</span><br><span class="line">data BookInfo = Book Int String [String]</span><br><span class="line">        -- Defined at BookStore.hs:1:1</span><br><span class="line">instance [safe] Show BookInfo -- Defined at BookStore.hs:1:51</span><br><span class="line"></span><br><span class="line">*Main&gt; :t Book</span><br><span class="line">Book :: Int -&gt; String -&gt; [String] -&gt; BookInfo</span><br></pre></td></tr></tbody></table></figure>
<p>在函数中的用法也比较类似，需要声明值选择器</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; data Coord = Coord Int Int deriving (Show)</span><br><span class="line"></span><br><span class="line">*Main&gt; x = Coord 3 4</span><br><span class="line"></span><br><span class="line">*Main&gt; x</span><br><span class="line">Coord 3 4</span><br><span class="line"></span><br><span class="line">*Main&gt; add (Coord x y) = x+y</span><br><span class="line">*Main&gt; add x</span><br><span class="line">7</span><br></pre></td></tr></tbody></table></figure>
<p>多个自定义类型的用法也是类似的，理解表达式绑定到变量对应的位置即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; add (Coord x y) (Coord a b) = x+y+a+b</span><br><span class="line">*Main&gt; x = Coord 1 2</span><br><span class="line">*Main&gt; y = Coord 10 20</span><br><span class="line">*Main&gt; add x y</span><br><span class="line">33</span><br></pre></td></tr></tbody></table></figure>
<h3 id="类型别名">类型别名</h3>
<p>和 C 语言非常类似，<code>type</code> 关键字用于设置类型别名，其中新的类型名字放在 <code>=</code> 号的左边，而已有的类型名字放在 <code>=</code> 号的右边。这两个名字都标识同一个类型，因此，类型别名完全是为了提高可读性而存在的。</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">CustomerID</span> = <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">ReviewBody</span> = <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">BetterReview</span> = <span class="type">BetterReview</span> <span class="type">BookInfo</span> <span class="type">CustomerID</span> <span class="type">ReviewBody</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="多个值构造器">多个值构造器</h3>
<p>当一个类型拥有一个以上的值构造器时，这些值构造器通常被称为“备选”（alternatives）或“分支”（case）。同一类型的所有备选，创建出的的值的类型都是相同的。<strong>这相当于实现了「枚举类型」或者反映了 「多态性」，但是又比较特殊，因为每个分支都是一个表达式，既是类型也可以是函数其实函数和值都是表达式</strong>。值构造器相当于构造函数。</p>
<h4 id="枚举类型">枚举类型</h4>
<p>代数数据类型的各个值构造器都可以接受任意个数的参数。[译注：不同备选之间接受的参数个数不必相同，参数的类型也可以不一样。]以下是一个账单数据的例子：</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file: BookStore.hs</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">CardHolder</span> = <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">CardNumber</span> = <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Address</span> = [<span class="type">String</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">BillingInfo</span> = <span class="type">CreditCard</span> <span class="type">CardNumber</span> <span class="type">CardHolder</span> <span class="type">Address</span></span></span><br><span class="line">                 | <span class="type">CashOnDelivery</span></span><br><span class="line">                 | <span class="type">Invoice</span> <span class="type">CustomerID</span></span><br><span class="line">                   <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>这个程序提供了三种付款的方式。如果使用信用卡付款，就要使用 <code>CreditCard</code> 作为值构造器，并输入信用卡卡号、信用卡持有人和地址作为参数。如果即时支付现金，就不用接受任何参数。最后，可以通过货到付款的方式来收款，在这种情况下，只需要填写客户的 ID 就可以了。</p>
<p>也就是说，先设置了类型别名，类似于 C 语言的 <code>typedef</code>，让类型的可读性更好。然后 <code> BillingInfo</code> 类型有三个枚举类型，通过模式匹配确定选择哪两个。</p>
<h4 id="Just-和-Maybe">Just 和 Maybe</h4>
<p>对于自定义的类型，往往会出现无意义的情况或者不需要返回值的情况，或者是错误处理的情况，这相当于其他语言里的 <code>null</code> 和 <code>nil</code>。所以，就出现了内置的 <code>Nothing</code> 类型。</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">BillingInfo</span> = <span class="type">CreditCard</span> <span class="type">CardNumber</span> <span class="type">CardHolder</span> <span class="type">Address</span></span></span><br><span class="line">                 | <span class="type">CashOnDelivery</span></span><br><span class="line">                 | <span class="type">Invoice</span> <span class="type">CustomerID</span></span><br><span class="line">                 | <span class="type">Nothing</span></span><br><span class="line">                   <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>更进一步，为了处理存在 <code>Nothing</code> 的模式匹配，加入了新的关键字 <code>Maybe</code> 和 <code>Just</code>。<code>Maybe</code> 表示变量可以表示空值。比如上面的代码，可以定义一个 <code>Maybe</code> 变量。<code>Just</code> 必须和 <code>Maybe</code> 配合使用，当不为空值是必须要有 <code>Just</code>，没有 <code>Just</code> 的 <code>Maybe</code> 变量就只能赋值 <code>billingInfo=Nothing</code>。</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">billingInfo</span> :: <span class="type">Maybe</span> <span class="type">BillingInfo</span></span><br><span class="line"><span class="title">billingInfo</span> = <span class="type">Just</span> (<span class="type">CreditCard</span> <span class="string">"1234"</span> <span class="string">"John"</span> <span class="string">"123 main St."</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>具体来说，如果是使用了 <code>Maybe</code> ，表示可以匹配值构造器或者 <code>Nothing</code>，在错误处理中很有用。</p>
<h4 id="多态性">多态性</h4>
<p>Haskell 是强类型的语言，所以参数的类型都是有明确的规定的，也存在对应其他语言中「泛型」或者「模板」的语法。这也是通过枚举类型实现的。</p>
<p>比如我们需要打印 JSON 的某个值，但是 JSON 类型有 String、Number、Boolean、Object (JSON object)、Array、null，难道每种类型都要写非常类似的函数吗？我们可以通过多态简化。</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多态</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">JValue</span></span></span><br><span class="line">  = <span class="type">JString</span> <span class="type">String</span></span><br><span class="line">  | <span class="type">JNumber</span> <span class="type">Double</span></span><br><span class="line">  | <span class="type">JBool</span> <span class="type">Bool</span></span><br><span class="line">  | <span class="type">JNull</span></span><br><span class="line">  | <span class="type">JObject</span> [(<span class="type">String</span>, <span class="type">JValue</span>)]</span><br><span class="line">  | <span class="type">JArray</span> [<span class="type">JValue</span>]</span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 类型名字</span></span><br><span class="line"><span class="title">getValue</span> (<span class="type">JValue</span>) |</span><br><span class="line"></span><br><span class="line"><span class="title">getString</span> :: <span class="type">JValue</span> -&gt; <span class="type">Maybe</span> <span class="type">String</span></span><br><span class="line"><span class="title">getString</span> (<span class="type">JString</span> s) = <span class="type">Just</span> s</span><br><span class="line"><span class="title">getString</span> _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">getInt</span> (<span class="type">JNumber</span> n) = <span class="type">Just</span> (truncate n)</span><br><span class="line"><span class="title">getInt</span> _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">getDouble</span> (<span class="type">JNumber</span> n) = <span class="type">Just</span> n</span><br><span class="line"><span class="title">getDouble</span> _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">getBool</span> (<span class="type">JBool</span> b) = <span class="type">Just</span> b</span><br><span class="line"><span class="title">getBool</span> _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">getObject</span> (<span class="type">JObject</span> o) = <span class="type">Just</span> o</span><br><span class="line"><span class="title">getObject</span> _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">getArray</span> (<span class="type">JArray</span> a) = <span class="type">Just</span> a</span><br><span class="line"><span class="title">getArray</span> _ = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">isNull</span> v = v == <span class="type">JNull</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="递归类型">递归类型</h3>
<h4 id="列表举例">列表举例</h4>
<p>上一小节提到了多个值构造器形成多态的特性，我们可以利用这一点实现非常简洁的递归类型。**本质上，列表就是递归类型。**后面将会提到，列表 <code>[1, 2]</code> 实际上只是 <code>(1:(2:[]))</code> 的一种简单的表示方式。具体的表达式如下：</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a = <span class="type">Cons</span> a (<span class="type">List</span> <span class="title">a</span>)</span></span><br><span class="line">            | <span class="type">Nil</span></span><br><span class="line">              <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>具体使用方法如下，<code>Cons</code> 需要两个参数，第一个参数可以是任何可以的类型，第二个参数必须是我们定义的 <code>List</code> 类型。怎么判断是否是 <code>List</code> 类型呢，这需要观察变量的表达式。例如 <code>Nil</code> 就是一个 <code>List a</code> 类型。当匹配不到 <code>Cons</code> 值构造器的时候，就会选择 <code>Nil</code></p>
<p>注意 <code>it</code> 是特殊的变量，表示交互式解释器里，输出的上一个变量。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">初始的 List 变量是 Nil，然后添加 1</span><br><span class="line">Prelude&gt; Cons 1 Nil</span><br><span class="line">Cons 1 Nil</span><br><span class="line"></span><br><span class="line">Prelude&gt; it</span><br><span class="line">Cons 1 Nil</span><br><span class="line"></span><br><span class="line">Prelude&gt; Cons 2 it</span><br><span class="line">Cons 2 (Cons 1 Nil)</span><br><span class="line"></span><br><span class="line">Prelude&gt; Cons 2 it</span><br><span class="line">Cons 2 (Cons 2 (Cons 1 Nil))</span><br></pre></td></tr></tbody></table></figure>
<p>如果我们把 <code>Cons</code> 替换成 <code>:</code> 实际上就和列表在结构上相同了。</p>
<h4 id="二叉树举例">二叉树举例</h4>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>)</span></span><br><span class="line">            | <span class="type">Empty</span></span><br><span class="line">              <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>当匹配到是 Node 的值就选择 Node，否则选择 Empty。如果熟悉二叉树的话，这是很容易理解的。</p>
<h3 id="和其他语言类比">和其他语言类比</h3>
<p>以下是一个 C 结构，它等同于我们前面定义的 <code>BookInfo</code> 类型：</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">struct</span> book_info {</span><br><span class="line">    int id;</span><br><span class="line">    char *name;</span><br><span class="line">    char *authors;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>目前来说， C 结构和 Haskell 的代数数据类型最大的差别是，<strong>Haskell 代数数据类型的成分是匿名且按位置排序的</strong>，也就是说位置才决定了绑定的那个类型，而不是通过名字。</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">BookInfo</span> = <span class="type">Book</span> <span class="type">Int</span> <span class="type">String</span> [<span class="type">String</span>]</span></span><br><span class="line">                <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>C 和 C++ 里的 <code>enum</code> 通常用于表示一系列符号值排列。代数数据类型里面也有相似的东西，一般称之为<em>枚举类型</em>。</p>
<p>以下是一个 <code>enum</code> 例子：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">roygbiv</span> {</span><br><span class="line">    red,</span><br><span class="line">    orange,</span><br><span class="line">    yellow,</span><br><span class="line">    green,</span><br><span class="line">    blue,</span><br><span class="line">    indigo,</span><br><span class="line">    violet,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>以下是等价的 Haskell 代码：</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file: Roygbiv.hs</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Roygbiv</span> = <span class="type">Red</span></span></span><br><span class="line">             | <span class="type">Orange</span></span><br><span class="line">             | <span class="type">Yellow</span></span><br><span class="line">             | <span class="type">Green</span></span><br><span class="line">             | <span class="type">Blue</span></span><br><span class="line">             | <span class="type">Indigo</span></span><br><span class="line">             | <span class="type">Violet</span></span><br><span class="line">               <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>在 ghci 里面测试：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; :load Roygbiv.hs</span><br><span class="line">[1 of 1] Compiling Main             ( Roygbiv.hs, interpreted )</span><br><span class="line">Ok, modules loaded: Main.</span><br><span class="line"></span><br><span class="line">*Main&gt; :type Yellow</span><br><span class="line">Yellow :: Roygbiv</span><br><span class="line"></span><br><span class="line">*Main&gt; :type Red</span><br><span class="line">Red :: Roygbiv</span><br><span class="line"></span><br><span class="line">*Main&gt; Red == Yellow</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">*Main&gt; Green == Green</span><br><span class="line">True</span><br></pre></td></tr></tbody></table></figure>
<h2 id="模式匹配">模式匹配</h2>
<p>简单地说，记住<strong>表达式在 Haskell 中很重要，只要对应的输入有对应的输出，那么就是正确的</strong>，所以如下的函数也是正确的</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file: myNot.hs</span></span><br><span class="line"><span class="title">myNot</span> <span class="type">True</span> = <span class="type">False</span></span><br><span class="line"><span class="title">myNot</span> <span class="type">False</span> = <span class="type">True</span></span><br></pre></td></tr></tbody></table></figure>
<p>初看上去，代码似乎同时定义了两个 <code>myNot</code> 函数，但实际情况并不是这样 —— Haskell 允许将函数定义为<em>一系列等式</em>： <code>myNot</code> 的两个等式分别定义了函数对于输入参数在不同模式之下的行为。对于每行等式，模式定义放在函数名之后， <code>=</code> 符号之前。</p>
<p>首先调用 <code>myNot</code> ， Haskell 运行时检查输入参数 <code>False</code> 是否和第一个模式的值构造器匹配 —— 答案是不匹配，于是它继续尝试匹配第二个模式 —— 这次匹配成功了，于是第二个等式右边的值被作为结果返回。</p>
<p>再看一个例子，在 Haskell 里，<strong>列表 <code>[1, 2]</code> 实际上只是 <code>(1:(2:[]))</code> 的一种简单的表示方式</strong>，其中 <code>(:)</code> 用于构造列表。</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sumList</span> (x:xs) = x + sumList xs</span><br><span class="line"><span class="title">sumList</span> []  = <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="通配符">通配符</h3>
<p>比较特殊的是<strong>通配符</strong>，如果一些值无所谓，那么直接用 <code>_</code> 代替即可，避免函数参数不匹配匹配。比如获取坐标中横坐标的值</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; x = Coord 1 2</span><br><span class="line">*Main&gt; xcoord (Coord x y)=x</span><br><span class="line">*Main&gt; xcoord x</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>也可以写成</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; xcoord (Coord x _)=x</span><br><span class="line">*Main&gt; x</span><br><span class="line">Coord 1 2</span><br><span class="line">*Main&gt; xcoord x</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<h3 id="形式匹配">形式匹配</h3>
<p>在 Haskell 中，形式匹配通常使用 case 表达式、函数定义、let 语句、where 子句等方式来实现。在 Haskell 中，case 表达式可以用于将一个表达式与一组模式进行匹配，并执行相应的代码。case 表达式的基本形式如下：</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span></span><br><span class="line">  pattern1 -&gt; code1</span><br><span class="line">  pattern2 -&gt; code2</span><br><span class="line">  ...</span><br><span class="line">  patternN -&gt; codeN</span><br></pre></td></tr></tbody></table></figure>
<p><code>expression</code> 是要匹配的表达式，``pattern1<code>到</code>patternN<code> 是不同的模式，</code>code1<code>到</code>codeN` 是对应的代码块。当匹配成功时，对应的代码块将被执行，并返回结果。如果所有的模式都无法匹配，则 case 表达式将返回一个错误或空值。</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">case</span> e <span class="keyword">of</span> { xs@(x:rest) -&gt; <span class="keyword">if</span> x==<span class="number">0</span> <span class="keyword">then</span> rest <span class="keyword">else</span> xs }</span><br></pre></td></tr></tbody></table></figure>
<p><code>xs@(x:rest)</code> 表示将 <code>e</code> 表达式的值绑定到 <code>xs</code> 变量，并将它分解为两部分：头部 <code>x</code> 和尾部 <code>rest</code>。在这个模式中，<code>xs </code>是整个 <code>e </code>表达式的值，<code>x</code> 是 <code>e</code> 表达式的第一个元素，rest 是 e 表达式的剩余部分。如果 <code>e</code> 的头部元素等于 0，则返回 e 的剩余部分<code>rest</code>。否则，返回整个 e 表达式的值 <code>xs</code>。</p>
<hr>
<p>为了方便起见，也可以在定义的时候就指定新类型的元素的名字。请读者仔细观察语法。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; data Coord = Coord {getx::Int,gety::Int} deriving (Show)</span><br><span class="line"></span><br><span class="line">*Main&gt; x = Coord 1 2</span><br><span class="line">*Main&gt; getx x</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>
<p>定义变量的时候也可以更加清楚一些</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; x = Coord {getx = 10,gety =20}</span><br><span class="line">*Main&gt; getx x</span><br><span class="line">10</span><br></pre></td></tr></tbody></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz">Michael L</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz/fp/FP-haskell-1/">https://www.blog-blockchain.xyz/fp/FP-haskell-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Haskell/">Haskell</a></div><div class="post-share"><div class="social-share" data-image="/images/haskell.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/geth/block-sync/" title="区块同步"><img class="cover" src="/images/geth.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">区块同步</div></div><div class="info-2"><div class="info-item-1">深入解析以太坊区块同步机制，包括downloader模块的文件结构、三种同步模式（full sync、fast sync、light sync）以及区块下载、header验证、body处理的完整流程源码分析。</div></div></div></a><a class="pagination-related" href="/fp/FP-haskell-2/" title="Haskell(二)函数式编程"><img class="cover" src="/images/haskell.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Haskell(二)函数式编程</div></div><div class="info-2"><div class="info-item-1">深入学习Haskell函数式编程核心概念，包括递归、高阶函数、柯里化、匿名函数等进阶特性，以及函数组合和惰性求值的实际应用。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/fp/Haskell-summary-toolchain/" title="Haskell(四)总结和工具链"><img class="cover" src="/images/haskell.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-08</div><div class="info-item-2">Haskell(四)总结和工具链</div></div><div class="info-2"><div class="info-item-1">Haskell学习路径总结与开发工具链介绍，包括Stack项目管理、Cabal包管理器、Nix环境管理等实用工具的配置与使用指南。</div></div></div></a><a class="pagination-related" href="/fp/Haskell-epilogue/" title="Haskell(五) 总结和展望"><img class="cover" src="/images/haskell.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="info-item-2">Haskell(五) 总结和展望</div></div><div class="info-2"><div class="info-item-1">Haskell学习之旅的总结与展望，探讨Monad的复杂性管理、类型系统的参数多态性、Lambda演算与范畴论的理论基础及其在函数式编程中的应用。</div></div></div></a><a class="pagination-related" href="/fp/monad/" title="Haskell(三) Monad"><img class="cover" src="/images/haskell.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-27</div><div class="info-item-2">Haskell(三) Monad</div></div><div class="info-2"><div class="info-item-1">深入理解Haskell中的Monad概念，从理论基础到实际应用，包括Functor、Applicative和Monad的层次结构，以及错误处理和副作用管理的实践。</div></div></div></a><a class="pagination-related" href="/fp/project-euler/" title="Haskell(六) Project Euler 练习1-26"><img class="cover" src="/images/haskell.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-14</div><div class="info-item-2">Haskell(六) Project Euler 练习1-26</div></div><div class="info-2"><div class="info-item-1">通过Project Euler经典数学问题练习Haskell编程，涵盖数论算法、质数筛选、递归优化等实战案例，提升函数式编程实际应用能力。</div></div></div></a><a class="pagination-related" href="/fp/FP-haskell-2/" title="Haskell(二)函数式编程"><img class="cover" src="/images/haskell.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-29</div><div class="info-item-2">Haskell(二)函数式编程</div></div><div class="info-2"><div class="info-item-1">深入学习Haskell函数式编程核心概念，包括递归、高阶函数、柯里化、匿名函数等进阶特性，以及函数组合和惰性求值的实际应用。</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">Michael L</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">102</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/learnerLj"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:luoshitou9@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">从技术到商业，从产品到设计，从生活到未来，我会在这里分享我的所思所想，欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD"><span class="toc-text">安装和下载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#haskell-%E7%AE%80%E4%BB%8B"><span class="toc-text">haskell 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-text">函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">操作列表的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%BB%84%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">操作元组的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC"><span class="toc-text">惰性求值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">面向表达式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">自定义类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text">基本语法结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%80%BC%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">多个值构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Just-%E5%92%8C-Maybe"><span class="toc-text">Just 和 Maybe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">多态性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B"><span class="toc-text">递归类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E4%B8%BE%E4%BE%8B"><span class="toc-text">列表举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%BE%E4%BE%8B"><span class="toc-text">二叉树举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%B1%BB%E6%AF%94"><span class="toc-text">和其他语言类比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">形式匹配</span></a></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>Post Series</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/fp/FP-haskell-1/" title="Haskell(一)入门"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(一)入门"></a><div class="content"><a class="title" href="/fp/FP-haskell-1/" title="Haskell(一)入门">Haskell(一)入门</a><time datetime="2022-08-29T13:30:33.000Z" title="Created 2022-08-29 21:30:33">2022-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fp/FP-haskell-2/" title="Haskell(二)函数式编程"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(二)函数式编程"></a><div class="content"><a class="title" href="/fp/FP-haskell-2/" title="Haskell(二)函数式编程">Haskell(二)函数式编程</a><time datetime="2022-08-29T13:50:33.000Z" title="Created 2022-08-29 21:50:33">2022-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fp/monad/" title="Haskell(三) Monad"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(三) Monad"></a><div class="content"><a class="title" href="/fp/monad/" title="Haskell(三) Monad">Haskell(三) Monad</a><time datetime="2023-05-26T16:42:33.000Z" title="Created 2023-05-27 00:42:33">2023-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fp/Haskell-summary-toolchain/" title="Haskell(四)总结和工具链"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(四)总结和工具链"></a><div class="content"><a class="title" href="/fp/Haskell-summary-toolchain/" title="Haskell(四)总结和工具链">Haskell(四)总结和工具链</a><time datetime="2024-01-08T14:01:33.000Z" title="Created 2024-01-08 22:01:33">2024-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fp/Haskell-epilogue/" title="Haskell(五) 总结和展望"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(五) 总结和展望"></a><div class="content"><a class="title" href="/fp/Haskell-epilogue/" title="Haskell(五) 总结和展望">Haskell(五) 总结和展望</a><time datetime="2024-01-09T17:02:33.000Z" title="Created 2024-01-10 01:02:33">2024-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fp/project-euler/" title="Haskell(六) Project Euler 练习1-26"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(六) Project Euler 练习1-26"></a><div class="content"><a class="title" href="/fp/project-euler/" title="Haskell(六) Project Euler 练习1-26">Haskell(六) Project Euler 练习1-26</a><time datetime="2024-01-14T12:28:03.000Z" title="Created 2024-01-14 20:28:03">2024-01-14</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/dev/immortalwrt-ax6000-upgrade/" title="Xiaomi Redmi Router AX6000 ImmortalWrt 升级记录"><img src="https://cdn.blog-blockchain.xyz/2026/02/30b64e37b39e0b482a817643d8100e5d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Xiaomi Redmi Router AX6000 ImmortalWrt 升级记录"></a><div class="content"><a class="title" href="/dev/immortalwrt-ax6000-upgrade/" title="Xiaomi Redmi Router AX6000 ImmortalWrt 升级记录">Xiaomi Redmi Router AX6000 ImmortalWrt 升级记录</a><time datetime="2026-02-19T13:43:00.000Z" title="Created 2026-02-19 21:43:00">2026-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/defi/permit-ecdsa-cryptography/" title="ERC-20 Permit 与 ECDSA 密码学原理"><img src="https://cdn.blog-blockchain.xyz/2026/01/7926570b23eeb56169050989a441e0a6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ERC-20 Permit 与 ECDSA 密码学原理"></a><div class="content"><a class="title" href="/defi/permit-ecdsa-cryptography/" title="ERC-20 Permit 与 ECDSA 密码学原理">ERC-20 Permit 与 ECDSA 密码学原理</a><time datetime="2026-01-09T02:00:00.000Z" title="Created 2026-01-09 10:00:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/career/structural-thoughts-after-one-and-half-years-at-work/" title="职业增长的数学模型：从log(x)到eˣ的跃迁代价"><img src="https://cdn.blog-blockchain.xyz/2026/02/57338184b4fb276c89fe5e77277a4f37.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="职业增长的数学模型：从log(x)到eˣ的跃迁代价"></a><div class="content"><a class="title" href="/career/structural-thoughts-after-one-and-half-years-at-work/" title="职业增长的数学模型：从log(x)到eˣ的跃迁代价">职业增长的数学模型：从log(x)到eˣ的跃迁代价</a><time datetime="2025-12-13T16:00:00.000Z" title="Created 2025-12-14 00:00:00">2025-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/career/find-gold-then-build-factory/" title="困境：从「想明白」到「做出来」的鸿沟"><img src="https://cdn.blog-blockchain.xyz/2026/02/131dd24e0445c2bc1422ed04d661be85.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="困境：从「想明白」到「做出来」的鸿沟"></a><div class="content"><a class="title" href="/career/find-gold-then-build-factory/" title="困境：从「想明白」到「做出来」的鸿沟">困境：从「想明白」到「做出来」的鸿沟</a><time datetime="2025-10-27T17:11:20.000Z" title="Created 2025-10-28 01:11:20">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/finance/fundiing-rate/" title="资金费率套利完整指南"><img src="https://cdn.blog-blockchain.xyz/2026/02/2882ad3aa493489c4cb0d9c60a862bb8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="资金费率套利完整指南"></a><div class="content"><a class="title" href="/finance/fundiing-rate/" title="资金费率套利完整指南">资金费率套利完整指南</a><time datetime="2025-10-05T10:26:20.000Z" title="Created 2025-10-05 18:26:20">2025-10-05</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2020 - 2026 By Michael L</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js?v=1771518382860"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="local-search-input"><input placeholder="Search for Posts" type="text"></div><hr><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div></div></div><script src="/bundle.js"></script><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})();
(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})();
(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '467d9506710fff22dc33',
      clientSecret: '2a3e530b895af9c94d4bbe95fe78c69317f4d76e',
      repo: 'blog-gitalk',
      owner: 'learnerLj',
      admin: ['learnerLj'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '661da61fbc5902a4b2ae382dfc7c798f'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></body></html>