<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Haskell(二)函数式编程 | Jiahao Luo</title><meta name="author" content="Michael(Jiahao) Luo"><meta name="copyright" content="Michael(Jiahao) Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Haskell(一)入门Haskell(二)函数式编程Haskell(三) MonadHaskell(四)总结和工具链Haskell(五) 总结和展望Haskell(六) Project Euler 练习1-26  首先，我们需要将自己的编程观念从命令式语言转换到函数式语言上面来。这样做的原因并不是因为命令式语言不好，而是因为比起命令式语言，函数式语言更胜一筹。 基本用法 先看一些简单的程序，了">
<meta property="og:type" content="article">
<meta property="og:title" content="Haskell(二)函数式编程">
<meta property="og:url" content="https://www.blog-blockchain.xyz/fp/FP-haskell-2/index.html">
<meta property="og:site_name" content="Jiahao Luo">
<meta property="og:description" content="Haskell(一)入门Haskell(二)函数式编程Haskell(三) MonadHaskell(四)总结和工具链Haskell(五) 总结和展望Haskell(六) Project Euler 练习1-26  首先，我们需要将自己的编程观念从命令式语言转换到函数式语言上面来。这样做的原因并不是因为命令式语言不好，而是因为比起命令式语言，函数式语言更胜一筹。 基本用法 先看一些简单的程序，了">
<meta property="og:locale">
<meta property="og:image" content="https://www.blog-blockchain.xyz/images/haskell.png">
<meta property="article:published_time" content="2022-08-29T13:50:33.000Z">
<meta property="article:modified_time" content="2024-11-15T14:30:54.922Z">
<meta property="article:author" content="Michael(Jiahao) Luo">
<meta property="article:tag" content="Haskell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.blog-blockchain.xyz/images/haskell.png"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://www.blog-blockchain.xyz/fp/FP-haskell-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=5.2.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?372b8854d18acf62880149b1e08e1901";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=QXcJQjXxTMeUwnWykFW2xw"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'QXcJQjXxTMeUwnWykFW2xw')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'QXcJQjXxTMeUwnWykFW2xw', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Haskell(二)函数式编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Jiahao Luo" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/site-avator.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jiahao Luo</span></a><a class="nav-page-title" href="/"><span class="site-name">Haskell(二)函数式编程</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Haskell(二)函数式编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-08-29T13:50:33.000Z" title="Created 2022-08-29 21:50:33">2022-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-15T14:30:54.922Z" title="Updated 2024-11-15 22:30:54">2024-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/functional-language/">functional language</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>27mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><blockquote>
<ol class="series-items"><li><a href="/fp/FP-haskell-1/" title="Haskell(一)入门">Haskell(一)入门</a></li><li><a href="/fp/FP-haskell-2/" title="Haskell(二)函数式编程">Haskell(二)函数式编程</a></li><li><a href="/fp/monad/" title="Haskell(三) Monad">Haskell(三) Monad</a></li><li><a href="/fp/Haskell-summary-toolchain/" title="Haskell(四)总结和工具链">Haskell(四)总结和工具链</a></li><li><a href="/fp/Haskell-epilogue/" title="Haskell(五) 总结和展望">Haskell(五) 总结和展望</a></li><li><a href="/fp/project-euler/" title="Haskell(六) Project Euler 练习1-26">Haskell(六) Project Euler 练习1-26</a></li></ol>
</blockquote>
<p>首先，我们需要将自己的编程观念从命令式语言转换到函数式语言上面来。这样做的原因并不是因为命令式语言不好，而是因为比起命令式语言，函数式语言更胜一筹。</p>
<h1>基本用法</h1>
<p>先看一些简单的程序，了解基本用法。</p>
<p>斐波那契数列：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fab</span> n = <span class="keyword">if</span> n==<span class="number">1</span>||n==<span class="number">2</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> fab (n-<span class="number">1</span>) + fab (n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>也可以利用模式匹配写成下面的样子，这个类似于分支语句，叫做 Guards</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fab</span> n | n==<span class="number">1</span>||n==<span class="number">2</span> =<span class="number">1</span> | n&gt;<span class="number">2</span> = (fab (n-<span class="number">1</span>) + fab (n-<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>在 Haskell 中，<code>|</code> 被用于定义函数的多重条件分支。它可以用来在函数定义中指定多个条件，并根据不同的条件执行不同的代码。它的基本语法形式如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">functionName</span> pattern1 | condition1 = codeBlock1</span><br><span class="line">                     | condition2 = codeBlock2</span><br><span class="line">                     | condition3 = codeBlock3</span><br><span class="line">                     ...</span><br><span class="line">                     | otherwise  = codeBlockN</span><br></pre></td></tr></table></figure>
<p>其中，<code>functionName </code>是函数名，<code>pattern1 </code>是函数的参数模式，<code>condition1</code>、<code>condition2</code>、<code>condition3 </code>等是不同的条件，<code>codeBlock1</code>、<code>codeBlock2</code>、<code>codeBlock3 </code>等是相应的代码块，<code>otherwise </code>是最后一个条件，用于匹配所有的其他情况。在多重条件分支中，只有第一个匹配的条件的代码块将被执行，其他的条件将被忽略。</p>
<p><strong><code>where</code>关键字或内置函数，可在运行时用于生成所需的输出，暂存中间的计算结果</strong>。当函数计算变得复杂时，这将非常有用。<code>where</code>子句将整个表达式分解成小部分。</p>
<p><code>do</code> 关键字引入一个块，标识那些带有副作用的代码</p>
<p>求二次方程的根：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">roots</span> (a, b, c) = (x1, x2) <span class="keyword">where</span></span><br><span class="line">  x1 = e + sqrt d/(<span class="number">2</span>*a)</span><br><span class="line">  x2 = e - sqrt d/(<span class="number">2</span>*a)</span><br><span class="line">  d = b * b - <span class="number">4</span> * a * c</span><br><span class="line">  e = -b/(<span class="number">2</span>*a)</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">   putStrLn <span class="string">&quot;The roots of our Polynomial equation are:&quot;</span></span><br><span class="line">   print (roots(<span class="number">1</span>,-<span class="number">8</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<h1>循环</h1>
<p>Haskell 既没有 <code>for</code> 循环，也没有 <code>while</code> 循环，一般用递归来代替。</p>
<h2 id="递归示例-1">递归示例 1</h2>
<p>例如一个 C 函数，它将字符串表示的数字转换成整数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">as_int</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> acc; <span class="comment">// accumulate the partial result</span></span><br><span class="line">    <span class="keyword">for</span> (acc = <span class="number">0</span>; <span class="built_in">isdigit</span>(*str); str++)&#123;</span><br><span class="line">        acc = acc * <span class="number">10</span> + (*str -<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以写成递归的形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">loop</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> acc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(str) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        acc = acc * <span class="number">10</span> + *str - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        *str++;</span><br><span class="line">        <span class="keyword">return</span> loop(str, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">as_int</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> loop(str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[] = <span class="string">&quot;124&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, as_int(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 Haskell 递归来实现的话可能会简洁一些。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 库函数，字符转数字</span></span><br><span class="line"><span class="keyword">import</span> Data.Char (<span class="title">digitToInt</span>)</span><br><span class="line"><span class="title">asInt</span> :: <span class="type">String</span> -&gt; <span class="type">Int</span> <span class="comment">-- 定义函数类型</span></span><br><span class="line"><span class="title">asInt</span>  = loop <span class="number">0</span></span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    loop :: <span class="type">Int</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Int</span> <span class="comment">--定义函数类型，也即下面的形式</span></span><br><span class="line">    loop acc [] = acc <span class="comment">-- acc 是整数变量，空列表就返回累积的数</span></span><br><span class="line">    <span class="comment">-- 如果不为空，那么继续累积</span></span><br><span class="line">    loop acc (x:xs) = <span class="keyword">let</span> acc&#x27; = acc * <span class="number">10</span> + digitToInt x</span><br><span class="line">                      <span class="keyword">in</span> loop acc&#x27; xs</span><br></pre></td></tr></table></figure>
<p>可以看到，函数式编程语言相比命令式编程语言，提供了截然不同的视角。</p>
<p>这里使用到了 <code>let ... in</code> 关键字，它的含义是在 <code>let</code> 后定义局部表达式，然后在 <code>in</code> 后面用上。可以见 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://stackoverflow.com/users/5053374/libby">Libby</a> 的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://stackoverflow.com/a/52705857/15272222">回答</a></p>
<blockquote>
<p><code>in</code> goes along with <code>let</code> to name one or more local expressions in a pure function.</p>
<p>So, to use a simpler example,</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> =</span><br><span class="line"><span class="title">let</span> greeting = <span class="string">&quot;hello&quot;</span> <span class="keyword">in</span></span><br><span class="line"> print (greeting ++ <span class="string">&quot; world&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>would print “hello world”.</p>
<p>But you could also use lots of <code>let</code>s:</p>
<figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> =</span><br><span class="line"><span class="title">let</span> greeting = <span class="string">&quot;hello&quot;</span></span><br><span class="line">   greetee  = <span class="string">&quot;world&quot;</span> <span class="keyword">in</span></span><br><span class="line"> print (greeting ++ <span class="string">&quot; &quot;</span> ++ greetee)</span><br></pre></td></tr></table></figure>
<p>And you just need one <code>in</code> before you use the names you just defined.</p>
</blockquote>
<h2 id="递归示例-2">递归示例 2</h2>
<p>考虑以下 C 函数， <code>square</code> ，它对数组中的所有元素执行平方计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">square</span><span class="params">(<span class="type">double</span> *out, <span class="type">const</span> <span class="type">double</span> *in, <span class="type">size_t</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        out[i] = in[i] * in[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码展示了一个直观且常见的 loop 动作，它对输入数组中的所有元素执行同样的动作。以下是 Haskell 版本的 <code>square</code> 函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- file: ch04/square.hs</span></span><br><span class="line"></span><br><span class="line"><span class="title">square</span> :: [<span class="type">Double</span>] -&gt; [<span class="type">Double</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">square</span> (x:xs) = x*x : square xs</span><br><span class="line"><span class="title">square</span> []     = []</span><br></pre></td></tr></table></figure>
<p>可以看到，非常的简洁，因为 Haskell 本身就采用递归的形式去定义列表。</p>
<h2 id="递归示例-3">递归示例 3</h2>
<p>因为对列表逐元素操作非常常见，所以内置了 <code>map</code> 函数，用法是 <code>map func oprand</code>。比如上一个问题可以写成这样</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Char (<span class="title">toUpper</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">square2</span> xs = map squareOne xs</span><br><span class="line">    <span class="keyword">where</span> squareOne x = x * x</span><br><span class="line"></span><br><span class="line"><span class="title">upperCase2</span> xs = map toUpper xs</span><br></pre></td></tr></table></figure>
<p>map 函数是一个非常常用的函数，它可以将一个函数应用到列表中的每一个元素，并将结果放入一个新的列表中。map 函数的类型签名和源码为</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map</span> _ []     = []</span><br><span class="line"><span class="title">map</span> f (x:xs) = f x : map f xs</span><br></pre></td></tr></table></figure>
<p>其中，a 和 b 是任意类型，map 函数接受两个参数：一个函数 f，以及一个列表 xs。它将 f 应用于 xs 中的每一个元素，并返回一个新的列表，其中包含了 f 应用于每一个元素后的结果。</p>
<h2 id="递归示例-4">递归示例 4</h2>
<p>对列表进行筛选，这也是很常见的，可以实现模式匹配来完成，也就是分支。这里是筛选列表中奇数元素。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">oddList</span> :: [<span class="type">Int</span>] -&gt; [<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">oddList</span> (x:xs) | odd x     = x : oddList xs</span><br><span class="line">               | otherwise = oddList xs</span><br><span class="line"><span class="title">oddList</span> []                 = []</span><br></pre></td></tr></table></figure>
<p>Haskell 也内置了过滤的函数 <code>filter</code>，从下面的例子也可以看出用法，它可以将一个谓词函数应用到列表中的每一个元素上，并返回一个新的列表，其中只包含满足谓词条件的元素。函数签名和源码如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter</span> _pred []    = []</span><br><span class="line"><span class="title">filter</span> pred (x:xs)</span><br><span class="line">  | pred x         = x : filter pred xs</span><br><span class="line">  | otherwise      = filter pred xs</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">oddList</span> xs = filter condition xs</span><br><span class="line">  <span class="keyword">where</span> condition x = odd x</span><br></pre></td></tr></table></figure>
<h2 id="递归示例-5">递归示例 5</h2>
<p>折叠函数也是非常常见的，也就是每次取出列表的第一个元素，然后不断累积。因此，可以写出递归的形式：</p>
<p><code>foldl func initial_value list</code>，<code>func</code> 是对每个元素怎么操作，其中<code>func</code> 需要是接受 <code>a</code>, <code>b</code> 返回 <code>a</code> 的函数 <code>initial_value</code> 是初始的累加值，<code>list</code> 是被折叠列表。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl</span> :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span><br><span class="line"></span><br><span class="line"><span class="title">foldl</span> step zero (x:xs) = foldl step (step zero x) xs</span><br><span class="line"><span class="title">foldl</span> _ zero []        = zero</span><br></pre></td></tr></table></figure>
<p>所以，字符串转数字可以更加简洁。step 函数必须是两个参数，第一个参数是累加值，第二个参数是列表中取出的元素。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Char (<span class="title">digitToInt</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">asInt</span> xs = foldl step <span class="number">0</span> xs</span><br><span class="line">  <span class="keyword">where</span> step acc x = acc*<span class="number">10</span> + digitToInt x</span><br></pre></td></tr></table></figure>
<p>再比如列表求和也可以写成</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sumList</span> xs = foldl step <span class="number">0</span> xs</span><br><span class="line">  <span class="keyword">where</span> step acc x = acc+x</span><br></pre></td></tr></table></figure>
<p>也可以简单的写成</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sumList</span> xs = foldl (+) <span class="number">0</span> xs</span><br></pre></td></tr></table></figure>
<p>也就是只需要定义累加值和元素的操作即可。</p>
<p>除了左折叠，也有右折叠 <code>foldr</code>，用法是相同的。</p>
<p><strong>但是不推荐使用<code>foldl</code></strong>，因为 Haskell 采用<strong>惰性求值</strong>(或者叫 <strong>非严格求值</strong>)，不到最后一刻就不会求值，会把大量的表达式存储在内存中，可能造成内存泄漏。而且效率也不高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foldl (+) 0 (1:2:3:[])</span><br><span class="line">          == foldl (+) (0 + 1)             (2:3:[])</span><br><span class="line">          == foldl (+) ((0 + 1) + 2)       (3:[])</span><br><span class="line">          == foldl (+) (((0 + 1) + 2) + 3) []</span><br><span class="line">          ==           (((0 + 1) + 2) + 3)</span><br></pre></td></tr></table></figure>
<p>每个表达式都保存在一个块中，这么多表达式嵌套，内存消耗会比较大，远不如直接进行数值运算。比如，内置的函数会显示堆栈溢出，而优化后的函数可以快速求解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; foldl  (+) 0 [1..100000000]</span><br><span class="line">*** Exception: stack overflow</span><br><span class="line"></span><br><span class="line">Prelude&gt; :module +Data.List</span><br><span class="line">Prelude Data.List&gt; foldl&#x27;  (+) 0 [1..100000000]</span><br><span class="line">5000000050000000</span><br></pre></td></tr></table></figure>
<h1>匿名函数</h1>
<p>有时，我们需要编写一个在应用程序的整个生命周期中只能使用一次的函数。为了应对这种情况，Haskell 开发人员使用了另一个称为 lambda 表达式或 lambda 函数的匿名块。Lambda 函数由<code>\</code>字符表示。关于它存在的意义，可以参考 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://stackoverflow.com/users/1482749/kosmikus">kosmikus</a> 的回答：</p>
<blockquote>
<p>Many Haskell functions are “higher-order functions”, i.e., they expect other functions as parameters. Often, the functions we want to pass to such a higher-order function are used only once in the program, at that particular point. It’s simply more convenient then to use a lambda expression than to define a new local function for that purpose.</p>
</blockquote>
<p>这里高阶函数的意思是，把函数作为参数的函数，前面提到的 <code>map</code> <code>filter</code> 都是高阶函数。例如这里只要大于 10 的偶数，那么直接用匿名函数，就不需要再用 <code>where</code> 去解释说明了。但是 也说明 lambda 函数的定义只能有一条语句。我们在很多情况下都会避免使用 lambda 。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> (\ x -&gt; even x &amp;&amp; x &gt; <span class="number">10</span>) [<span class="number">1</span>..<span class="number">20</span>]</span><br></pre></td></tr></table></figure>
<p>匿名函数以反斜杠符号 <code>\</code> 为开始，后跟函数的参数（可以包含模式），而函数体定义在 <code>-&gt;</code> 符号之后。</p>
<p>例如下面的代码，判断元素是否包含在列表中。<code>isInAny &quot;abc&quot; [&quot;a&quot;,&quot;xyz&quot;,&quot;abcd&quot;]</code> 会返回 True。其中 <code>isInfixOf </code> 用于判断一个列表是否是另一个列表的子串，函数签名为 <code>isInfixOf :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool</code>，<code>Eq</code> 是一个类型类，它表示可以进行相等性测试的类型。<strong>类型类是一组类型的集合</strong>，它们共享一些特定的行为或属性，因此可以用相同的函数或操作符来处理这些类型。</p>
<p><code>import</code> 用于导入其他模块中定义的函数、类型和常量等。导入一个模块时，Haskell 会在当前目录或全局搜索路径中查找指定的模块，并将该模块中的所有可见定义导入到当前模块的作用域中。除了导入整个模块之外，你还可以指定要导入的函数、类型和常量等。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入 Data.List 模块中的所有定义</span></span><br><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入 Data.List 模块中的 sort 和 intersperse 函数</span></span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">sort</span>, <span class="title">intersperse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入 Data.List 模块中的所有定义，但是不包括 foldl 函数</span></span><br><span class="line"><span class="keyword">import</span> Data.List <span class="keyword">hiding</span> (<span class="title">foldl</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入 Data.List 模块中的所有定义，并将它们重命名为 L</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List <span class="keyword">as</span> L</span><br></pre></td></tr></table></figure>
<p>所以，下面 <code>isInAny</code> 第一个参数是 可以进行相等性测试的列表，第二个参数是 <code>a</code> 的类型为 <code>t</code> 的容器类型，比如 <code>a</code> 的列表就是一个容器类型 。所以 <code>needle</code> 是列表，<code>haystack</code> 是包含了列表的容器，比如列表为元素的列表。<code>isInfixOf :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool</code> 需要接受两个列表，表示第二个列表是否包含第一个列表。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List (<span class="title">isInfixOf</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">isInAny</span> :: (<span class="type">Foldable</span> t, <span class="type">Eq</span> a) =&gt; [a] -&gt; t [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isInAny</span> needle haystack = any inSequence haystack</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    inSequence s = needle `isInfixOf` s</span><br><span class="line"><span class="comment">&#123;-相当于</span></span><br><span class="line"><span class="comment">any :: Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool</span></span><br><span class="line"><span class="comment">isInAny needle haystack = any (isInfixOf needle) haystack</span></span><br><span class="line"><span class="comment">函数签名可以这样看 any ([a]-&gt;Bool) [[a]]，最终返回Bool</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>isInfixOf</code>：反引号表示标识符转换成二元中缀运算符，也就是参数可以写在两边。</li>
</ul>
<p>可以写成下面的形式</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">isInAny</span> needle haystack = any (\s -&gt; needle `isInfixOf` s) haystack</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.blog-blockchain.xyz/202304091323989.png" alt="image-20230409132322865"></p>
<p>注意 ghci 多行代码的写法，首先是 <code>:&#123;</code> 换行，然后开始写，最后单独一行 <code>&#125;:</code>，比如下图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; :&#123;</span><br><span class="line">ghci| isInAny :: (Foldable t, Eq a) =&gt; [a] -&gt; t [a] -&gt; Bool</span><br><span class="line">ghci| isInAny needle haystack = any inSequence haystack</span><br><span class="line">ghci|   where</span><br><span class="line">ghci|     inSequence s = needle `isInfixOf` s</span><br><span class="line">ghci| :&#125;</span><br></pre></td></tr></table></figure>
<h1>函数柯里化</h1>
<p>柯里化：当一个函数有多个参数的时候，先传递一部分参数调用它(这部分参数以后永远不变)，然后返回一个新的函数接收剩余的参数，返回结果。</p>
<p>这其实很像链式调用，但是更加灵活。我们曾经提到 <code>a-&gt;a-&gt;a</code> 表示的是连续的返回值，第一次返回函数 <code>a-&gt;a</code>，第二次返回 <code>a</code>。**在 Haskell 中，所有函数都只接受一个参数！**但是为了方便起见，从语法上来说，我们也可以说它接受多个参数。下面看几个例子。</p>
<h2 id="第一个例子">第一个例子</h2>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">dropWhile</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">isSpace</span> :: <span class="type">Char</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">dropWhile</span> isSpace :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dropWhile</code> 是内置函数，第一个参数是条件，第二个参数是列表，遍历列表，从左到右去除满足条件的元素，直到出现不满足条件的元素。</li>
<li><code>isSpace</code> 是 <code>Data.Char</code> 里的函数，判断字符是否是空格。</li>
</ul>
<p>可以发现，实际上 <code>dropWhile</code> 只接受一个参数，然后接受了之后就变成了新的表达式。<code>a</code> 表示不限制类型，<code>isSpace</code> 作为参数之后，就变成了 <code>[Char] -&gt; [Char]</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*Main&gt; :m +Data.Char</span><br><span class="line">*Main Data.Char&gt; dropWhile isSpace &quot;    a b&quot;</span><br><span class="line">&quot;a b&quot;</span><br></pre></td></tr></table></figure>
<h2 id="第二个例子">第二个例子</h2>
<p><code>zip3</code> 函数是将三个列表转换成一个三元组。类型如下，请仔细观察函数类型的变化，可以非常直观地理解柯里化的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; :type zip3</span><br><span class="line">zip3 :: [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)]</span><br><span class="line"></span><br><span class="line">*Main Data.Char&gt; :t zip3 &quot;foo&quot;</span><br><span class="line">zip3 &quot;foo&quot; :: [b] -&gt; [c] -&gt; [(Char, b, c)]</span><br><span class="line"></span><br><span class="line">*Main Data.Char&gt; :t zip3 &quot;foo&quot; &quot;bar&quot;</span><br><span class="line">zip3 &quot;foo&quot; &quot;bar&quot; :: [c] -&gt; [(Char, Char, c)]</span><br><span class="line"></span><br><span class="line">*Main Data.Char&gt; :t zip3 &quot;foo&quot; &quot;bar&quot; &quot;quux&quot;</span><br><span class="line">zip3 &quot;foo&quot; &quot;bar&quot; &quot;quux&quot; :: [(Char, Char, Char)]</span><br><span class="line"></span><br><span class="line">Prelude&gt; zip3 &quot;foo&quot; &quot;bar&quot; &quot;quux&quot;</span><br><span class="line">[(&#x27;f&#x27;,&#x27;b&#x27;,&#x27;q&#x27;),(&#x27;o&#x27;,&#x27;a&#x27;,&#x27;u&#x27;),(&#x27;o&#x27;,&#x27;r&#x27;,&#x27;u&#x27;)]</span><br></pre></td></tr></table></figure>
<h2 id="回顾例子">回顾例子</h2>
<p>重新回顾我们在匿名函数中讨论过的例子</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List (<span class="title">isInfixOf</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">isInAny</span> :: (<span class="type">Foldable</span> t, <span class="type">Eq</span> a) =&gt; [a] -&gt; t [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isInAny</span> needle haystack = any inSequence haystack</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    inSequence s = needle `isInfixOf` s</span><br></pre></td></tr></table></figure>
<p>其中 EQ 类型类用于相等的条件判断，也就是可比较的类型。</p>
<blockquote>
<p>The <strong>Eq</strong> typeclass provides an interface for testing for equality. Any type where it makes sense to test for equality between two values of that type should be a member of the <strong>Eq</strong> class. All standard Haskell types except for IO (the type for dealing with input and output) and functions are a part of the <strong>Eq</strong> typeclass.</p>
<p>–<a target="_blank" rel="noopener external nofollow noreferrer" href="http://learnyouahaskell.com/types-and-typeclasses">http://learnyouahaskell.com/types-and-typeclasses</a></p>
</blockquote>
<p>所以说，<code>isInAny</code> 的参数是可折叠的类型和可以比较的类型。实际上的等价映射是 <code>[a] -&gt; t [a] -&gt; Bool</code>，首先需要一个列表，然后可折叠类型的元素逐个和可比较的类型相比，最后返回布尔值。</p>
<p>又看 <code>any</code> 的类型 <code>any :: Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool</code>，发现它是一个可折叠类型；</p>
<p>又看 <code>inSequence</code> 的类型 <code>inSequence :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool</code> 是一个做比较返回布尔值的类型。</p>
<p>总之，函数定义的时候可以简化，<strong>如果已经高阶函数的函子已经定义了参数，那么定义时可以省略高阶函数的最后一个参数</strong>，因为<code>any</code> 已经指定了函数类型了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*Main Data.Char&gt; isInAny needle = any (\s -&gt; needle `isInfixOf` s)</span><br><span class="line">*Main Data.Char&gt; :type isInAny</span><br><span class="line">isInAny :: (Foldable t, Eq a) =&gt; [a] -&gt; t [a] -&gt; Bool</span><br></pre></td></tr></table></figure>
<h1>节（section)</h1>
<p>之前提到过，使用反引号 `` <code>可以将标识符转换成二元中缀运算符。而节比较特殊，使用括号包围一个操作符，通过在括号里面提供左操作对象或者右操作对象，可以产生一个部分应用函数。具体来说</code>(*3)` 就是部分应用函数，可以实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; map (2^) [3, 5, 7, 9]</span><br><span class="line">[8,32,128,512]</span><br></pre></td></tr></table></figure>
<h1>As-模式</h1>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">suffixes</span> :: [a] -&gt; [[a]]</span><br><span class="line"><span class="title">suffixes</span> xs@(_ : xs&#x27;) = xs : suffixes xs&#x27;</span><br><span class="line"><span class="title">suffixes</span> [] = []</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print $suffixes <span class="string">&quot;foot&quot;</span></span><br></pre></td></tr></table></figure>
<p>As-模式在之前已经学习过了。源码里面用到了新引入的 <code>@</code> 符号，模式 <code>xs@(_:xs')</code> 被称为 as-模式，它的意思是：如果输入值能匹配 <code>@</code> 符号右边的模式（这里是 <code>(_:xs')</code> ），那么就将这个值绑定到 <code>@</code> 符号左边的变量中（这里是 <code>xs</code> ）。相当于多了一个参数，从 <code>xs</code> 中拆解出了 <code>xs'</code>。</p>
<p>As-模式还有其他作用：它可以对输入数据进行共享，而不是复制它，减少了内存消耗。</p>
<p><code>$</code> 运算符表示右结合，相当于给右边的部分加一个括号，用于简化函数的嵌套调用，比如如何的用法。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 括号版本</span></span><br><span class="line"><span class="title">sum</span> (filter (&gt; <span class="number">0</span>) (map (* <span class="number">2</span>) [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 $ 运算符</span></span><br><span class="line"><span class="title">sum</span> $ filter (&gt; <span class="number">0</span>) $ map (* <span class="number">2</span>) [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>运算符 <code>.</code> 的功能类似，可以将多个函数组合成一个新的函数，将右侧的函数作为左侧函数的参数。这样可以少写几个括号，看起来更加简洁。下面新的函数 <code>h</code> 表示参数先加 <code>1</code>，然后再乘以 <code>2</code>，从而得到一个新的输出结果。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义一个函数 f 和一个函数 g</span></span><br><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">f</span> x = x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">g</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">g</span> x = x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 . 运算符将 f 和 g 组合成一个新的函数 h</span></span><br><span class="line"><span class="title">h</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">h</span> = f . g</span><br></pre></td></tr></table></figure>
<h1>严格求值</h1>
<p>严格求值就是非惰性求值，它解决了暂存大量的表达式造成堆栈溢出的问题，但是如果不适当地使用，会增大计算量。</p>
<p>之前地例子是 <code>foldl</code> 非严格求值，而 <code>foldl'</code> 是严格求值。<code>seq</code> 函数是比较典型地严格求值的例子。我大致的理解是，</p>
<blockquote>
<p>（seq a b）it evaluates the first argument <code>a</code> to weak head normal form (WHNF). The only guarantee given by <code>seq</code> is that the both <code>a</code> and <code>b</code> will be evaluated before <code>seq</code> returns a value.</p>
<p>——<a target="_blank" rel="noopener external nofollow noreferrer" href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html#v:seq">https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html#v:seq</a></p>
</blockquote>
<p>也就是说，在返回之前它会把第一个参数求值，直到满足 WHNF，但是不一定 <code>a</code> 比 <code>b</code> 先求值。比如如果 <code>a</code> 依赖 <code>b</code>，那么就可能是 <code>b</code> 先求值。</p>
<p>WHNF 是什么呢？可以参考下面的回答：</p>
<blockquote>
<p><strong>Normal form</strong>: An expression in normal form is fully evaluated, and no sub-expression could be evaluated any further (i.e. it contains no un-evaluated thunks).</p>
<p><strong>Weak head normal form</strong>: An expression in weak head normal form has been evaluated to the outermost data constructor or lambda abstraction (the <em>head</em>). Sub-expressions <em>may or may not have been evaluated</em>. Therefore, every normal form expression is also in weak head normal form, though the opposite does not hold in general.</p>
<p>– <a target="_blank" rel="noopener external nofollow noreferrer" href="https://stackoverflow.com/a/6889335/15272222">https://stackoverflow.com/a/6889335/15272222</a></p>
</blockquote>
<p>来看一个例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myFoldl</span> f a [] = a</span><br><span class="line"><span class="title">myFoldl</span> f a (x : xs) = <span class="keyword">let</span> a&#x27; = f a x <span class="keyword">in</span> a&#x27; `seq` myFoldl f a&#x27; xs</span><br><span class="line"></span><br><span class="line"><span class="title">mySum</span> xs = myFoldl (\x b -&gt; x + b) <span class="number">0</span> xs</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = print $ mySum [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><code>seq</code> 让 <code>let a' = f a x in a'</code> 严格求值。</p>
<h1>斐波那契数列的优化</h1>
<p>这一部分会学些一些编码技巧，斐波那契数列最直观的逻辑如下，但是函数对应的值是不会缓存的，所以会具有指数级复杂度。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fibOriginal</span> :: <span class="type">Int</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">fibOriginal</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">fibOriginal</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fibOriginal</span> n = fibOriginal (n - <span class="number">1</span>) + fibOriginal (n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>我们考虑缓存中间结果，这样就可以节省计算量。<code>cache</code> 是一个列表，缓存了结果，如果缓存了特定的位置，那么就求值，否则这个位置是 Nothing。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fibList</span> :: <span class="type">Int</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">fibList</span> n = fib&#x27; n (replicate (n + <span class="number">1</span>) <span class="type">Nothing</span>)</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    fib&#x27; :: <span class="type">Int</span> -&gt; [<span class="type">Maybe</span> <span class="type">Integer</span>] -&gt; <span class="type">Integer</span></span><br><span class="line">    fib&#x27; <span class="number">0</span> cache = <span class="number">0</span></span><br><span class="line">    fib&#x27; <span class="number">1</span> cache = <span class="number">1</span></span><br><span class="line">    fib&#x27; n cache =</span><br><span class="line">      <span class="keyword">case</span> cache !! n <span class="keyword">of</span></span><br><span class="line">        <span class="type">Just</span> value -&gt; value</span><br><span class="line">        <span class="type">Nothing</span> -&gt;</span><br><span class="line">          <span class="keyword">let</span> value = fib&#x27; (n - <span class="number">1</span>) cache + fib&#x27; (n - <span class="number">2</span>) cache</span><br><span class="line">              newCache = updateCache n value cache</span><br><span class="line">          <span class="keyword">in</span> fib&#x27; n newCache</span><br><span class="line"></span><br><span class="line">    updateCache :: <span class="type">Int</span> -&gt; <span class="type">Integer</span> -&gt; [<span class="type">Maybe</span> <span class="type">Integer</span>] -&gt; [<span class="type">Maybe</span> <span class="type">Integer</span>]</span><br><span class="line">    updateCache _ _ [] = []</span><br><span class="line">    updateCache <span class="number">0</span> value (_:xs) = <span class="type">Just</span> value : xs</span><br><span class="line">    updateCache n value (x:xs) = x : updateCache (n - <span class="number">1</span>) value xs</span><br></pre></td></tr></table></figure>
<p>但是普通列表更新数据地复杂度是 n，很慢。换成映射会快许多。<code>cache</code> 就是 Map 类型。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Map (<span class="type">Map</span>) <span class="comment">-- 只导入 Map 类型。</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> Map <span class="comment">--导入了整个 Data.Map 模块，为这个模块创建了一个别名 Map</span></span><br><span class="line"></span><br><span class="line"><span class="title">fibMap</span> :: <span class="type">Int</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">fibMap</span> n = fst $ fib&#x27; n <span class="type">Map</span>.empty</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    fib&#x27; :: <span class="type">Int</span> -&gt; <span class="type">Map</span> <span class="type">Int</span> <span class="type">Integer</span> -&gt; (<span class="type">Integer</span>, <span class="type">Map</span> <span class="type">Int</span> <span class="type">Integer</span>)</span><br><span class="line">    fib&#x27; <span class="number">0</span> cache = (<span class="number">0</span>, cache)</span><br><span class="line">    fib&#x27; <span class="number">1</span> cache = (<span class="number">1</span>, cache)</span><br><span class="line">    fib&#x27; n cache =</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Map</span>.lookup n cache <span class="keyword">of</span></span><br><span class="line">        <span class="type">Just</span> value -&gt; (value, cache)</span><br><span class="line">        <span class="type">Nothing</span> -&gt;</span><br><span class="line">          <span class="keyword">let</span> (fibNMinus1, cache1) = fib&#x27; (n - <span class="number">1</span>) cache</span><br><span class="line">              (fibNMinus2, cache2) = fib&#x27; (n - <span class="number">2</span>) cache1</span><br><span class="line">              value = fibNMinus1 + fibNMinus2</span><br><span class="line">          <span class="keyword">in</span> (value, <span class="type">Map</span>.insert n value cache2) <span class="comment">-- Map.insert :: Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a</span></span><br></pre></td></tr></table></figure>
<p>当然也有 <code>Array</code> 类型，可以完成类似地功能。但是性能不太好</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fibArray</span> :: <span class="type">Int</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">fibArray</span> n = fib&#x27; n (listArray (<span class="number">0</span>, n) (repeat <span class="type">Nothing</span>))</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    fib&#x27; :: <span class="type">Int</span> -&gt; <span class="type">Array</span> <span class="type">Int</span> (<span class="type">Maybe</span> <span class="type">Integer</span>) -&gt; <span class="type">Integer</span></span><br><span class="line">    fib&#x27; <span class="number">0</span> cache = <span class="number">0</span></span><br><span class="line">    fib&#x27; <span class="number">1</span> cache = <span class="number">1</span></span><br><span class="line">    fib&#x27; n cache = <span class="keyword">case</span> cache ! n <span class="keyword">of</span></span><br><span class="line">      <span class="type">Just</span> value -&gt; value</span><br><span class="line">      <span class="type">Nothing</span> -&gt;</span><br><span class="line">        <span class="keyword">let</span> value = fib&#x27; (n - <span class="number">1</span>) cache + fib&#x27; (n - <span class="number">2</span>) cache</span><br><span class="line">            newCache = cache // [(n, <span class="type">Just</span> value)]</span><br><span class="line">        <span class="keyword">in</span> fib&#x27; n newCache</span><br></pre></td></tr></table></figure>
<p>另外一种写法则是利用惰性求值和 memorization</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fibList :: [Integer]</span><br><span class="line">fibList = 0 : 1 : zipWith (+) fibList (tail fibList)</span><br><span class="line"></span><br><span class="line">fib :: Int -&gt; Integer</span><br><span class="line">fib n = fibList !! n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对比的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; fibOriginal 25</span><br><span class="line">75025</span><br><span class="line">(0.41 secs, 43,998,040 bytes)</span><br><span class="line">ghci&gt; fibList 25</span><br><span class="line">75025</span><br><span class="line">(1.41 secs, 251,086,536 bytes)</span><br><span class="line">ghci&gt; fibArray 25</span><br><span class="line">75025</span><br><span class="line">(0.72 secs, 160,534,712 bytes)</span><br><span class="line">ghci&gt; fibMap 25</span><br><span class="line">75025</span><br><span class="line">(0.00 secs, 98,448 bytes)</span><br><span class="line">ghci&gt; fibBest 25</span><br><span class="line">75025</span><br><span class="line">(0.01 secs, 70,696 bytes)</span><br></pre></td></tr></table></figure>
<ol>
<li><code>fibOriginal</code>：编译器有优化。</li>
<li><code>fibList</code>：每次都要遍历列表，表现差</li>
<li><code>fibArray</code>：更新时要复制整个数组，导致较高的内存消耗。</li>
<li><code>fibMap</code>：这是使用 <code>Data.Map</code> 的实现，它是一个平衡二叉搜索树。<code>Data.Map</code> 的更新操作通常比数组更新更高效，因为它可以重用未更改的部分。此外，查找操作也非常快，性能接近 O(log n)。</li>
<li><code>fibBest</code>：则使用了惰性求值和 Memorization，而且也用上了内置的优化。</li>
</ol>
<h1>模块</h1>
<p>模块是组织和管理代码的基本单位。模块可以包含函数、类型、变量等定义，并将它们导出到其他模块中供使用。模块还可以导入其他模块中的定义，并在自己的代码中使用它们。</p>
<p>要定义一个模块，需要使用 <code>module</code> 关键字，后面跟着模块的名称和导出的定义列表。例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MyModule (</span><br><span class="line">    <span class="title">someFunction</span>,</span><br><span class="line">    <span class="title">someType</span>,</span><br><span class="line">    <span class="title">someVariable</span></span><br><span class="line">) <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一些函数、类型、变量等</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个名为 <code>MyModule</code> 的模块，并导出了一些定义，包括一个函数 <code>someFunction</code>、一个类型 <code>someType</code> 和一个变量 <code>someVariable</code>。这些定义可以在其他模块中使用，但如果没有在导出列表中明确导出，它们将无法访问。</p>
<p>下面是一个简单的 Haskell 模块，包含了一些常用的字符串操作函数，如<code>splitOn</code>（用于根据指定的分隔符将列表分割成子列表）、<code>joinWith</code>（用于连接子列表）、<code>startsWith</code>、<code>endsWith</code>（分别用于检查列表是否以给定的前缀/后缀开始/结束）、<code>toLowerStr</code>、<code>toUpperStr</code>（分别用于将字符列表转换为小写/大写）以及<code>trim</code>（用于删除字符列表前后的空白字符）。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> StringUtil</span><br><span class="line">  ( <span class="title">splitOn</span></span><br><span class="line">  , <span class="title">joinWith</span></span><br><span class="line">  , <span class="title">startsWith</span></span><br><span class="line">  , <span class="title">endsWith</span></span><br><span class="line">  , <span class="title">toLowerStr</span></span><br><span class="line">  , <span class="title">toUpperStr</span></span><br><span class="line">  , <span class="title">trim</span></span><br><span class="line">  , <span class="title">isSpace</span></span><br><span class="line">  ) <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.Char (<span class="title">isSpace</span>, <span class="title">toLower</span>, <span class="title">toUpper</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- | 根据指定的分隔符将列表分割成子列表。</span></span><br><span class="line"><span class="title">splitOn</span> :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; [[a]]</span><br><span class="line"><span class="title">splitOn</span> _ [] = []  <span class="comment">-- 如果输入列表为空，则返回空列表</span></span><br><span class="line"><span class="title">splitOn</span> sep list = <span class="keyword">case</span> break (== sep) list <span class="keyword">of</span></span><br><span class="line">  (chunk, []) -&gt; [chunk] <span class="comment">-- 如果找不到分隔符，则返回整个列表作为唯一的子列表</span></span><br><span class="line">  (chunk, _ : rest) -&gt; chunk : splitOn sep rest <span class="comment">-- 如果找到分隔符，将分割出的子列表添加到结果中，并继续处理剩余部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | 使用指定的分隔符连接子列表。</span></span><br><span class="line"><span class="title">joinWith</span> :: a -&gt; [[a]] -&gt; [a]</span><br><span class="line"><span class="title">joinWith</span> _ [] = [] <span class="comment">-- 如果输入的子列表列表为空，则返回空列表</span></span><br><span class="line"><span class="title">joinWith</span> _ [x] = x <span class="comment">-- 如果输入的子列表列表只有一个元素，则返回该元素</span></span><br><span class="line"><span class="title">joinWith</span> sep (x:xs) = x ++ sep : joinWith sep xs <span class="comment">-- 在当前子列表和下一个子列表之间添加分隔符，并递归处理剩余部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | 检查列表是否以指定的前缀开始。</span></span><br><span class="line"><span class="title">startsWith</span> :: <span class="type">Eq</span> a =&gt; [a] -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">startsWith</span> [] _ = <span class="type">True</span>  <span class="comment">-- 如果前缀为空，则始终返回True</span></span><br><span class="line"><span class="title">startsWith</span> _ [] = <span class="type">False</span> <span class="comment">-- 如果待检查列表为空但前缀不为空，则返回False</span></span><br><span class="line"><span class="title">startsWith</span> (x:xs) (y:ys) = x == y &amp;&amp; startsWith xs ys <span class="comment">-- 比较列表中的每个元素，并递归处理剩余部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | 检查列表是否以指定的后缀结束。</span></span><br><span class="line"><span class="title">endsWith</span> :: <span class="type">Eq</span> a =&gt; [a] -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">endsWith</span> xs ys = startsWith (reverse xs) (reverse ys)</span><br><span class="line"><span class="comment">-- 反转输入的列表和后缀，然后调用 startsWith 函数来检查反转后的列表是否以反转后的后缀开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | 将字符列表转换为小写。</span></span><br><span class="line"><span class="title">toLowerStr</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]</span><br><span class="line"><span class="title">toLowerStr</span> = map <span class="type">Data</span>.<span class="type">Char</span>.toLower <span class="comment">-- 使用 Data.Char.toLower 函数将每个字符转换为小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | 将字符列表转换为大写。</span></span><br><span class="line"><span class="title">toUpperStr</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]</span><br><span class="line"><span class="title">toUpperStr</span> = map <span class="type">Data</span>.<span class="type">Char</span>.toUpper <span class="comment">-- 使用 Data.Char.toUpper 函数将每个字符转换为大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | 删除字符列表前后的空白字符。</span></span><br><span class="line"><span class="title">trim</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]</span><br><span class="line"><span class="title">trim</span> = f . f</span><br><span class="line">  <span class="keyword">where</span> f = reverse . dropWhile isSpace</span><br><span class="line">  <span class="comment">-- 定义辅助函数 f，它首先删除列表开头的空白字符，然后反转列表</span></span><br><span class="line">  <span class="comment">-- 对输入列表应用两次 f 函数，以分别去除前导和尾随的空白字符</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试的结果如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :load str.hs</span><br><span class="line">[<span class="number">1</span> <span class="keyword">of</span> <span class="number">1</span>] <span class="type">Compiling</span> <span class="type">StringUtil</span>       ( str.hs, interpreted )</span><br><span class="line"><span class="type">Ok</span>, one <span class="keyword">module</span> loaded.</span><br><span class="line"></span><br><span class="line">ghci&gt; s = &quot;haha I&#x27;d like talk with you!&quot;</span><br><span class="line"></span><br><span class="line">ghci&gt; splitOn &#x27; &#x27; s</span><br><span class="line"></span><br><span class="line">[&quot;haha&quot;,&quot;I&#x27;d&quot;,&quot;like&quot;,&quot;talk&quot;,&quot;with&quot;,&quot;you!&quot;]</span><br><span class="line"></span><br><span class="line">ghci&gt; joinWith &#x27; &#x27; $ splitOn &#x27; &#x27; s</span><br><span class="line">&quot;haha I&#x27;d like talk with you!&quot;</span><br><span class="line"></span><br><span class="line">ghci&gt; startsWith &quot;I&quot; s</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">ghci&gt; startsWith &quot;ha&quot; s</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">ghci&gt; toLowerStr s</span><br><span class="line">&quot;haha i&#x27;d like talk with you!&quot;</span><br><span class="line"></span><br><span class="line">ghci&gt; toUpperStr s</span><br><span class="line">&quot;HAHA I&#x27;D LIKE TALK WITH YOU!&quot;</span><br><span class="line"></span><br><span class="line">ghci&gt; s_blank = &quot;   &quot;++s++&quot;  &quot;</span><br><span class="line"></span><br><span class="line">ghci&gt; s_blank</span><br><span class="line">&quot;   haha I&#x27;d like talk with you!  &quot;</span><br><span class="line"></span><br><span class="line">ghci&gt; trim s_blank</span><br><span class="line">&quot;haha I&#x27;d like talk with you!&quot;</span><br><span class="line"></span><br><span class="line">ghci&gt; :q</span><br></pre></td></tr></table></figure>
<h1>最后的话</h1>
<p>前面已经介绍过基础知识了，读者已经有了自己深入学习的基础。如果希望能够实际写出程序，那么可以完成<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kowainik/learn4haskell">Learn4Haskell</a>，学习自定义类型、typeclass 和 instance、newtype、带参类型、Externtion、Functor、Applicatives、Monads。</p>
<p>我这里会给出一些经验。</p>
<ol>
<li>
<p><code>where</code> 子句中的模式匹配应该使用 <code>case</code> 语句，而不能直接在 <code>where</code> 子句中进行。在 <code>where</code> 子句中的等式左边不能出现模式。下面的例子是错误的，它用分支来代替了模式匹配，但是 where 子句不行。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">buildWalls</span> city</span><br><span class="line">  | canBuildHouse = city &#123;cityCastle = <span class="type">CastleWithWalls</span> name&#125;</span><br><span class="line">  | otherwise = city</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    canBuildHouse</span><br><span class="line">      | <span class="type">Castle</span> name = totalPeople &gt;= <span class="number">10</span></span><br><span class="line">      | otherwise = <span class="type">False</span></span><br><span class="line">      totalPeople = sum . map (\(<span class="type">House</span> people) -&gt; people) $ cityHouses city</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>匿名函数中可以使用模式匹配，比如 <code>\(House people) -&gt; people</code> 就是匹配 <code>House</code> 类型，提取它的值。<strong>提取自定义类型的变量的值的方式，一般采用模式匹配，嵌套就多次模式匹配</strong>。函数传参也是获取了一次值。模式匹配的语法如下：</p>
<ol>
<li>
<p>分开写函数。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">f</span> <span class="number">0</span> = <span class="string">&quot;Zero&quot;</span></span><br><span class="line"><span class="title">f</span> <span class="number">1</span> = <span class="string">&quot;One&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>case .. of ..</code> 类型的匹配。<strong>case 表达式后面一定紧接一个表达式，不能再用 guard 语法</strong></p>
</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">&quot;The list is &quot;</span> ++ <span class="keyword">case</span> xs <span class="keyword">of</span></span><br><span class="line">  [] -&gt; <span class="string">&quot;empty.&quot;</span></span><br><span class="line">  [x] -&gt; <span class="string">&quot;a singleton list.&quot;</span></span><br><span class="line">  _ -&gt; <span class="string">&quot;a longer list.&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>使用 <code>@</code> 的模式匹配。注意如果 <code>allx@(x:xs)</code> 中 <code>allx</code> 没有用到，建议使用 <code>(x:xs)</code> 代替。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">longestPrefix</span> :: <span class="type">Eq</span> a =&gt; [a] -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">longestPrefix</span> [] _ = []</span><br><span class="line"><span class="title">longestPrefix</span> _ [] = []</span><br><span class="line"><span class="title">longestPrefix</span> allx@(x:xs) ally@(y:ys)</span><br><span class="line">  | x == y = x : longestPrefix xs ys</span><br><span class="line">  | otherwise = []</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用模式匹配的情况有:</p>
<ol>
<li>字面值处理。</li>
<li>列表递归，空列表的情况。</li>
<li>提取复杂类型或者容器特定位置的值。</li>
<li>Maybe/Just 类型匹配。</li>
</ol>
<p>比如我们的例子，可以下面这样写。其中尽量把局部表达式写在子句中，这样变量名可以非常方便的说明逻辑：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">buildWalls</span> :: <span class="type">MagicalCity</span> -&gt; <span class="type">MagicalCity</span></span><br><span class="line"><span class="title">buildWalls</span> city = <span class="keyword">case</span> cityCastle city <span class="keyword">of</span></span><br><span class="line">  (<span class="type">Castle</span> name) -&gt; <span class="keyword">if</span> enoughPopulation  <span class="keyword">then</span> createWalls name  <span class="keyword">else</span> city</span><br><span class="line">  _ -&gt; city</span><br><span class="line">  <span class="keyword">where</span></span><br><span class="line">    createWalls name = city &#123;cityCastle = <span class="type">CastleWithWalls</span> name&#125;</span><br><span class="line">    enoughPopulation = totalPeople &gt;= <span class="number">10</span></span><br><span class="line">    totalPeople = sum . map (\(<span class="type">House</span> people) -&gt; people) $ cityHouse city</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>类型也有自己的类型，可以作为其他类型的参数。比较典型的是容器比如 <code>[]</code>、<code>Maybe</code>、<code>Either</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IntBox</span> f = <span class="type">MkIntBox</span> (<span class="title">f</span> <span class="type">Int</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 变成了 MkIntBox Maybe Int</span></span><br><span class="line"><span class="title">intBoxMaybe</span> :: <span class="type">IntBox</span> <span class="type">Maybe</span></span><br><span class="line"><span class="title">intBoxMaybe</span> = <span class="type">MkIntBox</span> (<span class="type">Just</span> <span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 变成了 MkIntBox [] Int，也就是 MkInt Box [Int]</span></span><br><span class="line"><span class="title">intBoxList</span> :: <span class="type">IntBox</span> []</span><br><span class="line"><span class="title">intBoxList</span> = <span class="type">MkIntBox</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 变成了 MkIntBox Ether String Int</span></span><br><span class="line"><span class="title">intBoxEither</span> :: <span class="type">IntBox</span> (<span class="type">Either</span> <span class="type">String</span>)</span><br><span class="line"><span class="title">intBoxEither</span> = <span class="type">MkIntBox</span> (<span class="type">Right</span> <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz">Michael(Jiahao) Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz/fp/FP-haskell-2/">https://www.blog-blockchain.xyz/fp/FP-haskell-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Haskell/">Haskell</a></div><div class="post-share"><div class="social-share" data-image="/images/haskell.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/fp/FP-haskell-1/" title="Haskell(一)入门"><img class="cover" src="/images/haskell.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Haskell(一)入门</div></div><div class="info-2"><div class="info-item-1"> Haskell(一)入门Haskell(二)函数式编程Haskell(三) MonadHaskell(四)总结和工具链Haskell(五) 总结和展望Haskell(六) Project Euler 练习1-26  前言 这个系列主要介绍典型的函数式程序设计语言（Functional programming languages，FP）和逻辑式程序设计语言（Logic programming languages，LP），将会分别以 Haskell 和 datalog（主要是 souffle）作为例子，简单的入门和理解。 理解典型的 FP 对于深入学习程序设计语言挺好处的。我们先从 haskell 开始 参考资料：  haskell 官网 Haskell 趣学指南，英文原版也很不错。 快速查阅库文档 最推荐的查阅手册，能够直接点击 Quick Jump 搜索关键词，这也是我最常用的文档 官方 WiKi如果有不懂的术语，那么很推荐先在 wiki 上查找。 可以参考的入门课程 资源汇总 交流学习群、交流学习群...</div></div></div></a><a class="pagination-related" href="/cs-courses/modular-inverses/" title="乘法逆元"><img class="cover" src="/images/cryptology.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">乘法逆元</div></div><div class="info-2"><div class="info-item-1"> C语言基础乘法逆元信息安全算法基础操作系统基础x86汇编基础信息论与编码  辗转相除法 先温习辗转相除法和裴蜀等式： {ax+by=gcd(a,b)(b  mod a)x+ay  =  gcd(a,b)(a  mod(b  mod a))x+(b  mod a)y  =  gcd(a,b)((b  mod a)  mod(a  mod(b  mod a)))x+(a  mod(b  mod a))y=gcd(a,b)\begin{cases} 	ax+by=\mathrm{gcd}\left( a,b \right)\\ 	\left( b\,\,\mathrm{mod}\ a \right) x+ay\,\,=\,\,\mathrm{gcd}\left( a,b \right)\\ 	\left( a\,\,\mathrm{mod} \left( b\,\,\mathrm{mod} \ a \right) \right) x+\left( b\,\,\mathrm{mod}\ a \right) y\,\,=\,\,\mathrm{gcd}\left( a,b...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/fp/Haskell-epilogue/" title="Haskell(五) 总结和展望"><img class="cover" src="/images/haskell.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="info-item-2">Haskell(五) 总结和展望</div></div><div class="info-2"><div class="info-item-1"> Haskell(一)入门Haskell(二)函数式编程Haskell(三) MonadHaskell(四)总结和工具链Haskell(五) 总结和展望Haskell(六) Project Euler 练习1-26  随着我们深入 Haskell 的世界，我们发现它不仅仅是一种编程语言，而是一种带有丰富理论背景的编程范式。Haskell 的设计思想深植于函数式编程的根基，与 Lambda 演算和范畴论紧密相连，体现了逻辑和数学的美学。   Monad：结构化的复杂性管理 在 Haskell 中，Monad 的概念封装了一个层次结构，允许我们在一个定义良好的域内进行操作。Monad 提供了一种方式来构建层次化的结构，支持层次之间的转换。通过 Monad，可以利用自定义的规则进行快速错误处理，无需在每一步都进行错误处理。特别是在 Haskell 中，Monad 以顺序方式组合复杂函数，使不确定的结果、副作用、异常处理都可以通过 Monad 的统一接口进行管理。更进一步，Monad...</div></div></div></a><a class="pagination-related" href="/fp/Haskell-summary-toolchain/" title="Haskell(四)总结和工具链"><img class="cover" src="/images/haskell.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-08</div><div class="info-item-2">Haskell(四)总结和工具链</div></div><div class="info-2"><div class="info-item-1"> Haskell(一)入门Haskell(二)函数式编程Haskell(三) MonadHaskell(四)总结和工具链Haskell(五) 总结和展望Haskell(六) Project Euler 练习1-26  总结  安装方式：https://www.haskell.org/ghcup/ 这是最推荐的安装方式，建议都安装上。 特性介绍：https://www.haskell.org/ 如何入门：  理解基础规则，比如不可变性、绑定、递归 学完基本语法，包括列表、元组、类型、模式匹配、Guard 写法、where 用法、let … in 用法、case … of 用法、@ 用法； 理解函数的类型签名 函数柯里化和 folder、map、zip、filter 等高阶函数、lambda 表达式； $ . 的用法 递归的写法习惯 模块和导出， 语言拓展 Data 库中的 List、Char、Map、Set。一些对应的常见操作 ，比如列表的 take drop sum takeWhile group 等，可以等用到再查。 data 自定义类型（包括 product type 和...</div></div></div></a><a class="pagination-related" href="/fp/FP-haskell-1/" title="Haskell(一)入门"><img class="cover" src="/images/haskell.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-29</div><div class="info-item-2">Haskell(一)入门</div></div><div class="info-2"><div class="info-item-1"> Haskell(一)入门Haskell(二)函数式编程Haskell(三) MonadHaskell(四)总结和工具链Haskell(五) 总结和展望Haskell(六) Project Euler 练习1-26  前言 这个系列主要介绍典型的函数式程序设计语言（Functional programming languages，FP）和逻辑式程序设计语言（Logic programming languages，LP），将会分别以 Haskell 和 datalog（主要是 souffle）作为例子，简单的入门和理解。 理解典型的 FP 对于深入学习程序设计语言挺好处的。我们先从 haskell 开始 参考资料：  haskell 官网 Haskell 趣学指南，英文原版也很不错。 快速查阅库文档 最推荐的查阅手册，能够直接点击 Quick Jump 搜索关键词，这也是我最常用的文档 官方 WiKi如果有不懂的术语，那么很推荐先在 wiki 上查找。 可以参考的入门课程 资源汇总 交流学习群、交流学习群...</div></div></div></a><a class="pagination-related" href="/fp/project-euler/" title="Haskell(六) Project Euler 练习1-26"><img class="cover" src="/images/haskell.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-14</div><div class="info-item-2">Haskell(六) Project Euler 练习1-26</div></div><div class="info-2"><div class="info-item-1"> Haskell(一)入门Haskell(二)函数式编程Haskell(三) MonadHaskell(四)总结和工具链Haskell(五) 总结和展望Haskell(六) Project Euler 练习1-26  本文会选择一些有意思的 Project Euler 的题目，学习怎么用 Haskell 写算法，并且逐渐学习相关语言和数学知识。前 100 题可以直接分享答案，后续的题目就只给暗示和加密的答案，可以发邮件获取解密方式。 代码仓库：https://github.com/learnerLj/projecteuler P1  显然 3 和 5 的倍数，其实是 3 和 5 的倍数，去除重复算的 15 的倍数。而且 3 的倍数的和，还可以化简成求和公式。 1234sumOfMultiples limit = sumDivisible 3 + sumDivisible 5 - sumDivisible 15    where        cumulativeSum n = n * (n + 1) `div` 2        sumDivisible n = n *...</div></div></div></a><a class="pagination-related" href="/fp/monad/" title="Haskell(三) Monad"><img class="cover" src="/images/haskell.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-27</div><div class="info-item-2">Haskell(三) Monad</div></div><div class="info-2"><div class="info-item-1"> Haskell(一)入门Haskell(二)函数式编程Haskell(三) MonadHaskell(四)总结和工具链Haskell(五) 总结和展望Haskell(六) Project Euler 练习1-26  前言 我并不是相关数学理论研究者，而是 Haskell 和 Program language 的爱好者，研究水平还比较低，所以理解有错误是可能发生的，非常欢迎交流和指正。文章中引用了其他博客，我都已经明确注明来源和附带链接，如果您是这些博客的作者，也不同意被引用，那么请联系我。本文借用了 GPT4 写作，提供了非常多的指导。AI 正在改变学习的方式。 另外，我希望读者有一定的近世代数基础，也有一定的编程范式的理解，比如函数式语言（FP），特别是代码讲解都是基于 Haskell。由于我并没有实际的 Haskell 开发经验，所以我不熟悉 Monad的实际应用和用法，这篇文章只是给一个 demo，用于了解编程中的 Monad 的概念。 最后，对于 PL 和 software analysis...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Michael(Jiahao) Luo</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/LearnerLj"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/learnerLj" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:luoshitou9@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">从技术到商业，从产品到设计，从生活到未来，我会在这里分享我的所思所想，欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.1.</span> <span class="toc-text">递归示例 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">2.2.</span> <span class="toc-text">递归示例 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">2.3.</span> <span class="toc-text">递归示例 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">2.4.</span> <span class="toc-text">递归示例 4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">2.5.</span> <span class="toc-text">递归示例 5</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">函数柯里化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">4.1.</span> <span class="toc-text">第一个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">4.2.</span> <span class="toc-text">第二个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E4%BE%8B%E5%AD%90"><span class="toc-number">4.3.</span> <span class="toc-text">回顾例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">节（section)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">As-模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">严格求值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">斐波那契数列的优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">最后的话</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>Post Series</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/fp/FP-haskell-1/" title="Haskell(一)入门"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(一)入门"></a><div class="content"><a class="title" href="/fp/FP-haskell-1/" title="Haskell(一)入门">Haskell(一)入门</a><time datetime="2022-08-29T13:30:33.000Z" title="Created 2022-08-29 21:30:33">2022-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fp/FP-haskell-2/" title="Haskell(二)函数式编程"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(二)函数式编程"></a><div class="content"><a class="title" href="/fp/FP-haskell-2/" title="Haskell(二)函数式编程">Haskell(二)函数式编程</a><time datetime="2022-08-29T13:50:33.000Z" title="Created 2022-08-29 21:50:33">2022-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fp/monad/" title="Haskell(三) Monad"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(三) Monad"></a><div class="content"><a class="title" href="/fp/monad/" title="Haskell(三) Monad">Haskell(三) Monad</a><time datetime="2023-05-26T16:42:33.000Z" title="Created 2023-05-27 00:42:33">2023-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fp/Haskell-summary-toolchain/" title="Haskell(四)总结和工具链"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(四)总结和工具链"></a><div class="content"><a class="title" href="/fp/Haskell-summary-toolchain/" title="Haskell(四)总结和工具链">Haskell(四)总结和工具链</a><time datetime="2024-01-08T14:01:33.000Z" title="Created 2024-01-08 22:01:33">2024-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fp/Haskell-epilogue/" title="Haskell(五) 总结和展望"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(五) 总结和展望"></a><div class="content"><a class="title" href="/fp/Haskell-epilogue/" title="Haskell(五) 总结和展望">Haskell(五) 总结和展望</a><time datetime="2024-01-09T17:02:33.000Z" title="Created 2024-01-10 01:02:33">2024-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fp/project-euler/" title="Haskell(六) Project Euler 练习1-26"><img src="/images/haskell.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Haskell(六) Project Euler 练习1-26"></a><div class="content"><a class="title" href="/fp/project-euler/" title="Haskell(六) Project Euler 练习1-26">Haskell(六) Project Euler 练习1-26</a><time datetime="2024-01-14T12:28:03.000Z" title="Created 2024-01-14 20:28:03">2024-01-14</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/dev/crypto-practice/" title="安全加密实践-GPG"><img src="https://cdn.blog-blockchain.xyz/2024/11/ecd2b676f9bf98a607c67fc697f9ed4e.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安全加密实践-GPG"/></a><div class="content"><a class="title" href="/dev/crypto-practice/" title="安全加密实践-GPG">安全加密实践-GPG</a><time datetime="2024-11-18T09:28:20.000Z" title="Created 2024-11-18 17:28:20">2024-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/backup-practice/" title="传输和备份实践"><img src="https://cdn.blog-blockchain.xyz/2024/11/e9427ec31426e24ea92ff3d40382ed08.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传输和备份实践"/></a><div class="content"><a class="title" href="/dev/backup-practice/" title="传输和备份实践">传输和备份实践</a><time datetime="2024-11-18T09:26:20.000Z" title="Created 2024-11-18 17:26:20">2024-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/macbook/" title="macbook体验"><img src="https://cdn.blog-blockchain.xyz/2024/11/f0e20c6b389a00ecf1945b34324cfdd1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="macbook体验"/></a><div class="content"><a class="title" href="/dev/macbook/" title="macbook体验">macbook体验</a><time datetime="2024-11-16T17:33:20.000Z" title="Created 2024-11-17 01:33:20">2024-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/git/" title="Git合作指南"><img src="https://cdn.blog-blockchain.xyz/2024/11/4c8a976a9e6720e0283852ce24503f1c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git合作指南"/></a><div class="content"><a class="title" href="/dev/git/" title="Git合作指南">Git合作指南</a><time datetime="2024-10-29T16:21:20.000Z" title="Created 2024-10-30 00:21:20">2024-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/python-design/" title="(三）Python面向对象设计模式"><img src="https://cdn.blog-blockchain.xyz/2024/10/b0e9d2ce07312c8cc21c8e0c2fed6f16.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(三）Python面向对象设计模式"/></a><div class="content"><a class="title" href="/dev/python-design/" title="(三）Python面向对象设计模式">(三）Python面向对象设计模式</a><time datetime="2024-10-28T18:53:20.000Z" title="Created 2024-10-29 02:53:20">2024-10-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Michael(Jiahao) Luo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.2.2"></script><script src="/js/main.js?v=5.2.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '467d9506710fff22dc33',
      clientSecret: '2a3e530b895af9c94d4bbe95fe78c69317f4d76e',
      repo: 'blog-gitalk',
      owner: 'learnerLj',
      admin: ['learnerLj'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '59b15428781caee409b1fe64d4c82ffd'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.2.2"></script></div></div></body></html>