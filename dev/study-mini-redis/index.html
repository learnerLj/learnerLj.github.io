<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>深入学习Rust异步编程：mini-redis项目解析 | Jiahao Luo</title><meta name="author" content="Michael(Jiahao) Luo"><meta name="copyright" content="Michael(Jiahao) Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="通过深入分析mini-redis项目学习Rust异步编程和tokio运行时，涵盖项目架构设计、Redis协议实现、连接管理、数据库模块等核心组件，以及测试和命令行工具开发实践。">
<meta property="og:type" content="article">
<meta property="og:title" content="深入学习Rust异步编程：mini-redis项目解析">
<meta property="og:url" content="https://www.blog-blockchain.xyz/dev/study-mini-redis/index.html">
<meta property="og:site_name" content="Jiahao Luo">
<meta property="og:description" content="通过深入分析mini-redis项目学习Rust异步编程和tokio运行时，涵盖项目架构设计、Redis协议实现、连接管理、数据库模块等核心组件，以及测试和命令行工具开发实践。">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.blog-blockchain.xyz/2025/03/7a1eb877711a4e78b90307ccefde92f4.png">
<meta property="article:published_time" content="2025-03-22T20:33:20.000Z">
<meta property="article:modified_time" content="2025-06-18T20:06:28.046Z">
<meta property="article:author" content="Michael(Jiahao) Luo">
<meta property="article:tag" content="rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.blog-blockchain.xyz/2025/03/7a1eb877711a4e78b90307ccefde92f4.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深入学习Rust异步编程：mini-redis项目解析",
  "url": "https://www.blog-blockchain.xyz/dev/study-mini-redis/",
  "image": "https://cdn.blog-blockchain.xyz/2025/03/7a1eb877711a4e78b90307ccefde92f4.png",
  "datePublished": "2025-03-22T20:33:20.000Z",
  "dateModified": "2025-06-18T20:06:28.046Z",
  "author": [
    {
      "@type": "Person",
      "name": "Michael(Jiahao) Luo",
      "url": "https://www.blog-blockchain.xyz/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://www.blog-blockchain.xyz/dev/study-mini-redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?372b8854d18acf62880149b1e08e1901";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=QXcJQjXxTMeUwnWykFW2xw"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'QXcJQjXxTMeUwnWykFW2xw')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'QXcJQjXxTMeUwnWykFW2xw', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深入学习Rust异步编程：mini-redis项目解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Jiahao Luo" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">18</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jiahao Luo</span></a><a class="nav-page-title" href="/"><span class="site-name">深入学习Rust异步编程：mini-redis项目解析</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">深入学习Rust异步编程：mini-redis项目解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-22T20:33:20.000Z" title="Created 2025-03-23 04:33:20">2025-03-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-06-18T20:06:28.046Z" title="Updated 2025-06-19 04:06:28">2025-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/rust/">rust</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>30mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h2 id="前言">前言</h2>
<p>为了深入学习Rust编程的最佳实践，并熟悉成熟且主流的tokio异步运行时，我决定通过学习mini-redis项目来提升自己的Rust高性能编程能力。本文记录了我对该项目的学习过程和理解。</p>
<p>项目地址：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/tokio-rs/mini-redis">https://github.com/tokio-rs/mini-redis</a></p>
<h2 id="项目架构概览">项目架构概览</h2>
<pre class="mermaid">graph TD
    %% Main components with subgraph structure
    subgraph 核心服务器 ["核心服务器组件"]
        server["server<br/>Redis服务器实现"]
        shutdown["shutdown<br/>优雅关闭机制"]
        db["db<br/>键值存储和发布/订阅"]
    end

    subgraph 通信层 ["通信层组件"]
        connection["connection<br/>TCP连接管理"]
        parse["parse<br/>TCP字节流解析"]
        frame["frame<br/>Redis协议帧表示"]
    end

    subgraph 客户端交互 ["客户端交互组件"]
        clients["clients<br/>异步和阻塞客户端"]
        cmd["cmd<br/>Redis命令实现"]
    end

    %% Relationship arrows with labels
    server -->|"初始化和管理"| connection
    server -->|"创建和维护"| db
    server -->|"触发"| shutdown

    connection -->|"发送/接收"| frame
    parse -->|"生成"| frame

    clients -->|"建立"| connection
    clients -->|"发出"| cmd

    cmd -->|"编码为"| frame
    db -->|"响应转换为"| frame

    %% Add clear data flow
    frame -->|"执行并更新"| db
    connection -->|"传递到"| parse

    %% Visual styling
    classDef core fill:#f9d5e5,stroke:#333,stroke-width:1px
    classDef comm fill:#eeeeee,stroke:#333,stroke-width:1px
    classDef client fill:#d0f0c0,stroke:#333,stroke-width:1px

    class server,shutdown,db core
    class connection,parse,frame comm
    class clients,cmd client</pre>
<ol>
<li>
<p><strong>核心服务器组件</strong></p>
<ul>
<li>🔹 <strong>server</strong>：Redis服务器核心，启动服务进程，管理连接和请求处理流程</li>
<li>🔹 <strong>db</strong>：实现键值存储引擎，管理数据结构和发布/订阅功能</li>
<li>🔹 <strong>shutdown</strong>：处理服务器正常关闭流程，确保数据完整性和连接优雅终止</li>
</ul>
</li>
<li>
<p><strong>通信层组件</strong></p>
<ul>
<li>🔹 <strong>connection</strong>：管理TCP连接生命周期，处理网络I/O和事件循环</li>
<li>🔹 <strong>parse</strong>：将TCP字节流解析为协议格式，处理分包和粘包问题</li>
<li>🔹 <strong>frame</strong>：Redis协议帧的编码解码器，转换命令与二进制表示</li>
</ul>
</li>
<li>
<p><strong>客户端交互组件</strong></p>
<ul>
<li>🔹 <strong>clients</strong>：提供异步和阻塞式客户端API，处理连接池和请求队列</li>
<li>🔹 <strong>cmd</strong>：实现Redis命令集，处理命令验证、执行和响应生成</li>
</ul>
</li>
</ol>
<p>服务器启动时初始化各组件，建立连接监听和处理管道。客户端连接请求经由connection组件处理，建立会话。客户端命令经过协议编码，通过连接发送到服务器。服务器解析命令后在db组件中执行，并将结果返回。所有组件共同协作，确保数据流转高效和错误处理完善。</p>
<p>先看一下 mini-redis 的基本功能，具体在 README 里，然后再逐步实现。最简单的读、写、Ping、以及订阅更新的功能。</p>
<h2 id="实现">实现</h2>
<h3 id="db-模块">db 模块</h3>
<h4 id="数据结构和后台任务">数据结构和后台任务</h4>
<pre class="mermaid">classDiagram
    class Db {
        +new() Db
        +get(key: String) Option~Bytes~
        +set(key: String, value: Bytes, expiration: Option~Duration~) void
        +subscribe(channel: String) Receiver~Bytes~
        +publish(channel: String, message: Bytes) usize
    }

    class Shared {
        -state: Mutex~State~
        -background_task: Notify
    }

    class State {
        -entries: HashMap~String, Entry~
        -pub_sub: HashMap~String, Sender~Bytes~~
        -expirations: BTreeSet~(Instant, String)~
        -shutdown: bool
    }

    class Entry {
        -data: Bytes
        -expires_at: Option~Instant~
    }

    class BackgroundTask {
        -run() async
        -expire_keys() usize
        -sleep_until_next_expiration() Future
    }

    Db *-- Shared : contains
    Shared *-- State : protects
    State *-- Entry : stores
    State o-- BackgroundTask : triggers

    note for BackgroundTask "后台任务负责清理过期键值对"
    note for Shared "使用Arc包装，允许多线程共享访问"
    note for Entry "存储值和过期时间"</pre>
<p>Redis 是一个基于键值对的数据结构服务器，它支持多种类型的值，而且我们可以为每个键设置过期时间，到了这个时间点，如果键还没有被更新，它会被自动从数据库中删除。我们的值全部当作是 Bytes 类型，过期时间设置在 value 里。注意有的值是永不过期的，所以 expires_at 是 Option 类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Entry in the key-value store</span></span><br><span class="line">#<span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    <span class="comment">/// Stored data</span></span><br><span class="line">    data: Bytes,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Instant at which the entry expires and should be removed from the</span></span><br><span class="line">    <span class="comment">/// database.</span></span><br><span class="line">    expires_at: <span class="type">Option</span>&lt;Instant&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后需要维护整个 db 状态的变量，它需要不断的扫描过期时间，删除过期的键值对。所以需要使用有序的 时刻-&gt;键 的映射，这里使用 BTreeSet 来实现。</p>
<p>Redis 的 pub/sub 可以设置不同的频道，然后相同的频道可以有多个订阅者，就是一个广播机制。所以就有 频道 -&gt; 广播 的映射。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">/// 键值数据。使用标准的HashMap即可满足需求</span></span><br><span class="line">    entries: HashMap&lt;<span class="type">String</span>, Entry&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 发布/订阅键空间。Redis为键值和发布/订阅使用单独的键空间</span></span><br><span class="line">    pub_sub: HashMap&lt;<span class="type">String</span>, broadcast::Sender&lt;Bytes&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 跟踪键的TTL</span></span><br><span class="line">    <span class="comment">/// 使用BTreeSet按过期时间排序</span></span><br><span class="line">    <span class="comment">/// 这允许后台任务遍历此映射以找到下一个过期的值</span></span><br><span class="line">    expirations: BTreeSet&lt;(Instant, <span class="type">String</span>)&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 当Db实例关闭时为true</span></span><br><span class="line">    <span class="comment">/// 设置为true时通知后台任务退出</span></span><br><span class="line">    shutdown: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>触发过期的检查是在后台线程中进行的，一般是2个触发场景，第一个是后台定时触发，第二个是有新的键值对插入，如果时间比之前的都早，这时候需要更新过期时间。所以需要一个 Notify 来通知后台线程。定时器触发一般注意2点：</p>
<ol>
<li>没有任务时，线程应该休眠，不要空转。</li>
<li>如果有任务，等待的时间应该是下一个的过期时间，而不是固定的时间间隔。</li>
</ol>
<h4 id="读和写">读和写</h4>
<p>读和写都要加锁，因为读写都会修改 entries，所以需要 Mutex 来保护。读的时候数据要 clone 一份，因为哈希表里还是存储着的。</p>
<p>写的时候，如果指定了过期时间，那么需要更新 expirations，如果之前有过期时间，那么需要删除之前的，然后更新。</p>
<h4 id="Pub-Sub">Pub/Sub</h4>
<p>订阅很简单，创建一个 broadcast::channel，返回给客户端一个 Receiver，然后把 Sender 存储到 pub_sub 里。发布的时候，使用相同的频道，发送消息即可。</p>
<h3 id="Redis协议帧">Redis协议帧</h3>
<p>Redis 协议是一个简单的文本协议，它是基于 TCP 的，所以是字节流。我们需要把字节流解析成 Redis 命令，然后执行，然后把结果序列化成字节流返回给客户端。</p>
<p>RESP 是 Redis 客户端和服务器之间通信的协议，设计简单且易于实现。RESP 支持 5 种基本数据类型：</p>
<ol>
<li>简单字符串 (Simple Strings)
<ul>
<li>格式：<code>+&lt;string&gt;\r\n</code></li>
<li>例子：<code>+OK\r\n</code></li>
<li>说明：不能包含换行符。</li>
</ul>
</li>
<li>错误 (Errors)
<ul>
<li>格式：<code>-&lt;error message&gt;\r\n</code></li>
<li>例子：<code>-ERR unknown command 'foobar'\r\n</code></li>
<li>说明：客户端应将其视为异常。</li>
</ul>
</li>
<li>整数 (Integers)
<ul>
<li>格式：<code>:&lt;number&gt;\r\n</code></li>
<li>例子：<code>:1000\r\n</code></li>
<li>说明：64 位有符号整数。</li>
</ul>
</li>
<li>批量字符串 (Bulk Strings)
<ul>
<li>格式：<code>$&lt;length&gt;\r\n&lt;data&gt;\r\n</code></li>
<li>例子：<code>$5\r\nhello\r\n</code></li>
<li>说明：
<ul>
<li>可以表示二进制数据。</li>
<li>空字符串：<code>$0\r\n\r\n</code></li>
<li>空值：<code>$-1\r\n</code></li>
</ul>
</li>
</ul>
</li>
<li>数组 (Arrays)
<ul>
<li>格式：<code>*&lt;number of elements&gt;\r\n&lt;element1&gt;...&lt;elementN&gt;</code></li>
<li>例子：<code>*2\r\n$5\r\nhello\r\n$5\r\nworld\r\n</code></li>
<li>说明：
<ul>
<li>可以包含不同类型的元素。</li>
<li>空数组：<code>*0\r\n</code></li>
<li>空值数组：<code>*-1\r\n</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>客户端请求通常使用数组格式发送命令，例如 SET key value 被编码为：<br>
<code>*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n</code></p>
<p>服务器响应根据命令返回适当的 RESP 数据类型，例如 GET key 可能返回 <code>$5\r\nhello\r\n</code> 或者 <code>$-1\r\n</code>。</p>
<p>根据上面的特征，帧解析的时候，首先读取第一个字节确定类型，然后基于类型解析剩余数据。而且这是典型的字符串状态机，所以可以使用状态机模式来实现，逐步构建完整的 RESP 对象。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A frame in the Redis protocol.</span></span><br><span class="line">#<span class="meta">#[derive(Clone, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Frame</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Simple</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Error</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Integer</span>(<span class="type">u64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Bulk</span>(Bytes),</span><br><span class="line">    Null,</span><br><span class="line">    <span class="title function_ invoke__">Array</span>(<span class="type">Vec</span>&lt;Frame&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>+&lt;string&gt;\r\n</code> 和 <code>-&lt;error message&gt;\r\n</code> 都比较简单，一直找到 <code>\r\n</code> 为止，然后返回 Simple 类型。<br>
如果是整数 <code>:&lt;number&gt;\r\n</code>，则需要额外的判断是否能编码成 u64。<br>
如果是二进制数据 <code>$&lt;length&gt;\r\n&lt;data&gt;\r\n</code>，要注意空字符串和空值的情况。<br>
如果是数组，那么第一个部分是整数格式，然后递归解析每个元素。</p>
<h3 id="连接模块">连接模块</h3>
<p>连接模块实现网络读写Redis帧的功能，基于tokio的异步网络库。一个基本连接需实现：</p>
<ul>
<li>初始化连接：建立底层网络连接</li>
<li>读取数据：从网络连接读取数据</li>
<li>写入数据：向网络连接写入数据</li>
<li>处理数据：解析和处理接收到的数据</li>
<li>维护连接状态：监控连接状态，处理各种事件</li>
</ul>
<p>我们使用BufWriter<TcpStream>而非直接使用TcpStream，它维护内部缓冲区，优化系统交互，减少系统调用。同时使用BytesMut维护读取但未处理的数据，实现零拷贝提升性能。</p>
<p>因为 TCP 协议只保证字节流的顺序，不保证数据包的边界。已经读取但是还没有处理的数据，我们需要维护一个缓冲区，而不是频繁访问系统的TCP缓冲区。常见的做法是使用 Vec<u8> 来维护，但是 BytesMut 实现了零拷贝，只有在实际需要修改的时候才会拷贝，在读取、合并等操作的时候，只是移动指针，所以性能更好。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="comment">// The `TcpStream`. It is decorated with a `BufWriter`, which provides write</span></span><br><span class="line">    <span class="comment">// level buffering. The `BufWriter` implementation provided by Tokio is</span></span><br><span class="line">    <span class="comment">// sufficient for our needs.</span></span><br><span class="line">    stream: BufWriter&lt;TcpStream&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The buffer for reading frames.</span></span><br><span class="line">    buffer: BytesMut,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当读到一个数据流的时候，要尝试解析成一个完整的 RESP 帧，如果解析成功，就返回一个 Frame，<br>
然后把剩余的数据放回 buffer 里。具体解析的时候，使用 Cursor 来读取 buffer，方便设置 position，处理字节流。如果构成一个完整的 RESP 帧，就要记得 advance，把已经处理的字节去掉，这段内存空出来。此时 buffer 又开始从 0 开始。</p>
<p>如果解析失败，就继续读取，直到解析成功。考虑特殊情况，如果读取字节为0，说明对端关闭了连接，如果此时buffer还存在数据，就说明是异常断开了。</p>
<p>写入的时候，需要把Frame序列化成字节流，然后写入到 stream 里，要注意写入的字节流可能比较大，所以要分步写入，直到全部写入完成。最后记得 flush，把缓冲区的数据写入到系统的 TCP 缓冲区。</p>
<h3 id="服务器模块">服务器模块</h3>
<p>这个模块就开始汇总前面的模块，实现一个完整的 Redis 服务器。<br>
一般都是一个很大的结构体，然后实现一些需要对外部暴露的方法，比如启动、关闭、处理连接等。内部的各个子结构体，就是各个功能模块，接着在这个大结构体里逐渐启动。大结构体里，除了各个模块的实例，还有一些共享的数据，比如配置、日志、计数器，尤其是一些控制信号，用于协调各个模块的工作，比如停止服务的顺序。这个设计模式叫做：中介者模式。</p>
<p>然后一个模块有更新，比如协议更新，出现了并存的实例，那么这个局部可以使用外观模式，把这些实例隐藏起来，对外暴露一个接口，这个接口可以根据配置，选择不同的实例。</p>
<p>控制信号需要 2 个，一个用于通知连接退出，因为 redis 服务器可能有多个客户端连接，每个连接都有自己的 TCP 连接进来，<br>
当服务器退出的时候，需要通知所有的连接退出。<br>
另一个是通知后台线程退出，比如数据库的部分，它在不断的扫描过期时间，删除过期的键值对，这个是一个后台线程，需要通知它退出。</p>
<p>另外一个控制信号是并发控制，限制服务器接收的 TCP 连接数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">    db_holder: DbDropGuard,</span><br><span class="line"></span><br><span class="line">    listener: TcpListener,</span><br><span class="line"></span><br><span class="line">    limit_connections: Arc&lt;Semaphore&gt;,</span><br><span class="line">    notify_shutdown: broadcast::Sender&lt;()&gt;,</span><br><span class="line">    shutdown_complete_tx: mpsc::Sender&lt;()&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般启动服务器时，要考虑控制信号，还有一些程序的初始化，比如日志，<br>
一些rust运行时的参数，比如线程数，这些都是全局的，需要在启动的时候初始化。</p>
<p>所以最外层的结构体，一般是这样的，shutdown 收到之后，会退出这个select：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tokio::<span class="built_in">select!</span> &#123;</span><br><span class="line">     res = server.<span class="title function_ invoke__">run</span>() =&gt; &#123;</span><br><span class="line">         <span class="comment">// If an error is received here, accepting connections from the TCP</span></span><br><span class="line">         <span class="comment">// listener failed multiple times and the server is giving up and</span></span><br><span class="line">         <span class="comment">// shutting down.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// Errors encountered when handling individual connections do not</span></span><br><span class="line">         <span class="comment">// bubble up to this point.</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(err) = res &#123;</span><br><span class="line">             error!(cause = %err, <span class="string">&quot;failed to accept&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     _ = shutdown =&gt; &#123;</span><br><span class="line">         <span class="comment">// The shutdown signal has been received.</span></span><br><span class="line">         info!(<span class="string">&quot;shutting down&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>整个服务器是个大循环，首先需要信号量有空闲，才允许新的连接进来，<br>
然后监听新的连接，把连接和后台服务模块打包进 Handler，这样启动一个异步的任务。<br>
这是个非常常用的程序设计思路，把一个任务的启动和关闭，都封装在一个结构体里，这样可以方便的控制任务的生命周期。<br>
而且也方便在另外一个线程里启动这个任务。</p>
<p>这里通过封装 TcpListener 自定义了 accept，实现了指数退避策略，如果 accept 失败，就等待一段时间再尝试，这样可以减少系统调用，提高性能。<br>
一般 accept 失败都是系统内部错误。</p>
<p>这里就涉及到克隆的规则了，因为我们希望每个连接都共享数据库实例。rust的clone 分成了深拷贝和浅拷贝，shallow clone 会增加引用计数，deep clone 会复制整个对象。这里我们需要的是浅拷贝，所以使用 Arc 来包装数据库实例。</p>
<blockquote>
<p>对于结构体这种复合类型，其克隆行为遵循以下规则：</p>
<ol>
<li><strong>默认派生的Clone实现</strong> (<code>#[derive(Clone)]</code>)：会递归地克隆结构体中的每个字段，每个字段的克隆行为取决于该字段类型自己的Clone实现，最终结果是结构体中所有字段都被克隆。</li>
<li><strong>手动实现的Clone</strong>：可以自定义任何克隆行为，可以选择性地克隆某些字段或使用不同的克隆策略</li>
</ol>
<p>📌 例1：所有字段进行深克隆的结构体</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u32</span>,</span><br><span class="line">    hobbies: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person1</span> = Person &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>),</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">        hobbies: <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Reading&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hiking&quot;</span>)],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person2</span> = person1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>Person</code>的克隆会创建一个完全独立的副本，因为所有字段(<code>String</code>、<code>u32</code>、<code>Vec&lt;String&gt;</code>)都实现了深克隆。</p>
<p>📌 例2：包含引用计数的结构体（混合克隆行为）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">    title: <span class="type">String</span>,                <span class="comment">// 深克隆</span></span><br><span class="line">    content: <span class="type">String</span>,              <span class="comment">// 深克隆</span></span><br><span class="line">    shared_metadata: Arc&lt;Metadata&gt;, <span class="comment">// 浅克隆（只增加引用计数）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Metadata</span> &#123;</span><br><span class="line">    author: <span class="type">String</span>,</span><br><span class="line">    created_at: <span class="type">u64</span>,</span><br><span class="line">    tags: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">metadata</span> = Arc::<span class="title function_ invoke__">new</span>(Metadata &#123;</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Bob&quot;</span>),</span><br><span class="line">        created_at: <span class="number">1616161616</span>,</span><br><span class="line">        tags: <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;important&quot;</span>)],</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">doc1</span> = Document &#123;</span><br><span class="line">        title: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Report&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Some content...&quot;</span>),</span><br><span class="line">        shared_metadata: metadata,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">doc2</span> = doc1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// doc2的title和content是深克隆的独立副本</span></span><br><span class="line">    <span class="comment">// 但doc1和doc2共享同一个metadata (Arc&lt;Metadata&gt;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>Document</code>的克隆是混合行为：</p>
<ul>
<li><code>title</code>和<code>content</code>字段是深克隆（完整副本）</li>
<li><code>shared_metadata</code>字段是浅克隆（引用计数增加）</li>
</ul>
</blockquote>
<p>每个 Handler 里除了必要的资源，还有退出信号、每个连接的信号。只有当所有连接的信号都关闭，服务器才会退出。<br>
当每个连接收到退出信号，就会开始关闭连接，也就是 Handler 任务。</p>
<p>任务的主要内容就是读取 Frame，一定会停留到收到一个完整的 Frame，才进行下一步。<br>
如果出现异常，就会 Err，如果客户端政策终止连接返回None。<br>
接着 Frame 会被<strong>解析</strong>成命令，然后<strong>执行</strong>，执行的结果会被序列化成 Frame，然后写入到连接里。</p>
<p>这里用 enum 来表示命令，然后用 match 来处理，这是 Rust 的模式匹配，很好的实践，能选择不同的成员，这样各自单独实现同名的命令，这就类似接口了。</p>
<p>另外每个命令有不同的 Frame 组装形式和返回值形式。</p>
<blockquote>
<p>这里就涉及到 rust 的模块组织了，</p>
<ol>
<li>一个模块就是一个文件，文件名就是模块名，文件里的内容就是模块的内容。</li>
<li>一个模块可以包含多个结构体、枚举、函数等。</li>
<li>一个文件里可以包含多个模块，这些模块可以是私有的，也可以是公有的。跨文件实际上就是隐含的把文件名当作模块名，然后在其他文件里引用。目录也是同理，目录名就是模块名。</li>
</ol>
<p>模块组织有 <code>mod.rs</code> 和 与目录同名的rs文件两种做法，Rust 2018推荐之后推荐后者，但是实际上两者差别不大，只是文件命名位置不同而已。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── main.rs</span><br><span class="line">└── models/</span><br><span class="line">    ├── mod.rs</span><br><span class="line">    ├── user.rs</span><br><span class="line">    └── product.rs</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── main.rs</span><br><span class="line">├── models.rs</span><br><span class="line">└── models/</span><br><span class="line">    ├── user.rs</span><br><span class="line">    └── product.rs</span><br></pre></td></tr></table></figure>
<p>区别只是，<code>mod.rs</code> 挪动到了同级目录的与目录同名的rs文件里，你不用动里面的内容，rust会自动的去目录中找对应文件。</p>
<p>🔥 Rust 导入还有技巧，可以先导入，在设置Pub哪些。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> get;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> get::Get;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> publish;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> publish::Publish;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="客户端模块">客户端模块</h3>
<p>Connection 是最基本的，包括 TCPStream 和 Buffer。接着用户命令行输入组装成对应命令，命令再序列化成 Frame，然后写入到 Connection 里。<br>
接着阻塞，等待服务器返回 frame。但是要注意超时，这里是如果发送成功后，没有考虑对方超时。我们注释掉返回写入的逻辑，会发现客户端卡住了。后面我们自己来修改。</p>
<p>Ping-&gt;Pong， 都是简单的字符串，所以直接返回即可。<br>
Get-&gt;Value，发送的是 bulk 数组，返回Simple、Bulk、Null都有可能。<br>
Set-&gt;OK，返回的是 Simple。</p>
<p>订阅会麻烦一些，字符串列表表示要订阅的多个频道。<br>
服务端首先要记录客户端订阅了哪些 channel，并且为每个 channel 创建一个 stream。stream 是等待后续消息的流，消息通道，这个通道是rx，接收信息。而服务端会在状态数据里记录对应的tx，等待有其他客户端Publish消息到对应channel，然后广播给rx。</p>
<p>这个实现有个好处，rx 是从状态数据库来的，每个客户端都持有对应的部分，那么就可以做到状态数据库向tx发送消息，然后所有的客户端都能收到消息。这就是广播机制。</p>
<p>这个 rx 的类型很有意思，loop 与 yield 一起用，这就是生成器，但是加上 <code>async_stream::stream!</code> 就是异步的生成器，这个是通过 async-stream 包提供的，可以实现异步的流。不过同步代码不会用 yield，而是实现一个 Iterator 的 next 方法。所以这个语法几乎是创建异步流的标准写法。<br>
每次收到消息，就 yield 出去，然后等待下一次消息，退出就返回 None，这和 stream 完全相同。那么持有这个 loop 的变量，就可以实现 stream 的功能。<br>
而 <code>try_stream!</code> 是 async_stream 提供的另一个重要宏，它与 stream! 类似，但专门用于处理可能出错的场景。它返回的流中的元素类型是 Result&lt;T, E&gt;，并且在宏内部可以使用 ? 操作符进行错误传播。这对于像网络操作、IO 读写等可能失败的异步操作特别有用。<br>
当我们使用 try_stream! 时，内部的错误会被自动包装成 Result 类型并向上传播。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rx</span> = db.<span class="title function_ invoke__">subscribe</span>(channel_name.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe to the channel.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rx</span> = <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(async_stream::stream! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(msg) =&gt; <span class="keyword">yield</span> msg,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Track subscription in this client&#x27;s subscription set.</span></span><br><span class="line">subscriptions.<span class="title function_ invoke__">insert</span>(channel_name.<span class="title function_ invoke__">clone</span>(), rx); <span class="comment">//  &amp;mut StreamMap&lt;String, Messages&gt;</span></span><br></pre></td></tr></table></figure>
<p>在底层实现上，async_stream 通过巧妙的方式解决了异步状态管理的问题。它使用线程本地存储来保存状态，避免了手动实现 Stream 特性时需要使用 unsafe 代码处理自引用结构的复杂性。这使得开发者可以用看起来像同步代码的方式（使用 <code>async/await</code> 和 yield）来编写异步流，而不必关心底层的异步状态机实现细节。</p>
<p>还有个有意思的地方，就是 stream 的类型 <code>Box::pin(...)</code>，这创建一个堆分配的 <code>stream</code>，这是因为 <code>async_stream::stream!</code> 创建的 stream 类型和大小是不确定的，编译时才产生的。</p>
<p>这样封装一层Box，就可以当作一个固定大小的类型来使用了。记住，<strong>Rust 是强类型语言，每个变量都有固定的类型和大小，无法确定大小的类型一定是在堆上，而且用栈上的指针引用</strong>，这样才能保证内存安全。</p>
<p>这里的 pin 也是有学问的，异步本质上是创建了一个 Future，表示还没有完成的计算，是一个特殊 trait。在编译的时候，每个异步任务转换成状态机，每个状态就是异步任务的一个等待点。这个状态机可能包括对数据的引用，当这个 Future 被调度到其他线程，内存位置就可能变化，导致引用失效。所以需要 pin 保证内存位置不变，这样就可以安全的在多线程之间传递 Future。</p>
<p>Box::pin 是标准库提供的方法，用于创建堆分配的、被钉住的值。tokio::pin! 是 tokio 提供的宏，用于在栈上钉住值。最重要的区别在于tokio::pin! 分配在栈上，更高效，无需堆分配，但是生命周期受限于当前作用域，无法跨函数边界传递。</p>
<p>什么时候需要Pin呢，最常见的就是 stream，因为 stream 本身就是为了等待异步任务的结果，所以它本身就是一个Future。</p>
<p>还有就是自引用的结构，比如</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SelfReferential</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">    <span class="comment">// This would normally be unsafe without Pin</span></span><br><span class="line">    reference: *<span class="keyword">const</span> <span class="type">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面函数的返回值类型也是 rust 的重要知识点。 前面的 rx 推理出的的类型是 <code>Pin&lt;Box&lt;AsyncStream&lt;Bytes, impl Future&lt;Output = ()&gt;&gt;&gt;&gt;</code>，实际定义的类型是 <code>Pin&lt;Box&lt;dyn Stream&lt;Item = Bytes&gt; + Send&gt;&gt;</code>，下面函数返回的类型是 <code>impl Stream&lt;Item = crate::Result&lt;Message&gt;&gt;</code>，我们发现了不用的写法 <code>&lt;Box&lt;dyn _&gt;&gt;</code> 和 <code>impl _</code>，这里就是动态分发和静态分发的区别，动态分发是在运行时确定类型，可以返回不同的具体类型实现（多态），有轻微的性能开销，用Box实现返回值类型大小固定（就是一个指针大小）。而静态分发是在编译时确定类型，只能返回单一具体类型，性能更好。<code>into_stream</code> 用静态分发的原因是它专门处理固定的 Message 类型。而前面动态分发是因为需要处理多种可能的 Stream 实现，而这些实现在编译时可能并不确定。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">into_stream</span>(<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Stream</span>&lt;Item = crate::<span class="type">Result</span>&lt;Message&gt;&gt; &#123;</span><br><span class="line">    try_stream! &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(message) = <span class="keyword">self</span>.<span class="title function_ invoke__">next_message</span>().<span class="keyword">await</span>? &#123;</span><br><span class="line">            <span class="keyword">yield</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端的虽有订阅的rx都存储在 <code>subscriptions = StreamMap::new();</code> 里了，就是前面提到的 str-&gt;rx 的映射。他的好处是，任何一个rx收到消息，subscriptions.next() 就会返回这个消息，不用自己手动的写个 select 来等待多个rx。</p>
<p>另外用户可能再次订阅更多的频道，那么服务端继续增加 channels，然后触发增加 rx。</p>
<p>如果用户要取消订阅，那么服务端就要删除对应的 rx，这里有个问题，就是 rx 是异步的，可能正在等待消息，这时候删除了，就会导致 rx 无法接收到消息，这里我们直接中断rx，这是符合预期的，因为用户取消订阅，就不应该再接收到消息了。</p>
<p>我们来看 publish 的实现，是怎么发送给 channel 对应的 tx 的。这个操作就相当简单了，因为只管发布就可以了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">subscribe_to_channel</span>(</span><br><span class="line">    channel_name: <span class="type">String</span>,</span><br><span class="line">    subscriptions: &amp;<span class="keyword">mut</span> StreamMap&lt;<span class="type">String</span>, Messages&gt;,</span><br><span class="line">    db: &amp;Db,</span><br><span class="line">    dst: &amp;<span class="keyword">mut</span> Connection,</span><br><span class="line">) <span class="punctuation">-&gt;</span> crate::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rx</span> = db.<span class="title function_ invoke__">subscribe</span>(channel_name.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subscribe to the channel.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rx</span> = <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(async_stream::stream! &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>().<span class="keyword">await</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(msg) =&gt; <span class="keyword">yield</span> msg,</span><br><span class="line">                <span class="comment">// If we lagged in consuming messages, just resume.</span></span><br><span class="line">                <span class="title function_ invoke__">Err</span>(broadcast::error::RecvError::<span class="title function_ invoke__">Lagged</span>(_)) =&gt; &#123;&#125;,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">break</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Track subscription in this client&#x27;s subscription set.</span></span><br><span class="line">    subscriptions.<span class="title function_ invoke__">insert</span>(channel_name.<span class="title function_ invoke__">clone</span>(), rx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Respond with the successful subscription</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">make_subscribe_frame</span>(channel_name, subscriptions.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    dst.<span class="title function_ invoke__">write_frame</span>(&amp;response).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改进">改进</h2>
<blockquote>
<p>改动见： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/learnerLj/mini-redis/commit/dd18c65b17347e1986efc2df30f9d9f73f595086">https://github.com/learnerLj/mini-redis/commit/dd18c65b17347e1986efc2df30f9d9f73f595086</a></p>
</blockquote>
<p>接下来我打算在这个项目的基础上进行一些扩展。这里有个关键，就是不会清理掉过期的 broadcast::Sender。为了解决这个问题，我们首先考虑 Sender 是否知晓自己有rx呢？这个是不可能的，因为没有直接的方法来检测，只能发送消息去尝试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub_sub: HashMap&lt;<span class="type">String</span>, broadcast::Sender&lt;Bytes&gt;&gt;,</span><br></pre></td></tr></table></figure>
<p>那我我们增加这么个机制。下面2个条件都会清理掉对应的 Sender。</p>
<ol>
<li>
<p>通过 TCP 连接的状态来管理订阅的有效性。如果客户端断开连接，服务器会自动检测到并清理相应的资源。注意心跳机制没有作用，这里是TCP连接，一般心跳机制是用于UDP，检验某些记录是否还有效。</p>
</li>
<li>
<p>Sender增加一个字段，是rx的计数。对应掉线或者主动取消订阅，都会减少计数，如果没有对应的 rx，就清理掉对应的 Sender。这个是为了防止客户端取消订阅，但是服务端没有收到消息，导致的内存泄漏。</p>
</li>
</ol>
<p>具体说，订阅时，要更新对应字段。重复订阅已经存在的 channel，也要刷新活跃时间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Entry::<span class="title function_ invoke__">Occupied</span>(e) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">channel_state</span> = e.<span class="title function_ invoke__">into_mut</span>();</span><br><span class="line">        channel_state.receiver_count += <span class="number">1</span>;</span><br><span class="line">        channel_state.last_activity = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">        channel_state.sender.<span class="title function_ invoke__">subscribe</span>()</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    Entry::<span class="title function_ invoke__">Vacant</span>(e) =&gt; &#123;</span><br><span class="line">        <span class="comment">// No broadcast channel exists yet, so create one.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The channel is created with a capacity of `1024` messages. A</span></span><br><span class="line">        <span class="comment">// message is stored in the channel until **all** subscribers</span></span><br><span class="line">        <span class="comment">// have seen it. This means that a slow subscriber could result</span></span><br><span class="line">        <span class="comment">// in messages being held indefinitely.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// When the channel&#x27;s capacity fills up, publishing will result</span></span><br><span class="line">        <span class="comment">// in old messages being dropped. This prevents slow consumers</span></span><br><span class="line">        <span class="comment">// from blocking the entire system.</span></span><br><span class="line">        <span class="keyword">let</span> (tx, rx) = broadcast::<span class="title function_ invoke__">channel</span>(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">channel_state</span> = ChannelState &#123;</span><br><span class="line">            sender: tx,</span><br><span class="line">            receiver_count: <span class="number">1</span>,</span><br><span class="line">            last_activity: Instant::<span class="title function_ invoke__">now</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        e.<span class="title function_ invoke__">insert</span>(channel_state);</span><br><span class="line">        rx</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>取消订阅的时候是类似的，但是由于之前 db 模块没有这部份逻辑，我们需要从 unsubscribe 命令，一直改到 db。之前只是从 subscriptions 里删除这个 channel-&gt;stream 映射，这样subscriptions.next() 就不会从删除了的rx返回数据了。但是这次我们要db里也改。</p>
<p>这里有个有趣的点，参数db 没有mut，但是实际订阅是修改了 db的状态的，这是否矛盾了呢？没有，因为 Mutex 是Refcell的多线程版本，也就是也实现了内部可变行。Db 结构体包含一个 Arc<Shared>，而 Shared 结构体包含一个 Mutex<State>。<code>let mut state = self.shared.state.lock().unwrap();</code> 就自动的变成可变的了。这里就是很好的例子，我们的Db不想从头到尾都是可变参数传进去，到了 state 字段就可变了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">subscribe_to_channel</span>(</span><br><span class="line">    channel_name: <span class="type">String</span>,</span><br><span class="line">    subscriptions: &amp;<span class="keyword">mut</span> StreamMap&lt;<span class="type">String</span>, Messages&gt;,</span><br><span class="line">    db: &amp;Db,</span><br><span class="line">    dst: &amp;<span class="keyword">mut</span> Connection,</span><br><span class="line">) <span class="punctuation">-&gt;</span> crate::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rx</span> = db.<span class="title function_ invoke__">subscribe</span>(channel_name.<span class="title function_ invoke__">clone</span>());</span><br></pre></td></tr></table></figure>
<p>db 增加一个实现，当所有订阅被取消了，就要删除这个订阅。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">unsubscribe</span>(&amp;<span class="keyword">self</span>, key: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">state</span> = <span class="keyword">self</span>.shared.state.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(channel_state) = state.pub_sub.<span class="title function_ invoke__">get_mut</span>(key) &#123;</span><br><span class="line">            channel_state.receiver_count -= <span class="number">1</span>;</span><br><span class="line">            channel_state.last_activity = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> channel_state.receiver_count == <span class="number">0</span> &#123;</span><br><span class="line">                state.pub_sub.<span class="title function_ invoke__">remove</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是也可能存在一些客户端，已经掉线了，但是订阅还存在，那需要在掉线的时候，增加取消订阅的逻辑。中断时 <code>dst.read_frame()</code> 会返回 none，那么所有订阅都应该删除，通知server对应计数改变。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">res = dst.<span class="title function_ invoke__">read_frame</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">frame</span> = <span class="keyword">match</span> res? &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(frame) =&gt; frame,</span><br><span class="line">        <span class="comment">// This happens if the remote client has disconnected.</span></span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            subscriptions.<span class="title function_ invoke__">keys</span>().for_each(|channel_name| &#123;</span><br><span class="line">                db.<span class="title function_ invoke__">unsubscribe</span>(channel_name);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>为了验证我们的订阅管理是否真的起效，我们增加 debug trace。接着把 <code>mod.rs</code> 的模式，我们改成现代的模式。</p>
<h2 id="学习项目结构">学习项目结构</h2>
<p>还有项目的布局，我们发现 example 文件夹下，也能导入本地的 mini_redis，这说明寻找依赖库时，Cargo 首先会读取项目根目录下的 Cargo.toml 文件，它会检查 [package] 部分的 name 字段，这定义了项目/库的名称。当在代码中使用 use mini_redis 这样的导入语句时，Cargo 会首先检查这个名称是否与当前项目名称匹配<br>
如果匹配，它会优先使用当前项目的库代码，如果不匹配，才会去查找外部依赖。</p>
<p>我们还发现了运行命令 <code>cargo run --example sub</code> 结构特殊，这是运行一级目录下的 sub模块，如果是sub.rs单个文件，就是里面的main函数。如果是一个文件夹，那么就是运行整个模块，一般入口 <code>example/sub/main.rs</code>。</p>
<p>这里的项目层级，只要你在项目目录内，就不会受到当前路径的影响，你可以在项目的任何地方运行，会自动寻找。但是 Rust 对于大型项目，有一个&quot;工作空间&quot;(Workspace)，那么你就需要指定项目了。在 workspace 根目录运行：需要指定包 cargo run --package project-a --example sub</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">workspace/</span><br><span class="line">├── Cargo.toml  # 工作空间配置</span><br><span class="line">├── project-a/</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── examples/</span><br><span class="line">│       └── sub.rs</span><br><span class="line">└── project-b/</span><br><span class="line">    └── Cargo.toml</span><br></pre></td></tr></table></figure>
<p>如何判断是一个&quot;工作空间&quot;(Workspace)呢？根目录有一个主 Cargo.toml，定义工作空间和成员项目。比如reth项目，cargo build、cargo test 等命令时设置了默认包，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[workspace]</span><br><span class="line">members = [</span><br><span class="line">    &quot;bin/reth-bench/&quot;,</span><br><span class="line">    &quot;bin/reth/&quot;,</span><br><span class="line">    &quot;crates/chain-state/&quot;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">efault-members = [&quot;bin/reth&quot;]</span><br><span class="line">exclude = [&quot;book/sources&quot;, &quot;book/cli&quot;]</span><br></pre></td></tr></table></figure>
<p>项目里还有 bin目录，用来用上各个模块的功能，完成这个工具，一般也是软件的入口。这里是因为有多个软件，客户端和服务端的原因。如果只有一个，一般寻找 src/main.rs 或者 src/bin/main.rs 作为默认入口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[bin]]</span><br><span class="line">name = &quot;mini-redis-cli&quot;</span><br><span class="line">path = &quot;src/bin/cli.rs&quot;</span><br><span class="line"></span><br><span class="line">[[bin]]</span><br><span class="line">name = &quot;mini-redis-server&quot;</span><br><span class="line">path = &quot;src/bin/server.rs&quot;</span><br></pre></td></tr></table></figure>
<p>对于简单的项目，用这样的布局足够了。workspace就单独学习。</p>
<p>再看项目导出的部分，都在 src/lib.rs 中。每个子模块导出的函数，就在<code>mod.rs</code>或者与目录同名的rs文件。</p>
<h2 id="学习测试">学习测试</h2>
<p>下面是典型的测试，对于用到 async 的函数，都要用 <code>#[tokio::test]</code> 代替 <code>#[test]</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A PING PONG test without message provided.</span></span><br><span class="line"><span class="comment">/// It should return &quot;PONG&quot;.</span></span><br><span class="line">#<span class="meta">#[tokio::test]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">ping_pong_without_message</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (addr, _) = <span class="title function_ invoke__">start_server</span>().<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">client</span> = Client::<span class="title function_ invoke__">connect</span>(addr).<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pong</span> = client.<span class="title function_ invoke__">ping</span>(<span class="literal">None</span>).<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">b&quot;PONG&quot;</span>, &amp;pong[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试的断言，除了 assert_eq! 还有 <code>#[should_panic]</code>，标记在测试函数上，表示需要触发panic。</p>
<p>有时候需要便边写代码边测试，但是我们又不希望测试用例也编译进程序，那么创建一个 test模块，然后 <code>#[cfg(test)]</code> 标记它，这样仅在测试构建时包含的代码块。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要运行所有测试，直接 <code>cargo test</code>，会寻找项目中所有标记为测试的代码，而不仅仅是 tests 目录下的测试。标记为测试是指：</p>
<ol>
<li>标记为 <code>#[test]</code> 的函数，这些函数必须返回 () 并且不能接受任何参数。</li>
<li>标记为 <code>#[tokio::test]</code> 或其他自定义测试宏的函数。</li>
<li>在 <code>#[cfg(test)]</code> 模块中的测试函数。</li>
</ol>
<p>如果你只想运行 tests 目录下的测试，单个模块 <code>cargo test --test</code>。如果不在 <code>tests</code> 目录下，那么就按照模块顺序去找，比如 <code>cargo test crate::models::user::test_user_validation</code>。也可以简单地提供测试函数的名称，如果它在项目中是唯一的 <code>cargo test test_user_validation</code>。这里的名字都是可以<strong>正则匹配</strong>的。</p>
<p>如果你需要看到测试中的 println! 输出，可以添加 – --nocapture 参数。比如 <code>cargo test --test server key_value_get_set -- --nocapture</code>。</p>
<p><code>--show-output</code> 参数只会显示失败测试的输出，而且会在测试结果之后整齐地显示。这样可以更容易地将测试结果与输出区分开。通过测试就不会有输出了。</p>
<p>测试里除了 println!，还可以使用 dbg!()，会自动打印表达式和计算后的值。比如 <code>dbg!(addr);</code> 返回 <code>[tests/server.rs:15:5] addr = 127.0.0.1:57813</code>。</p>
<h2 id="命令行工具">命令行工具</h2>
<p>Rust 中最常见的命令行参数解析库是 clap。我们看 redis client 的设计，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#[derive(Parser, Debug)]</span></span><br><span class="line">#<span class="meta">#[command(</span></span><br><span class="line"><span class="meta">    name = <span class="string">&quot;mini-redis-cli&quot;</span>,</span></span><br><span class="line"><span class="meta">    version,</span></span><br><span class="line"><span class="meta">    author,</span></span><br><span class="line"><span class="meta">    about = <span class="string">&quot;Issue Redis commands&quot;</span></span></span><br><span class="line"><span class="meta">)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cli</span> &#123;</span><br><span class="line">    <span class="meta">#[clap(subcommand)]</span></span><br><span class="line">    command: Command,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[arg(id = <span class="string">&quot;hostname&quot;</span>, long, default_value = <span class="string">&quot;127.0.0.1&quot;</span>)]</span></span><br><span class="line">    host: <span class="type">String</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[arg(long, default_value_t = DEFAULT_PORT)]</span></span><br><span class="line">    port: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个子命令（通过 Command 枚举表示），<code>#[clap(subcommand)]</code> 会告诉 clap 这是个子命令，加上他继承Subcommand，就会自动生成解析的代码。子命令里的参数字段，也可以增加标签。这个自动生成功能，极大的简化了命令解析的过程。<br>
默认参数可以是用 --字段名，或者用字段位置对应。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#[derive(Subcommand, Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    Ping &#123; msg: <span class="type">Option</span>&lt;Bytes&gt; &#125;,</span><br><span class="line">    Get &#123; key: <span class="type">String</span> &#125;,</span><br><span class="line">    Set &#123; key: <span class="type">String</span>, value: Bytes, expires: <span class="type">Option</span>&lt;Duration&gt; &#125;,</span><br><span class="line">    Publish &#123; channel: <span class="type">String</span>, message: Bytes &#125;,</span><br><span class="line">    Subscribe &#123; channels: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
    
  </pre></div>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz">Michael(Jiahao) Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz/dev/study-mini-redis/">https://www.blog-blockchain.xyz/dev/study-mini-redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/rust/">rust</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.blog-blockchain.xyz/2025/03/7a1eb877711a4e78b90307ccefde92f4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/dev/rust-lifetime/" title="深入学习Rust生命周期"><img class="cover" src="https://cdn.blog-blockchain.xyz/2025/03/7a1eb877711a4e78b90307ccefde92f4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">深入学习Rust生命周期</div></div><div class="info-2"><div class="info-item-1">深入解析Rust生命周期机制的核心原理和推导规则，详细讨论循环引用问题和可变引用限制，提供避免生命周期陷阱的实用建议和最佳实践。</div></div></div></a><a class="pagination-related" href="/dev/value-of-software-engineering/" title="程序员的价值在哪里"><img class="cover" src="https://cdn.blog-blockchain.xyz/2025/05/819ee56cc884eb5c8194f7f9a2d94d8c.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">程序员的价值在哪里</div></div><div class="info-2"><div class="info-item-1">程序员的核心价值是利用技术为企业创造业务价值，而非纯粹的技术能力。其价值公式 V=Σ（技术杠杆率×业务价值密度）揭示了价值来源：技术杠杆放大个人产出，业务价值密度决定场景潜力。不同场景和行业对程序员价值估值各异，通用价值体现在解决复杂问题、优化性能、提升效率、推动创新和降低成本等方面。程序员需拥抱多元技术栈，精进核心技能，提升业务理解和复合能力。技术价值受稀缺性、适配度和泡沫溢价率影响，需警惕技术超前、路径依赖和伪需求陷阱。逃离泡沫需识别资本退潮、人才降温、监管收紧等信号，并提前转型、提升能力、谨慎投资、拓展人脉和终身学习。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/dev/rust-lifetime/" title="深入学习Rust生命周期"><img class="cover" src="https://cdn.blog-blockchain.xyz/2025/03/7a1eb877711a4e78b90307ccefde92f4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-28</div><div class="info-item-2">深入学习Rust生命周期</div></div><div class="info-2"><div class="info-item-1">深入解析Rust生命周期机制的核心原理和推导规则，详细讨论循环引用问题和可变引用限制，提供避免生命周期陷阱的实用建议和最佳实践。</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Michael(Jiahao) Luo</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">87</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://x.com/jiahao_luo9"><i class="fa-brands fa-twitter"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://www.linkedin.com/in/jiahao-michael-luo-8ba5942a3" rel="external nofollow noreferrer" target="_blank" title="Linkedin"><i class="fa-brands fa-linkedin"></i></a><a class="social-icon" href="https://x.com/jiahao_luo9" rel="external nofollow noreferrer" target="_blank" title="Twitter"><i class="fa-brands fa-twitter"></i></a><a class="social-icon" href="https://github.com/learnerLj" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:luoshitou9@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">从技术到商业，从产品到设计，从生活到未来，我会在这里分享我的所思所想，欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-text">项目架构概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#db-%E6%A8%A1%E5%9D%97"><span class="toc-text">db 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1"><span class="toc-text">数据结构和后台任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%92%8C%E5%86%99"><span class="toc-text">读和写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pub-Sub"><span class="toc-text">Pub&#x2F;Sub</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8D%8F%E8%AE%AE%E5%B8%A7"><span class="toc-text">Redis协议帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%9D%97"><span class="toc-text">连接模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">服务器模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%9D%97"><span class="toc-text">客户端模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B"><span class="toc-text">改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-text">学习项目结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%B5%8B%E8%AF%95"><span class="toc-text">学习测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="toc-text">命令行工具</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/dev/kafka/" title="Kafka分布式消息系统技术指南"><img src="https://cdn.blog-blockchain.xyz/2025/06/a96b1a9d3fed485c6214b10572c4d736.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kafka分布式消息系统技术指南"/></a><div class="content"><a class="title" href="/dev/kafka/" title="Kafka分布式消息系统技术指南">Kafka分布式消息系统技术指南</a><time datetime="2025-06-18T19:21:20.000Z" title="Created 2025-06-19 03:21:20">2025-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/career/making-of-consumer/" title="制造消费者"><img src="https://cdn.blog-blockchain.xyz/2025/06/51642e0693cbe2d398d9d1518bf06360.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="制造消费者"/></a><div class="content"><a class="title" href="/career/making-of-consumer/" title="制造消费者">制造消费者</a><time datetime="2025-06-14T18:11:20.000Z" title="Created 2025-06-15 02:11:20">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/career/ai-chat-philosophy/" title="一个初代AI聊天机器人的故事。人性的弱点碰上了人工智能的哲学。"><img src="https://cdn.blog-blockchain.xyz/2025/06/b4a3b8645810b021a67ae726b9734632.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一个初代AI聊天机器人的故事。人性的弱点碰上了人工智能的哲学。"/></a><div class="content"><a class="title" href="/career/ai-chat-philosophy/" title="一个初代AI聊天机器人的故事。人性的弱点碰上了人工智能的哲学。">一个初代AI聊天机器人的故事。人性的弱点碰上了人工智能的哲学。</a><time datetime="2025-06-06T10:44:20.000Z" title="Created 2025-06-06 18:44:20">2025-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/solana/solana-basic/" title="Solana 合约开发基础"><img src="https://cdn.blog-blockchain.xyz/2025/05/a8ff2c0938675dd107393164903785c8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Solana 合约开发基础"/></a><div class="content"><a class="title" href="/solana/solana-basic/" title="Solana 合约开发基础">Solana 合约开发基础</a><time datetime="2025-05-18T14:58:33.000Z" title="Created 2025-05-18 22:58:33">2025-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/solana/solana-flashloan-1/" title="Solana flashloan 原理和设计"><img src="https://cdn.blog-blockchain.xyz/2025/05/a8ff2c0938675dd107393164903785c8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Solana flashloan 原理和设计"/></a><div class="content"><a class="title" href="/solana/solana-flashloan-1/" title="Solana flashloan 原理和设计">Solana flashloan 原理和设计</a><time datetime="2025-05-17T14:09:33.000Z" title="Created 2025-05-17 22:09:33">2025-05-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Michael(Jiahao) Luo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.5"></script><script src="/js/main.js?v=5.3.5"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '467d9506710fff22dc33',
      clientSecret: '2a3e530b895af9c94d4bbe95fe78c69317f4d76e',
      repo: 'blog-gitalk',
      owner: 'learnerLj',
      admin: ['learnerLj'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'c277fc36e2887763b801dc17528f7d17'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.3.5"></script></div></div></body></html>