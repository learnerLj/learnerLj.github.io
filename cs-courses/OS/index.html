<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统基础 | Jiahao Luo</title><meta name="author" content="Michael(Jiahao) Luo"><meta name="copyright" content="Michael(Jiahao) Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><meta name="description" content="全面阐述操作系统核心概念，包括进程线程管理、内存管理、文件系统、死锁处理、调度算法等重要主题，适合计算机专业学生和系统开发人员学习参考。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统基础">
<meta property="og:url" content="https://www.blog-blockchain.xyz/cs-courses/OS/index.html">
<meta property="og:site_name" content="Jiahao Luo">
<meta property="og:description" content="全面阐述操作系统核心概念，包括进程线程管理、内存管理、文件系统、死锁处理、调度算法等重要主题，适合计算机专业学生和系统开发人员学习参考。">
<meta property="og:locale">
<meta property="og:image" content="https://www.blog-blockchain.xyz/images/OS.png">
<meta property="article:published_time" content="2023-02-13T15:06:22.000Z">
<meta property="article:modified_time" content="2025-06-18T20:06:27.917Z">
<meta property="article:author" content="Michael(Jiahao) Luo">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.blog-blockchain.xyz/images/OS.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统基础",
  "url": "https://www.blog-blockchain.xyz/cs-courses/OS/",
  "image": "https://www.blog-blockchain.xyz/images/OS.png",
  "datePublished": "2023-02-13T15:06:22.000Z",
  "dateModified": "2025-06-18T20:06:27.917Z",
  "author": [
    {
      "@type": "Person",
      "name": "Michael(Jiahao) Luo",
      "url": "https://www.blog-blockchain.xyz"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://www.blog-blockchain.xyz/cs-courses/OS/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?372b8854d18acf62880149b1e08e1901";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=QXcJQjXxTMeUwnWykFW2xw"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'QXcJQjXxTMeUwnWykFW2xw')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'QXcJQjXxTMeUwnWykFW2xw', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Jiahao Luo" type="application/atom+xml">
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css');loadCss('https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css');loadCss('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css"></noscript></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">32</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jiahao Luo</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统基础</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">操作系统基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-02-13T15:06:22.000Z" title="Created 2023-02-13 23:06:22">2023-02-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-06-18T20:06:27.917Z" title="Updated 2025-06-19 04:06:27">2025-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/courses/">courses</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">22.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>70mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><blockquote>
<ol class="series-items"><li><a href="/cs-courses/C-language-basis/" title="C语言基础">C语言基础</a></li><li><a href="/cs-courses/modular-inverses/" title="乘法逆元">乘法逆元</a></li><li><a href="/cs-courses/cpp-cryptographic-algorithm-basis/" title="信息安全算法基础">信息安全算法基础</a></li><li><a href="/cs-courses/OS/" title="操作系统基础">操作系统基础</a></li><li><a href="/cs-courses/x86-masm/" title="x86汇编基础">x86汇编基础</a></li><li><a href="/cs-courses/information-theory/" title="信息论与编码">信息论与编码</a></li></ol>
</blockquote>
<h2 id="前言">前言</h2>
<p>这是电子科技大学计算机系的操作系统课程的总结，笔者已经基本理解这篇文章里的内容，但是如果有不准确之处，恳请指出。在操作系统这个成熟很久的领域中，有不少作者图文并茂的介绍了操作系统地基本知识。但是，笔者认为这里地总结相对精简，直接抵达核心概念，也是阅读学习的好资料。本文很多的总结和图片都来自老师的 PPT，笔者只是学习并且结合其他资料与自己的理解，加以阐释。</p>
<h2 id="进程和线程">进程和线程</h2>
<p>进程是操作系统最核心的概念，简单的说是正在运行的程序的抽象。进程的执行模型可以分成两类，<strong>顺序执行</strong>和<strong>并行执行</strong>，前者效率低，后者硬件要求高。我们整个课程都是只考虑<strong>并发执行</strong>，也就是微观上顺序执行，宏观上并行执行。进程＝进程控制块＋程序＋相关数据，<strong>进程之间各自独立、不可预知速度地并发执行</strong>。</p>
<h3 id="进程的状态">进程的状态</h3>
<p>进程有三种基本状态，进程都在内存中：</p>
<p>**就绪状态：**进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行。</p>
<p>**执行状态：**进程已获得 CPU，其程序正在执行。</p>
<p>**阻塞状态：**放弃处理机而处于暂停状态。处理机指计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。</p>
<img src="http://cdn.blog-blockchain.xyz/202212121700982.png" alt="图片1" style="zoom:50%;">
<p>注意就绪不能直接到阻塞，阻塞也不能直接执行。</p>
<p>进程还有其他状态：</p>
<ul>
<li>New：新建了进程对象，PCB（程序控制块） 在内存，但是程序指令存储在硬盘。</li>
<li>Exit：进程彻底停止，并且释放内存。</li>
<li>挂起状态：进程被暂时调离内存。就绪挂起只要程序进入内存就可以运行；阻塞挂起定义模糊，等待事件就会变成就绪挂起。一般时放在交换区，不再竞争 CPU。</li>
</ul>
<img src="http://cdn.blog-blockchain.xyz/202212131011289.png" alt="image-20221213101111199" style="zoom: 50%;">
<h3 id="进程的描述">进程的描述</h3>
<p>单独的进程可以拆解为：</p>
<ul>
<li>进程映像：程序、数据、堆、栈的集合。</li>
<li>程序控制块。用于控制程序的行为，主要包括：
<ul>
<li>进程标识信息。每个进程都分配了唯一的标识符，用于引用进程，表示父进程和子进程的关系。</li>
<li>处理器状态信息。CPU 寄存器存储栈指针、程序计数器等执行信息，程序状态寄存器存储溢出、进位等程序状态。</li>
<li>进程控制信息。操作系统控制和协调各种活动进程所需的额外信息。比如优先级、进程运行态、调度算法相关信息、存储管理信息等。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">映像名称                       PID 会话名              会话#       内存使用</span><br><span class="line">========================= ======== ================ =========== ============</span><br><span class="line">System Idle Process              0 Services                   0          8 K</span><br><span class="line">System                           4 Services                   0      1,060 K</span><br><span class="line">Secure System                  168 Services                   0     75,552 K</span><br><span class="line">Registry                       248 Services                   0    227,004 K</span><br><span class="line">smss.exe                       708 Services                   0      1,332 K</span><br><span class="line">csrss.exe                      864 Services                   0      5,612 K</span><br><span class="line">wininit.exe                   1168 Services                   0      6,716 K</span><br><span class="line">csrss.exe                     1176 Console                    1     12,260 K</span><br><span class="line">services.exe                  1240 Services                   0     17,772 K</span><br><span class="line">LsaIso.exe                    1248 Services                   0      3,756 K</span><br></pre></td></tr></tbody></table></figure>
<h3 id="模式切换和进程切换">模式切换和进程切换</h3>
<p>内核包含了重要的系统功能，常驻内存，管理资源和支撑系统。例如内核管理着进程的创建、终止、调度、同步、通信等，并且管理着存储空间中进程地址分配、内存交换、段页管理等功能。中断处理也是通过内核完成的。</p>
<p>在程序状态寄存器中存在指示执行模式的位。</p>
<ol>
<li>内核模式。它由操作系统直接控制，具有更多的优先权和特权。部分底层的 IO 指令、寄存器操作指令、内存管理指令只能通过特权模式由内核发出。部分内存也只能通过特权模式由内核访问。</li>
<li>用户模式。它具备较少的优先权，用户在该模式下运行指令。</li>
</ol>
<p><strong>进程创建时</strong>，操作系统分配内存和用于管理进程的数据结构，然后对进程进行初始化，将新进程插入对应队列。</p>
<p>进程切换由<strong>系统中断</strong>和<strong>系统调用</strong>完成。系统中断又分为普通中断和陷阱。<strong>进程切换</strong>的详细步骤：</p>
<ol>
<li>保存当前处理器的上下文环境，比如寄存器信息。</li>
<li>更新进程控制块的信息，将进程控制块移动到相应的队列。</li>
<li>选择另外一个进程，更新它的进程控制块信息。</li>
<li>更新内存管理数据结构。</li>
<li>执行结束后，恢复之前的上下文环境，载入之前寄存器的值。</li>
</ol>
<img src="http://cdn.blog-blockchain.xyz/202212131523752.png" alt="图片1" style="zoom: 50%;">
<p><strong>模式切换的过程</strong>：当发生系统中断时，程序计数器置为中断处理程序开始地址，然后从用户模式切换成内核模式，以便执行特权指令。注意模式切换的过程可以不改变进程的状态。</p>
<h3 id="线程">线程</h3>
<p><strong>进程是拥有资源的最小单位</strong>，也是调度和执行的基本单位。线程是单个进程内更加细粒度的并发执行的单位，是<strong>调度的最小单位</strong>。线程的创建时间更短、终止花费的时间更短、线程切换时间比进程切换时间更短，因此线程更加轻量级，提高了不同程序间通信的效率。<strong>调度和分派是在线程的基础上完成的</strong>。</p>
<p>一个进程可能有多个线程，每个线程包括</p>
<ol>
<li>执行状态（运行、就绪等）</li>
<li>未运行时保存的线程上下文</li>
<li>执行栈</li>
<li>用于局部变量的静态存储空间</li>
<li>与进程内其他线程共享的内存和资源访问</li>
</ol>
<p><img src="http://cdn.blog-blockchain.xyz/202212291244894.png" alt="image-20221229124455762"></p>
<p>**一个进程中的所有线程共享一个地址空间和进程所拥有的资源。一个线程对共享资源的修改都将影响同一进程的其他线程的环境。**线程也包括了和进程类似的状态和基本操纵：派生、阻塞、解除阻塞、结束。</p>
<p>线程可以分为</p>
<ul>
<li>用户级线程。线程的管理工作都由应用程序完成，内核意识不到线程的存在。因此，用户线程由应用程序决定，可以运行在任何操作系统上。但是当用户级线程请求系统调用时，<strong>会阻塞当前进程中所有的用户级线程</strong>。<strong>不能利用多处理器技术</strong>。</li>
<li>内核级线程。线程的管理工作由内核完成，允许同一进程内的多个线程被多处理器处理，<strong>一个线程阻塞时，内核可以调度其他线程</strong>。但是，内核级线程切换时，需要切换到内核模式，会有额外开销。</li>
</ul>
<h3 id="进程调度">进程调度</h3>
<p>当多个进程或者线程竞争 CPU 时，需要选择下一个要运行的进程或者线程，OS 中有完成这个工作的调度程序（scheduler）。</p>
<p>调度根据距离执行的远近，分为</p>
<ul>
<li>长程调度。决定哪个程序可以进入系统中处理，创建进程</li>
<li>中程调度。内存的交换部分，主要是考虑并发度的限制和存储的限制。</li>
<li>短程调度。最为频繁的调度程序，直接决定下次执行哪个进程。</li>
</ul>
<p>具体如下图所示</p>
<p><img src="http://cdn.blog-blockchain.xyz/202301062241445.png" alt="image-20230106224153374"></p>
<p>下面是一些会用到的概念：</p>
<ul>
<li>响应时间。从用户提交一个请求开始，到接收响应之间的时间间隔。由输入传送时间、处理时间、响应传送时间构成。</li>
<li>截止时间。某任务必须开始执行的最迟时间，或必须完成的最迟时间。</li>
<li>系统吞吐量。在单位时间内，系统所完成的进程数。</li>
<li>处理器利用率。处理器处于忙状态的时间百分比。</li>
<li>周转时间。一个进程从提交到完成之间的时间间隔，等于等待资源的时间+执行时间。</li>
<li>平均周转时间。多个进程周转时间的平均值。</li>
<li>带权周转时间：进程的周转时间与系统为它提供的服务时间之比。服务时间是系统预计完成需要的时间。</li>
<li>平均带权周转时间：多个进程带权周转时间的平均值。</li>
</ul>
<p>短期调度会直接影响系统性能，需要达到的目标是：用户感知的交互响应时间尽可能短、用户程序完成时间尽可能短、处理器利用效率尽可能高。具体如下图</p>
<p><img src="http://cdn.blog-blockchain.xyz/202301062335665.png" alt="image-20230106233503614"></p>
<h3 id="调度算法">调度算法</h3>
<p>调度可以采用强制优先级，但是可能造成某些进程饥饿，也就是长时间得不到执行机会，因此可以采用动态优先级的方案。动态优先级调度算法分为<strong>抢占和非抢占</strong>，主要区别在于抢占式能中断正在执行的进程，然后执行新的进程。非抢占式需要等待当前进程执行完或者请求服务时被阻塞，新的进程才能执行。</p>
<p>在决定哪个就绪进程执行时， 有三个关键参数。</p>
<ul>
<li>w = 目前为止在系统里的等待时间</li>
<li>e = 目前为止花费的执行时间</li>
<li>s = 进程所需的总服务时间，包括 e; 这个参数需要估计或者由用户提供。</li>
</ul>
<p>不同的目标就有不同的调度算法，下表是调度算法概览：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>FCFS</strong></th>
<th style="text-align:center"><strong>Round robin</strong></th>
<th style="text-align:center"><strong>SPN</strong></th>
<th style="text-align:center"><strong>SRT</strong></th>
<th style="text-align:center"><strong>HRRN</strong></th>
<th style="text-align:center"><strong>Feedbadk</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">选择函数</td>
<td style="text-align:center">max[w]</td>
<td style="text-align:center">常数</td>
<td style="text-align:center">min[s]</td>
<td style="text-align:center">min[s-e]</td>
<td style="text-align:center">max[(w+s)/s]</td>
<td style="text-align:center">参后描述</td>
</tr>
<tr>
<td style="text-align:center">决策模式</td>
<td style="text-align:center">非抢占</td>
<td style="text-align:center">抢占(时间片完)</td>
<td style="text-align:center">非抢占</td>
<td style="text-align:center">抢占（到达时）</td>
<td style="text-align:center">非抢占</td>
<td style="text-align:center">抢占(时间片完)</td>
</tr>
<tr>
<td style="text-align:center">吞吐量</td>
<td style="text-align:center">不强调</td>
<td style="text-align:center">时间片小时，吞吐量低</td>
<td style="text-align:center">高</td>
<td style="text-align:center">高</td>
<td style="text-align:center">高</td>
<td style="text-align:center">不强调</td>
</tr>
<tr>
<td style="text-align:center">响应时间</td>
<td style="text-align:center">可能很高，尤其在进程执行时间差别大时</td>
<td style="text-align:center">为短进程提供较好的响应时间</td>
<td style="text-align:center">为短进程提供较好的响应时间</td>
<td style="text-align:center">提供较好的响应时间</td>
<td style="text-align:center">提供较好的响应时间</td>
<td style="text-align:center">不强调</td>
</tr>
<tr>
<td style="text-align:center">开销</td>
<td style="text-align:center">最小</td>
<td style="text-align:center">最小</td>
<td style="text-align:center">可能较大</td>
<td style="text-align:center">可能较大</td>
<td style="text-align:center">可能较大</td>
<td style="text-align:center">可能较大</td>
</tr>
<tr>
<td style="text-align:center">对进程影响</td>
<td style="text-align:center">对短进程不利；对 I/O 密集型进程不利</td>
<td style="text-align:center">公平对待</td>
<td style="text-align:center">对长进程不利</td>
<td style="text-align:center">对长进程不利</td>
<td style="text-align:center">平衡性好</td>
<td style="text-align:center">对 I/O 密集型进程可能有利</td>
</tr>
<tr>
<td style="text-align:center">饥饿</td>
<td style="text-align:center">无</td>
<td style="text-align:center">无</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">无</td>
<td style="text-align:center">可能</td>
</tr>
</tbody>
</table>
<h4 id="先来先服务-FCFS">先来先服务 FCFS</h4>
<p>选择就绪队列中存在时间最长的进程运行，即按<strong>请求 CPU 的顺序使用 CPU</strong>。对于下面的调度，结果如下图。</p>
<table>
<thead>
<tr>
<th><strong>进程名</strong></th>
<th><strong>产生时间</strong></th>
<th><strong>服务时间</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>8</td>
<td>2</td>
</tr>
</tbody>
</table>
<img src="http://cdn.blog-blockchain.xyz/202301062359685.png" alt="image-20230106235907630" style="zoom:50%;">
<p>平均周转时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>3</mn><mo>+</mo><mn>7</mn><mo>+</mo><mn>9</mn><mo>+</mo><mn>12</mn><mo>+</mo><mn>12</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>5</mn><mo>=</mo><mn>8.6</mn></mrow><annotation encoding="application/x-tex">(3+7+9+12+12)/5=8.6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">12</span><span class="mclose">)</span><span class="mord">/5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8.6</span></span></span></span>，平均带权周转时间</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mfrac><mn>3</mn><mn>3</mn></mfrac><mo>+</mo><mfrac><mn>7</mn><mn>6</mn></mfrac><mo>+</mo><mfrac><mn>9</mn><mn>4</mn></mfrac><mo>+</mo><mfrac><mn>12</mn><mn>5</mn></mfrac><mo>+</mo><mfrac><mn>12</mn><mn>2</mn></mfrac></mrow><mn>5</mn></mfrac><mo>=</mo><mn>2.56</mn></mrow><annotation encoding="application/x-tex">\frac{\frac{3}{3}+\frac{7}{6}+\frac{9}{4}+\frac{12}{5}+\frac{12}{2}}{5}=2.56
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.2661em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5801em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.735em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2.56</span></span></span></span></span></p>
<p>FCFS 是非抢占调度算法，<strong>有利于 CPU 繁忙型的进程，而不利于 I/O 繁忙型的进程</strong>，平均周转时间长，不利于短进程，因为等待时间较长。</p>
<h4 id="时间片轮转调度算法-RR">时间片轮转调度算法 RR</h4>
<p>每个进程被分配一个时间片，周期性产生时钟中断，中断时当前进程进入就绪队列末尾，基于 FCFS 选择下一个作业运行。<strong>如果进程在时间片内阻塞或结束，则 CPU 立即执行调度</strong>。</p>
<p>这是抢占式算法，时间片用完之后一定会被中断。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>进程名</strong></th>
<th style="text-align:center"><strong>产生时间</strong></th>
<th style="text-align:center"><strong>服务时间</strong></th>
<th style="text-align:center"><strong>时间片</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>C</strong></td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>D</strong></td>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><strong>E</strong></td>
<td style="text-align:center">8</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<img src="http://cdn.blog-blockchain.xyz/202301262100605.png" style="zoom:50%;">
<p>**先添加新进程到队尾，再把过了时间片的进程放在最后。**具体过程如下，需要每个时刻：</p>
<ol>
<li>A2。这里标记的方法是，进程名字后的数字表示还剩下的服务时间。</li>
<li>B6A1</li>
<li>A1B5</li>
<li>B5C4</li>
<li>C4B4</li>
<li>B4D6C3</li>
</ol>
<p>过程以此类推。RR 算法属于抢占性算法，常用于分时系统。时间片的长短会显著地影响系统的性能，太短则进程切换太频繁，太长则短进程会产生时间浪费。另外，由于 IO 会阻塞进程，所以<strong>对 IO 密集类型的进程不利，对 CPU 密集的类型有利</strong>。在 RR 算法的基础上，提出了改进后的 VRR 算法，用于改善 IO 密集类型进程的不利地位。</p>
<h4 id="短进程优先-SJF-SPF-SPN">短进程优先 SJF/SPF/SPN</h4>
<p>短进程优先算法是<strong>非抢占式</strong>的算法，每当当前进程结束，就会根据当前每个进程的服务时间选择执行哪一个进程。</p>
<table>
<thead>
<tr>
<th><strong>进程名</strong></th>
<th><strong>产生时间</strong></th>
<th><strong>服务时间</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>8</td>
<td>2</td>
</tr>
</tbody>
</table>
<img src="http://cdn.blog-blockchain.xyz/202301262107906.png" alt="image-20230126210727844" style="zoom:50%;">
<p>核心点在于进程结束之后，选择服务时间最短的进程执行。由于短进程优先，所以服务时间长的进程容易饥饿，同时也减少了平均周转时间。服务时间是用户估计的时间，但是不一定等于实际需要占用处理机的时间。由于没有抢占机制，可能不适合某些场景。</p>
<p>平均周转时间 <code>(3+7+11+14+2)/5=7.4</code>，平均带权周转时间 <code>(3/3+7/6+11/4+14/5+2/2)/5=1.74</code></p>
<h4 id="剩余时间最短优先-SRT">剩余时间最短优先 SRT</h4>
<p>剩余时间最短优先算法是<strong>抢占式</strong>的算法，每当当前进程结束<strong>或者新进程到来</strong>，就会根据当前每个进程剩余的服务时间选择执行哪一个进程。数据与之前的相同，得到的结果如下。</p>
<img src="http://cdn.blog-blockchain.xyz/202301262123148.png" alt="image-20230126212347084" style="zoom:50%;">
<ul>
<li>时刻 2 时，A 剩下 1，B 剩下 6，执行 A</li>
<li>时刻 3 时，B 剩下 6，执行 B</li>
<li>时刻 4 时，B 剩下 5，C 剩下 4，所以抢占，执行 C。</li>
<li>时刻 6 时，B 剩下 5，C 剩下 2，D 剩下 5.</li>
<li>时刻 8 时，B 剩下 5，D 剩下 5，E 剩下 2，所以执行 E。</li>
<li>时刻 10 时，<strong>因为 B 和 D 剩下时间相同，按照入队顺序，执行 B</strong></li>
<li>时刻 15 时，执行 D。</li>
</ul>
<p>平均周转时间 <code>(3+13+4+14+2)/5=7.2</code>，平均带权周转时间 <code>(3/3+13/6+4/4+14/5+2/2)/5=1.59</code>。周转时间方面，SRT 比 SJF 性能要好，只要就绪，短作业可以立即被选择执行。但是仍然存在长进程饥饿等问题。</p>
<h4 id="高响应比优先-HRRN">高响应比优先 HRRN</h4>
<p>当前进程执行完毕或需要阻塞时，选择就绪队列中响应比最高的进程投入执行。他是<strong>非抢占性</strong>调度算法。响应比的计算 <code>(等待时间+要求服务时间)/要求服务时间</code>。</p>
<table>
<thead>
<tr>
<th><strong>进程名</strong></th>
<th><strong>产生时间</strong></th>
<th><strong>服务时间</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>8</td>
<td>2</td>
</tr>
</tbody>
</table>
<img src="http://cdn.blog-blockchain.xyz/202301262308365.png" alt="image-20230126230822298" style="zoom: 50%;">
<ul>
<li>时刻 3，A 执行结束，只剩下 B。所以执行 B。</li>
<li>时刻 9，B 执行结束，C 响应比(5+4)/4=2.25，D 响应比(3+5)/5=1.6，所以执行 C。</li>
<li>时刻 13，C 执行完，D 响应比(7+5)/5=2.4，E 响应比(5+2)/2，所以执行 E。</li>
</ul>
<p>HRRN 算法其实是动态权重算法，既考虑了短进程不应该等待过长的时间，又考虑了长进程不至于饥饿。但是计算响应比会增加开销。</p>
<h4 id="反馈调度-FB">反馈调度 FB</h4>
<p>采用了「惩罚运行时间较久的进程」 的思想，算法有很多种，大致的思路是维护多个就绪队列，每个队列的优先级不同，进程根据一定的规则动态调整优先级。注意是<strong>抢占式</strong>调度算法。</p>
<p>下面介绍一种基于时间片轮转的反馈调度算法，具体规则如下：</p>
<ol>
<li>
<p>设置多个就绪队列，每个队列赋予不同优先级。</p>
<ol>
<li>第一队列优先级最高，依次递减；</li>
<li>各个队列中进程执行的时间片不相同，优先级越高的队列，时间片越小。</li>
</ol>
</li>
<li>
<p>新进程进入时，首先放入第一个队列尾，按 FCFS 原则排队。</p>
</li>
<li>
<p>如果进程在当前队列规定的时间片内完成则退出，一般而言，从队列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 中调度的进程允许执行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span> 的时间，然后才被抢占，降级到下一个优先级队列（如果没有被抢占（无其他进程需调度），则当前进程不降级）。</p>
</li>
<li>
<p>到达最低优先级队列后，不再降级。</p>
</li>
<li>
<p>仅当第一队列空闲时，才调度第二队列中的进程，依次类推。</p>
</li>
</ol>
<p>仍然是之前的例子，调度的结果如下，<strong>队列编号从 0 开始</strong>。</p>
<p><img src="http://cdn.blog-blockchain.xyz/202301271656699.png" alt="image-20230127165612521"></p>
<ul>
<li>时刻 0，A 进入队列 0，允许执行的时间是 1。</li>
<li>时刻 1，因为没有其他进程，A 不降级，进入队列 0，允许执行时间 1。执行 A。</li>
<li>时刻 2，A 时间片用完，被抢占，队列 0 是 B，队列 1 是 A，所以 B 执行一个单位。</li>
<li>时刻 3，B 时间片用完，队列 1 是 AB，所以执行 A。</li>
<li>时刻 4，A 执行完退出，队列 0 是 C，队列 1 是 B，所以执行 C。</li>
<li>时刻 5，C 执行完，队列 1 是 BC，所以执行 B。</li>
<li>时刻 6，由于 B 允许执行 2 个单位才被抢占，所以继续执行。</li>
<li>时刻 7，队列 0 是 D，队列 1 是 C，队列 2 是 B。</li>
<li>以此类推</li>
</ul>
<p>多级反馈队列调度算法性能较好，短进程可以在前面几个队列执行完，长进程允许执行的时间也能快速增长。但是如果一直提交短进程，长进程仍然可能饥饿。</p>
<h3 id="实时系统的调度">实时系统的调度</h3>
<p>实时系统能够<strong>即时</strong>响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务<strong>协调一致</strong>地运行。规定的时间分为</p>
<ul>
<li>开始截止时间：必须在某个时间之前执行任务。</li>
<li>完成截至时间：必须在某个时间之前完成任务。</li>
</ul>
<h4 id="实时任务">实时任务</h4>
<p>实时任务一般有如下信息：</p>
<ul>
<li>就绪时间</li>
<li>启动的限期（starting deadline）</li>
<li>完成的限期（completion deadline）</li>
<li>处理的时间：任务执行到完成的时间</li>
<li>资源需求：任务执行过程中所需的资源集</li>
<li>优先级：度量任务的相对重要性</li>
<li>子任务结构：一个任务可分解为一个必须执行的子任务和一个可选执行子任务，前者有硬截止时间（hard deadline）</li>
</ul>
<p>可以知道，越早执行就越容易满足期限。非抢占方式可以更好的安排任务，满足启动的期限。抢占的方式可以更好的满足完成的期限。</p>
<h4 id="调度算法的组成">调度算法的组成</h4>
<p>我们之前讨论的调度算法，都是实时系统的调度算法。实时系统的调度则是由调度方法和抢占的方式决定的。这一小节会从理论上概括调度算法。</p>
<p>调度方法可以分成如下几类：</p>
<ol>
<li><strong>静态表驱动</strong>：他用于调度<strong>周期性实时任务</strong>，根据任务周期到达的时间、执行时间、完成截止时间（ending deadline）以及任务的优先级，<strong>制订调度表</strong>。这种算法不灵活，静态的调度表要经常修改。</li>
<li><strong>静态优先级抢占调度法</strong>：多用于非实时多道程序系统，根据系统时间的约束赋予优先级。多道程序系统是在<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98/9021807?fromModule=lemma_inlink">计算机内存</a>中同时存放几道相互独立的程序，使它们在管理<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6?fromModule=lemma_inlink">程序控制</a>之下，相互穿插的运行。也就是一般意义上的单 CPU，微观串行模式。</li>
<li><strong>基于动态规划的调度法</strong>：当实时任务到达后动态地创建一张调度表，如果能够满足当前任务地时间约束，那么立即执行新任务。</li>
<li><strong>动态尽力调度法</strong>：广泛用于非周期性实时任务调度，当任务到达时，系统根据其属性赋予优先级，优先级高的先调度。但是可能难以兼顾任务的时间约束。</li>
</ol>
<p>抢占方式可以分成如下几类：</p>
<ol>
<li>基于时间片轮转的抢占式。响应时间一般为<strong>秒级</strong>。</li>
<li>基于优先级的非抢占式。响应时间为<strong>几百毫秒到几秒</strong>。</li>
<li>基于优先级的抢占式。响应时间<strong>几毫秒至几十毫秒</strong></li>
<li>立即抢占式。响应时间<strong>微秒至毫秒级</strong>。</li>
</ol>
<p>针对每种情况的调度算法就不细说了，内容确实很繁杂。</p>
<h4 id="优先级反转">优先级反转</h4>
<p>优先级反转，是指某同步<strong>资源被较低优先级的进程/线程所拥有</strong>，较高优先级的进程/线程竞争该同步资源未获得该资源，而使得较高优先级进程/线程反而推迟被调度执行的现象。这是是一种<strong>不希望发生</strong>的任务调度状态。在该种状态下，一个高优先级任务间接被一个低优先级任务所抢先(preempted)，使得两个任务的相对优先级被倒置。</p>
<p>有一种解决方法叫<strong>优先级继承</strong>，也就是占有了资源的进程的优先级，继承共享这个进程的优先级。</p>
<h3 id="进程的同步">进程的同步</h3>
<p>这里的进程的并发都是指多道程序系统，宏观并行，微观穿行，也就是<strong>单处理器交替执行</strong>。进程是<strong>独立</strong>的个体，可以<strong>异步</strong>、并发，但是 CPU、内存等资源只能有限地使用。</p>
<p>部分术语如下：</p>
<ul>
<li>原子操作。由一个或多个指令序列实现的动作或函数，对外不可见，一组指令要么都执行，要么都不执行。</li>
<li>互斥。当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问共享资源的情形。</li>
<li>临界资源。不可同时访问，必须互斥访问的资源，如打印机。</li>
<li>临界区。访问临界资源的代码，任意时刻只能由一个进程在这段代码中运行。</li>
<li>忙等现象。当一个进程等待进入临界区时，它会继续消耗处理器的时间。</li>
<li>活锁。两个或两个以上的进程为响应其他进程而持续改变自己状态，但是<strong>不做有用工作</strong>的情形。</li>
<li>死锁。两个或两个以上的进程因等待其他进程做完某些事而<strong>不能继续执行</strong>的情形。</li>
<li>竞争条件。多个进程或线程读写共享的数据时，结果取决于多个进程的指令执行顺序。</li>
<li>饥饿。一个具备执行条件的进程，被调度程序无限期的忽视而不能调度的情形。</li>
</ul>
<img src="http://cdn.blog-blockchain.xyz/202301280943718.png" alt="image-20230128094358647" style="zoom: 33%;">
<p>由于进程执行的相对速度不可预测，资源的共享和协调就较为困难。比如某个变量被多个进程共享，那么每个进程读取这个变量时获得的值，可能不确定。所以需要设计控制访问共享资源的方法。</p>
<p>除了<strong>基于资源共享</strong>的进程之间的合作，还有<strong>基于通信</strong>的进程之间的合作。一个进程执行的结果可能由其他进程提供的信息决定。比如必须等接收到特定的信号之后，某个进程才能开始执行。</p>
<h4 id="互斥">互斥</h4>
<p>为了控制进程对临界资源的访问，提出了互斥的概念，互斥的性质如下：</p>
<ol>
<li><strong>空闲让进</strong>：如临界区空闲，则有进程申请就立即进入。</li>
<li><strong>忙则等待</strong>：每次只允许一个进程处于临界区。</li>
<li><strong>有限等待</strong>：保证进程在有限时间内能进入临界区。</li>
<li><strong>让权等待</strong>：进程在临界区不能长时间阻塞等待某事件。</li>
</ol>
<h4 id="软件方法">软件方法</h4>
<p>在编程中我们可以用最原始的方法实现互斥，这叫做实现互斥的<strong>软件方法</strong>。他的核心思想在于：</p>
<ol>
<li>进入临界区时，设置和检查一些标志，<strong>判断临界区是否被占有</strong>。</li>
<li>若已有进程在临界区，则在临界区的入口，<strong>循环地检查标志，等待临界区空闲后访问</strong>。</li>
<li>进程离开临界区时，需要修改标志。</li>
</ol>
<p>这是单 CPU 的背景下的进程调度，就是说每个时刻只能运行一个进程，微观串行。下面不同的进程中是访问同样的临界区。</p>
<p><strong>单标志法</strong></p>
<p>进程访问完临界资源后会把使用临界资源的权限主动转让给另一个进程。即每个进程进入临界区的权限只能被另一个进程赋予。通过一个标志表示应该执行哪一个进程。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> trun = <span class="number">0</span>;                      <span class="comment">//共享的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程P0</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">0</span>) ;           <span class="comment">//进入区</span></span><br><span class="line">    <span class="comment">//进程P0的临界区代码； 			//临界区</span></span><br><span class="line">    turn = <span class="number">1</span>;                     <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">//进程P0的其它代码				 //剩余区</span></span><br><span class="line">} <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程P1</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    <span class="keyword">while</span> (turn != <span class="number">1</span>) ;           <span class="comment">//进入区</span></span><br><span class="line">    <span class="comment">//进程P1的临界区代码； 			//临界区</span></span><br><span class="line">    turn = <span class="number">0</span>;                     <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">//进程P1的其它代码          	 //剩余区</span></span><br><span class="line">} <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>这是最容易想到的，一个全局变量，然后两个进程之间轮换，但是违反了空闲让进的原则。如果是 P1 先进入，那么就会在 while 处执行空的循环，直到时间片用完。但是这个期间，虽然 P1 没有访问临界区，但是 P0 也无法访问临界区，这就违反了空闲让进的原则了。</p>
<p>也就是必须按照一定的顺序执行才行，<strong>每个进程执行的权限来自其他进程，如果其他进程没有先执行，就会违反空闲让进原则</strong>。</p>
<p><strong>双标志先检查法</strong></p>
<p>通过设置一个数组，表示每个进程进入临界区的意愿，每个进程在使用资源之前先检查是否有别的进程想进入临界区。如果没有则将自身对应的标志 flag[i] 置为 true，并开始访问临界区；有则先让其他进程使用。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">boolean flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};   <span class="comment">//共享的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程P0</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">1</span>]) ;               <span class="comment">//进入区</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;                 <span class="comment">//进入区</span></span><br><span class="line">    <span class="comment">//进程P0的临界区代码； 			  //临界区</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>;                <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">//进程P0的其它代码          	   //剩余区</span></span><br><span class="line">} <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程P1</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">0</span>]) ;               <span class="comment">//进入区</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>;                 <span class="comment">//进入区</span></span><br><span class="line">    <span class="comment">//进程P1的临界区代码； 			  //临界区</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>;                <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">//进程P1的其它代码				   //剩余区</span></span><br><span class="line">} <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>但是如果执行 #5 和 #14 的检查之后，#6 之后执行 #15，就会造成同时访问临界区的情况，违反了忙则等待的原则。这是因为检查和上锁之间，其他进程可能已经通过了检查，也在准备上锁。<strong>把检查和上锁结合在一块，形成原子操作，是可行的办法</strong>。</p>
<p><strong>双标志后检查法</strong></p>
<p>和上一个方法类似，差别在于先上锁后检查。但是如果在上锁和检查之间，另外一个进程也上锁了，就会造成死锁。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">boolean flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};    <span class="comment">//共享的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程P0</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;                  <span class="comment">//进入区</span></span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">1</span>]) ;                <span class="comment">//进入区</span></span><br><span class="line">    <span class="comment">//进程P0的临界区代码；			   //临界区</span></span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>;                 <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">//进程P0的其它代码          		//剩余区</span></span><br><span class="line">} <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程P1</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>;                  <span class="comment">//进入区</span></span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">0</span>]) ;                <span class="comment">//进入区</span></span><br><span class="line">    <span class="comment">//进程P1的临界区代码； 			   //临界区</span></span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>;                 <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">//进程P1的其它代码         	    //剩余区</span></span><br><span class="line">} <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Dekker 互斥算法</strong></p>
<p>这个算法结合了单标志法和双标志法，在使用临界资源前，判断对方是否想使用资源，而且资源的使用权是否已经给了对方。如果都是，则自己暂时不想使用资源，等待对方释放资源后，再想要资源。重复进行这样的等待，直到对方不想使用资源。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">boolean flag[<span class="number">2</span>] = {<span class="literal">false</span>, <span class="literal">false</span>};              <span class="comment">//共享的全局变量</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">1</span>;                                  <span class="comment">//共享的全局</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程P0</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">true</span>;                            <span class="comment">//进入区</span></span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">1</span>]) {</span><br><span class="line">       <span class="keyword">if</span> (turn == <span class="number">1</span>)  {</span><br><span class="line">           flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">while</span>  (turn == <span class="number">1</span>) ;                <span class="comment">//等待</span></span><br><span class="line">           flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">     }                                         <span class="comment">//进入区</span></span><br><span class="line">    <span class="comment">//进程P0的临界区代码；            			 //临界区</span></span><br><span class="line">    turn = <span class="number">1</span>;</span><br><span class="line">    flag[<span class="number">0</span>] = <span class="literal">false</span>;                           <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">//进程P0的其它代码                   		  //剩余区</span></span><br><span class="line">} <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程P1</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">true</span>;                            <span class="comment">//进入区</span></span><br><span class="line">    <span class="keyword">while</span> (flag[<span class="number">0</span>]) {</span><br><span class="line">       <span class="keyword">if</span> (turn == <span class="number">0</span>)  {</span><br><span class="line">           flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">while</span>  (turn == <span class="number">0</span>) ;           	   <span class="comment">//等待</span></span><br><span class="line">           flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">     }                                         <span class="comment">//进入区</span></span><br><span class="line">    <span class="comment">//进程P1的临界区代码；          				 //临界区</span></span><br><span class="line">    turn = <span class="number">0</span>;</span><br><span class="line">    flag[<span class="number">1</span>] = <span class="literal">false</span>;                           <span class="comment">//退出区</span></span><br><span class="line">    <span class="comment">//进程P1的其它代码                   		  //剩余区</span></span><br><span class="line">} <span class="keyword">while</span> (<span class="literal">true</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>上述所有的软件方法，都是依靠循环实现，所以没有遵循让权等待的原则</strong></p>
<h4 id="硬件方法">硬件方法</h4>
<p>硬件方法分为<strong>中断禁用</strong>和<strong>机器指令</strong>。中断禁用，就是屏蔽中断，利用 「开/关中断指令」实现互斥。「关中断」和「开中断」之间的代码就是临界区。由于关中断后 CPU 会屏蔽中断，而<strong>进程切换依赖于中断</strong>，因此可以保证其他进程不会访问到这个临界区，避免了资源竞争。</p>
<p>但是中断禁用的办法<strong>只能在单 CPU 计算机使用</strong>，不同 CPU 之间的进程需要额外的协调机制。</p>
<p>机器指令是指在设计 CPU 时就设计了一些指令，用于<strong>保证两个动作的原子性</strong>。比较典型的例子是 <code>compare&amp;swap </code>，比较一个内存单元的值和一个测试值，如果相等，则发生交换。这个操作就必须保持原子性。再比如 <code>Exchange</code>，原子性地交换寄存器和内存的值。它涉及到两次写入，也是需要保持原子性。</p>
<p>采用机器指令可以支持多 CPU、多临界区计算机，而且简单易证明。但是使用不当也会造成死锁。</p>
<h4 id="信号量">信号量</h4>
<p>两个或多个进程可以通过传递信号进行合作，主要功能是：</p>
<ul>
<li>迫使进程在某个位置暂时停止执行（阻塞）</li>
<li>直到它收到一个可以“向前推进”的信号（被唤醒）</li>
</ul>
<p>这样的机制就叫做信号量机制。表示这样的信号的变量就叫做信号量。信号量是一个值为整数的变量，只能进行下面的三类操作：</p>
<ol>
<li>初始化为非负数。</li>
<li>semWait （Wait 或 P）操作使信号量的值减少 1。若值变为负数，则阻塞执行 semWait( Wait 或 P)操作的进程。</li>
<li>semSignal（Signal 或 V）操作使信号量的值增加 1，若值小于等于零，则被 semWait(Wait 或 P)阻塞的进程解除阻塞。</li>
</ol>
<p>信号量里 count 值可以解释如下</p>
<ul>
<li>s.count ≥ 0, s.count 表示执行 semWait(s)操作而不被阻塞的进程数（或可看作可用资源数）。这种情形信号量可支持同步与互斥。</li>
<li>s.count &lt; 0, s.count 表示阻塞在 s.queue 队列上的进程数。</li>
</ul>
<p><strong>生产者/消费者问题</strong></p>
<p>生产者/消费者问题是信号量使用的经典方式，描述如下：</p>
<ul>
<li>一个或者多个生产者产生数据，并放入缓冲区。</li>
<li>每次只能有一个消费者从缓冲中取出数据。</li>
<li>任何时候只能由一个生产者或消费者访问缓冲。（互斥关系）</li>
<li>保证缓冲区满时，生产者不会往缓冲区中增加数据。（同步关系）</li>
<li>保证缓冲区空时，消费者不能从缓冲区中取走数据。（同步关系）</li>
</ul>
<p>上面的条件中包括了两个同步关系和一个互斥关系。所以需要三个信号量表示。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n; <span class="comment">//同步信号量，表示空闲缓冲单位的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;  <span class="comment">//同步信号量，表示产品的数量，也即非空缓冲单位的数量</span></span><br><span class="line"></span><br><span class="line">producer(){</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        <span class="comment">//生产1个产品;</span></span><br><span class="line">        P(empty);    <span class="comment">// 消耗一个空闲缓冲单位</span></span><br><span class="line">        P(mutex);	 <span class="comment">// 访问缓冲区</span></span><br><span class="line">        <span class="comment">//把产品放入缓冲区;</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);	 <span class="comment">// 增加一个产品</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer(){</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        P(full);     <span class="comment">// 消耗一个缓存区中的产品</span></span><br><span class="line">        P(mutex);	 <span class="comment">// 访问缓冲区</span></span><br><span class="line">        <span class="comment">//从缓冲区取出产品;</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);	 <span class="comment">// 增加一个可用缓冲区单位</span></span><br><span class="line">        <span class="comment">//使用产品;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意：</p>
<ol>
<li>先申请资源信号量，再申请互斥信号量。如果反过来的话，会发生死锁。因为当缓冲区满之后，生产者的 <code>P(empty)</code> 会阻塞，同时上一句的 <code>P(mutex)</code> 会导致消费者的 <code>P(mutex)</code> 阻塞。</li>
<li>消费者的 <code>V(mutex)</code> 和 <code>V(empty)</code> 顺序可以互换。</li>
</ol>
<p>来看下面这个实际练习.</p>
<p>桌子上有一只盘子，最多可以放入 N（N&gt;0）个水果。爸爸随机向盘中放入苹果或桔子。儿子只吃盘中的桔子，女儿只吃盘中的苹果。只有盘子中水果数目小于 N 时，爸爸才可以向盘子中放水果（两个同步关系）；仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果（同步关系）；每次只能放入或取出一个水果，且不允许多人同时使用盘子（互斥关系）。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">//一个盘子只能被一个人使用</span></span><br><span class="line">semaphore orange = <span class="number">0</span>; <span class="comment">//必须有橘子，儿子才能取橘子</span></span><br><span class="line">semaphore apple = <span class="number">0</span>; <span class="comment">//必须有苹果，女儿才能取苹果</span></span><br><span class="line">semaphore empty = N;<span class="comment">//必须有空位，爸爸才能放水果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//爸爸放水果</span></span><br><span class="line">P1(){</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        <span class="comment">//选择水果类型</span></span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">//放入水果进盘子</span></span><br><span class="line">        V(mutex)</span><br><span class="line">        V(orange or apple)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//儿子取桔子</span></span><br><span class="line">sun(){</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        P(orange);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">//取出苹果</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//女儿取走苹果</span></span><br><span class="line">sun(){</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        P(apple);</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="comment">//取出苹果</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>如果改变条件，爸爸放苹果，妈妈放桔子，其他不变。那么只要增加一个和生产者类似的进程即可。</p>
<p><strong>读者和写者问题</strong></p>
<p>多个进程访问一个共享数据区（可为文件、内存空间、寄存器），其中有些进程只能读取数据，有些只能写入数据，有些则有读写权限。规定进程可以<strong>同时读、互斥写(不能同时写)、互斥读写（不能同时读写）</strong>。这个问题和消费者/生产者问题的区别在于，它可以同时读取。</p>
<p>为了完成互斥，就可以选择读者优先、写者优先，或者公平读写的策略。</p>
<p><strong>读者优先</strong>就是必须全部读者都完成了，才能写入。很显然，容易造成写者饥饿的问题。此时需要，读写互斥锁、读者的数量，由于读者数量是没有限制的，我们采用加互斥锁和变量来实现。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> readCount=<span class="number">0</span>；</span><br><span class="line">semaphore readCountMutex = <span class="number">1</span>, wMutex=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        P(readCountMutex);</span><br><span class="line">        readCount++;</span><br><span class="line">        <span class="keyword">if</span>(readCount==<span class="number">1</span>) P(wMutex); <span class="comment">//读写互斥</span></span><br><span class="line">        V(readCountMutex);</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        P(readCountMutex);</span><br><span class="line">        readCount--;</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">0</span>) V(wMutex);</span><br><span class="line">        V(readCountMutex)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> {</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        P(wMutex);</span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        V(wMutex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>写者优先</strong>就是存在写者声明需要读取数据时，之前的读者必须先完成，之后的新的读者暂时不能读取数据，需要等待写入完毕之后才行。但是如果又有新的写入进程，那么会接着上一个写入进程执行。显然，由于读者被推迟，系统的并发性能较差。并发时需要考虑：</p>
<ol>
<li>之前的读者必须完成，所以需要记录之前读者的数量。</li>
<li>写入数据需要互斥锁。</li>
<li>之后的读者需要阻塞，需要互斥锁。</li>
<li>新来的写者可能要「插队」，需要记录写者数量。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> writeCount = <span class="number">0</span>, readCount = <span class="number">0</span>;</span><br><span class="line">semaphore wMutex=<span class="number">1</span>, rmutex=<span class="number">1</span>, writeCountMutex=<span class="number">1</span>, readCountMutex=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> reader() {</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        P(rMutex); <span class="comment">//被阻塞则不能进行任何操作</span></span><br><span class="line">        P(readCountMutex);</span><br><span class="line">        readCount++;</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">1</span>) P(wMutex); <span class="comment">// 等待之前的读者完成</span></span><br><span class="line">        V(readCountMutex);</span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        P(readCountMutex);</span><br><span class="line">        readCount--;</span><br><span class="line">        <span class="keyword">if</span>(readCount == <span class="number">0</span>) V(wMutex); <span class="comment">//之前的读者完毕</span></span><br><span class="line">        V(readCountMutex);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span>{</span><br><span class="line">	<span class="keyword">while</span> ( <span class="number">1</span> ){</span><br><span class="line">		P(writeCountMutex); <span class="comment">//为了保证自增和判断的原子性</span></span><br><span class="line">		writecount++;</span><br><span class="line">		<span class="keyword">if</span> (writecount == <span class="number">1</span>) P(rMutex); <span class="comment">//写入时阻塞读取</span></span><br><span class="line">		V(writeCountMutex);</span><br><span class="line">		P(wMutex);</span><br><span class="line">		<span class="comment">//写入</span></span><br><span class="line">		V(wMutex);</span><br><span class="line">		P(writeCountMutex);</span><br><span class="line">		writecount--;</span><br><span class="line">		<span class="keyword">if</span> (writecount == <span class="number">0</span>) V(rMutex);</span><br><span class="line">		V(writeCountMutex);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>公平读写</strong>则按照先来后到的顺序，处理读者和写者。那么</p>
<ol>
<li>读者读取时不能有写者。需要互斥。</li>
<li>新进程到达时，都应该阻塞。</li>
<li>写者之前的读者，应该全部完成，写者才能开始。</li>
<li>写者之间应该互斥。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">semaphore wrMutex = <span class="number">1</span>, wMutex = <span class="number">1</span>, readCountMutex = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> reader(){</span><br><span class="line">    P(wrMutex); <span class="comment">//读者和写者串行，但是读者之间并发</span></span><br><span class="line">    P(readCountMutex);</span><br><span class="line">    readCount++;</span><br><span class="line">    <span class="keyword">if</span>(readCount == <span class="number">1</span>) P(wMutex); <span class="comment">// 读取时加写锁</span></span><br><span class="line">    V(readCountMutex);</span><br><span class="line">    V(wrMutex); <span class="comment">//在这里解开读写锁很有讲究，读者可以并发读取</span></span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    P(readCountMutex);</span><br><span class="line">    readCount--;</span><br><span class="line">    <span class="keyword">if</span>(readCount == <span class="number">0</span>) V(wMutex)<span class="comment">//解开写锁</span></span><br><span class="line">    V(readCountMutex);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wirter</span><span class="params">()</span>{</span><br><span class="line">    P(wrMutex); <span class="comment">//读者和写者串行</span></span><br><span class="line">    p(wMutex);</span><br><span class="line">    <span class="comment">// 写入</span></span><br><span class="line">    V(wMutex);</span><br><span class="line">    V(wrMutex);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>例题 1：</p>
<p>有一座东西方向的独木桥，桥很窄只能单向通行，而且承载能力有限，最多 4 个人同时在桥上。当某一方向有行人过桥时，另一方向行人必须等待。东、西两端各有若干行人在等待过桥。请用 P、V 操作来实现东西两端行人过桥问题。</p>
<p>这是需要公平地过桥，两边地人互斥而且各自可以并发。每一边需要等另外一边的人通过才能开始。考虑进程之间的通信，需要的信息如下</p>
<ol>
<li>东西两个方向，需要互斥锁，只能走一个方向。</li>
<li>东西两个方向都需要自己的数量锁，防止并发造成 count 修改和读取不一致。</li>
<li>东西两个方向需要表示自己的数量。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> countA = <span class="number">0</span>, countB = <span class="number">0</span></span><br><span class="line">semaphore lockCountA = <span class="number">1</span>, lockCountB = <span class="number">1</span>, mutex = <span class="number">1</span>, count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eastToWest</span><span class="params">()</span>{</span><br><span class="line">    P(lockCountA);</span><br><span class="line">    countA++;</span><br><span class="line">    <span class="keyword">if</span>(countA==<span class="number">1</span>) P(mutex);</span><br><span class="line">    V(lockCountA);</span><br><span class="line">    P(count);</span><br><span class="line">    <span class="comment">//过桥</span></span><br><span class="line">    V(count);</span><br><span class="line">    P(lockCountA);</span><br><span class="line">    countA--;</span><br><span class="line">    <span class="keyword">if</span>(countA==<span class="number">0</span>) V(mutex);</span><br><span class="line">    V(lockCountA);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">westToEast</span><span class="params">()</span>{</span><br><span class="line">    P(lockCountB);</span><br><span class="line">    countB++;</span><br><span class="line">    <span class="keyword">if</span> (countB==<span class="number">1</span>) P(mutex);</span><br><span class="line">    V(lockCountB);</span><br><span class="line">    P(count);</span><br><span class="line">    <span class="comment">//过桥</span></span><br><span class="line">    V(count);</span><br><span class="line">    P(lockCountB);</span><br><span class="line">    countB--;</span><br><span class="line">    <span class="keyword">if</span> (countB==<span class="number">0</span>) V(mutex);</span><br><span class="line">    V(mutexB);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>经验：</strong></p>
<ol>
<li>想象进程时独立个体，同类进程之间、不同类别进程之间合作需要哪些信息。</li>
<li>宁愿多一些信号量，尽量避免少量信号量组合使用，这样尽管精妙，但是不容易写和理解。</li>
<li>以上的例子都是可以拓展的，进程之间通过信号量同步，进程内部可以用更小的协程等同步，然后把每个小部分都视作对象，就构建并发的高性能程序了。</li>
</ol>
<h4 id="管程">管程</h4>
<p>管程是一个程序设计语言结构，采用了<strong>集中式</strong>的进程同步方法，提供了与信号量同样的功能，但更易于控制。这里强调「集中式」，是因为信号量的操作<strong>分散</strong>在各个进程种，代码维护和心智负担都比较大。</p>
<p>管程定义了数据通信的数据结构和并发控制的操作（比如阻塞、接触阻塞、队列长度控制），并且<strong>局部的数据只能被管程访问</strong>，这样完成通信数据和局部数据的区分。同一时刻，<strong>只能有一个进程再管程中执行</strong>，其他调用管程的进程都会被阻塞，直到这个进程阻塞或者退出。这样实现了临界资源的互斥访问。</p>
<p>管程需要<strong>条件变量</strong>实现队进程的管理，因为管程中只能由一个进程执行，如果进程到达顺序不对，那么就不满足条件变量，进程就会阻塞。这时管程的调用权就交给了其他进程，直到另外的进程满足了条件变量，才能顺利执行。<strong>管程中的条件变量是同步的</strong>，因此由于其他进程修改了条件变量，这样被阻塞的进程也可以解除阻塞继续执行。这样，就完成了进程之间的同步。</p>
<p>管程中最常见的操作就是阻塞和解除阻塞：</p>
<ul>
<li>cwait©：调用进程的执行在条件 c 上阻塞，管程可供其它进程使用。</li>
<li>csignal©：恢复在条件 c 上阻塞的一个进程，若不存在阻塞进程，则什么都不做。</li>
</ul>
<h4 id="消息传递">消息传递</h4>
<p>我们之前都是直接默认了信号量在不同进程中是同步的，用来实现互斥或者同步。这样传递消息的方式，具有一些规律和模式。这一小节我们就是学习消息传递的基本原理。</p>
<p>消息传递由两条基本原语（原语是指<strong>由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断</strong>）：发送和接收。简单的说就是来自谁、发给谁，还有一些控制信息等。</p>
<img src="http://cdn.blog-blockchain.xyz/202302051646948.png" alt="image-20230205164621777" style="zoom:67%;">
<p>上图的消息的数据结构中可以看到一些参数，特别是源 ID 和发送 ID，它们的确定的方式，在不同场景下也不同。<strong>直接寻址</strong>时直接包含目标程序 ID，接收报文时根据需要选择是否要指明源程序 ID。<strong>间接寻址</strong>时消息会发送到公共的队列，然后接收的进程从公共队列中取走消息。</p>
<p>对于发送消息的进程，在发送消息之后可能阻塞，也可能不阻塞，继续执行。对于接收消息的进程，可能必须等待消息到达才能解除阻塞，也可能不接收消息直接执行。总的来说，有以下 3 种模式：</p>
<ol>
<li><strong>阻塞发送，阻塞接收</strong> 。发送者和接受者都阻塞，直到完成消息投递。一般需要进程紧密地同步时，比如流水线调度，会采用这种模式。</li>
<li>**不阻塞发送，阻塞接收 **。发送者不阻塞，但是接收者阻塞直到请求的消息到达。这是最常见的请求的模式。</li>
<li>**不阻塞发送，不阻塞接收 **。这就是各自执行各自的。</li>
</ol>
<h3 id="死锁">死锁</h3>
<p>进程同步的小节已经介绍过死锁了，当一组进程中的每个进程都在等待某事件，而只有同组进程中阻塞的其他进程能够促发该事件时，死锁发生。比如进程之间循环等待，或者内存不足，各自执行一般后阻塞。</p>
<p>严格的说，死锁的发送必须具备一些条件。必要条件：</p>
<ul>
<li>互斥。存在资源是临界资源，一次只有一个进程可以使用这个资源。</li>
<li>占用等待。当进程等待其他资源时，继续占有已经分配的资源。</li>
<li>不可抢占。不能强行抢占进程已经占有的资源。</li>
</ul>
<p>这些都是容易理解的，必须要存在临界资源才会造成等待，等待的时候如果释放资源或者资源被抢占，也是无法发生死锁的。有个充分条件则是<strong>循环等待</strong>：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。</p>
<h4 id="死锁预防">死锁预防</h4>
<p>死锁预防是指<strong>通过不满足上述三个条件</strong>防止死锁的发生。死锁的避免是指<strong>允许上述三个条件，但是通过设计不发生死锁</strong>。</p>
<p>互斥这个条件无法禁止，因为有些资源只能被独占。占用等待则可以<strong>要求进程一次性请求所有资源，并阻塞这个进程直到所有资源请求能够满足</strong>。但是，得到所有资源才开始执行，效率很低，而且某些进程执行时不知道需要哪些资源。</p>
<p>为了改善不可抢占的条件，就可以要求<strong>一个占有某些资源的进程进一步申请资源时若被拒绝，则释放最初占有的资源，或者要求占用自己需要的资源的进程释放资源给自己用</strong>。但是资源的状态如果不容易保存的话，会造成其他的程序中断，可能不得不重新执行被中断的进程。</p>
<p>从防止循环等待的角度说，可以把资源排序，申请资源的进程，必须先按照资源的序号申请，比如申请了 5 号资源就不能回过头申请 4 号资源。这样就避免了资源的冲突，但是显然申请资源的顺序可能和进程需要请求的资源的顺序不一样，这样需要额外的处理，效率较低。</p>
<h4 id="死锁避免">死锁避免</h4>
<p>死锁的避免是指<strong>允许上述三个条件，但是通过设计不发生死锁</strong>。一般有两种办法：</p>
<ol>
<li>资源分配拒绝。若一个进程增加的资源请求会导致死锁，则不允许这一资源分配。</li>
<li>进程启动拒绝。若一个进程请求会导致死锁，则不启动该进程</li>
</ol>
<p>简单的说，就是动态地检测，避免资源竞争地发生。比较典型的算法是<strong>银行家算法</strong>，它的基本思想是当进程申请资源时，必须保证分配出去之后，系统还是处于<strong>安全状态</strong>。否则就不分配，阻塞这个申请资源的进程。这里的「安全状态」指至少有一个资源分配的序列（表示进程申请资源顺序）不会导致死锁，能够让所有进程运行结束。<strong>安全状态一定不会发生死锁，不安全的状态不一定会发生死锁</strong>。</p>
<p>银行家算法需要使用到如下的数据结构：</p>
<ul>
<li>声明需要资源的矩阵（C 矩阵）。表示每个进程需要每种类型的资源的数量。</li>
<li>分配矩阵（A 矩阵）。表示当前每个进程分配到的资源的数量。</li>
<li>C-A 矩阵。表示每个进程还需要的资源的数量。</li>
<li>资源向量。表示当前系统拥有的每类资源的数量。</li>
<li>可用资源向量。表示当前还可以分配的每类资源的数量。</li>
</ul>
<img src="http://cdn.blog-blockchain.xyz/202302062013948.png" alt="image-20230206201304855" style="zoom: 80%;">
<p>根据逻辑和上述原理，可以发现分配矩阵中每类资源的和就是已经分配出去的资源数量，相当于资源向量减可用资源向量。图上的所有信息，就是初始的系统状态。</p>
<p>每次更新时，<strong>可用资源向量（的每个元素）必须大于 C-A 矩阵中的某个进程</strong>，这样才能让一个进程获得所需的所有资源。但是可能出现有多个满足条件的进程，这就像一棵树一样，有多条路径。就是通过这样类似深度优先搜索的方法，找到一条可以遍历每个进程一次的路径。例如上图只有 P2 满足条件，当 P2 运行结束后，状态如下图。</p>
<p>记住需要更新分配矩阵、C-A 矩阵、可用资源向量。需求矩阵对应进程需要的资源设置为 0。</p>
<img src="http://cdn.blog-blockchain.xyz/202302062024843.png" alt="image-20230206202446750" style="zoom:80%;">
<p>可以知道都可以分配了，不妨选择 P1，P1 运行结束后如下</p>
<img src="http://cdn.blog-blockchain.xyz/202302062028648.png" alt="image-20230206202847552" style="zoom:80%;">
<p>之后的选择完全是类似的，P2, P1, P3, P4 这个顺序是安全的，其他的顺序，比如 P2, P1, P4, P3 也是安全的。需要注意的是，如果进程并不一次性分配的需要所有资源，这也是可以的，但是需要满足分配之后，存在一个进程可以分配得到所有它需要的资源。比如，下图中，如果给 P1 分配了(1, 0, 1)的资源，那么后续就无法分配了，没有一个进程可以执行结束，这是不允许的，会拒绝分配。</p>
<img src="http://cdn.blog-blockchain.xyz/202302062107629.png" alt="image-20230206210720509" style="zoom:80%;">
<p>根据上面的例子可以发现，死锁避免采用的银行家算法，并没有改变三个必要条件中的要求，而是通过策略控制资源分配给进程的多少和顺序，从而达到死锁避免。这样做的限制更少，而且更加灵活。但是，这需要每个进程需要在执行前声明自己需要的所有资源有哪些，而且进程之间是独立的，不能有执行顺序的要求。特别是频繁的检测会消耗处理器很多的时间。</p>
<p>如果发现不存在安全的路径，通常有三种办法：</p>
<ul>
<li>撤销进程。撤销被永久阻塞的进程，直到不发生死锁。</li>
<li>回退。把进程的状态回滚到之前的检查点，从检查的开始重新执行。</li>
<li>抢占。通过抢占资源，来保证某个进程能顺利执行。</li>
</ul>
<h4 id="哲学家就餐问题">哲学家就餐问题</h4>
<p>哲学家就餐问题是经典的死锁问题。场景如下 5 把叉子，五份食物，每个人必须要两把叉子才能进食。显然，如果每个人都拿起了一把叉子，就每个人都没办法进食。直观的想法是，如果一个人拿不到左边或者右边的叉子，那么就把手上的另一个叉子也放下，让其他人使用。但是，没有规则的互相谦让，可能让每个人都无法进食，形成活锁。</p>
<img src="http://cdn.blog-blockchain.xyz/202302062120273.png" alt="image-20230206212059064" style="zoom: 50%;">
<p>所以我们需要给资源建立偏序关系，让资源按照一定的顺序申请和释放。</p>
<p>方案一：就餐前，先取用编号较低的餐叉，再取用编号较高的餐叉。这样就会有同一个叉子被两个人竞争，导致至少一个人由于竞争失败，不去取另外一个叉子。这样就可以保证有一个人能拿到两把叉子。</p>
<p>方案二：奇数号的哲学家必须首先拿左边的餐叉，偶数号的哲学家必须首先拿右边的餐叉。同样的道理。</p>
<p>方案三：最多允许四个人同时进食，这样至少一个人会拿到两把叉子。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore fork[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>}, room = <span class="number">4</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">        cobegin {philosopher(<span class="number">0</span>); philosopher(<span class="number">1</span>); philosopher(<span class="number">2</span>); philosopher(<span class="number">3</span>); philosopher(<span class="number">4</span>);}coend;</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        wait(room);                             <span class="comment">//占据就餐位置</span></span><br><span class="line">        wait(fork[i]);                           <span class="comment">//拿起左边的叉子</span></span><br><span class="line">        wait(fork[(i+<span class="number">1</span>)%<span class="number">5</span>]);               <span class="comment">//拿起右边的叉子</span></span><br><span class="line">        eat();</span><br><span class="line">        signal(fork[(i+<span class="number">1</span>)%<span class="number">5</span>]);            <span class="comment">//放回右边的叉子</span></span><br><span class="line">        signal(fork[(i]);                        <span class="comment">//放回左边的叉子</span></span><br><span class="line">        signal(room);                          <span class="comment">//释放就餐位置</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>哲学家就餐问题，实际上代表着对每一个进程，临界资源要么全部分配到位或者一个资源都不分配。</p>
<h2 id="基本内存管理">基本内存管理</h2>
<p>这一部分的前提是，要求默认读者清楚计算机存储的基本结构。对于存档的存储，是不能直接访问的。ROM 这些是可以作为永久性记忆的，可以用来存储。对于快速的临时存储，按照 CPU 读取的亲近关系，可以分成寄存器、Cache、主存（内存）。它们的速度是从金字塔顶端下降的，但是容量是逐渐上升。</p>
<img src="http://cdn.blog-blockchain.xyz/202302062318849.png" alt="image-20230206231848772" style="zoom: 80%;">
<h3 id="内存管理的关注点">内存管理的关注点</h3>
<p>内存管理需要关注<strong>重定位</strong>、<strong>保护</strong>、<strong>共享</strong>、<strong>逻辑组织方式</strong>、<strong>物理组织方式</strong>。</p>
<p>重定位是指编程时程序员设置的内存位置和实际程序运行的位置的映射，程序员不知道系统可能在哪些位置有哪些程序，所以就需要重定位技术，让程序按照内存空闲情况，重新定位到内存中不同的位置。重定位的方式，其实就是地址转化的方式，也会影响进程寻址的方式。</p>
<p>保护是指进程以外的其他进程中的程序不能未经授权地访问（进行读操作或写操作）该进程的内存单元。这是非常重要的技术，如果黑客可以访问并修改 root 用户所在的内存，刻意修改内存，可能会造成严重后果。所以，windows 也推出了让内存中程序的位置不可预测的功能。</p>
<p>共享是指多个进程可以执行同一个程序，多个进程拥有同一个副本，通过共享可以大大节省内存。</p>
<p>逻辑组织方式是应用程序访问内存时，看到的内存的组织方式。属于软件层面的支持。</p>
<p>物理组织方式是硬件层面的编码方式，它和逻辑组织方式之间的转化由操作系统完成，而不是由程序员完成。最典型的就是虚拟内存和物理内存之间的映射方式。</p>
<p>高级语言需要转化成实际的可以运行的程序，一般需要对单个文件的源代码进行编译，然后链接编译后的单个模块和库函数等形成一个完整程序。之后才能装入内存，程序直接包含了静态库，但是动态库需要在程序装入时跟着装入。</p>
<img src="http://cdn.blog-blockchain.xyz/202302062323258.png" alt="image-20230206232353031" style="zoom: 50%;">
<p>在装入主存的过程中，程序内的地址将会发生重定位，将逻辑地址转化成内存中的物理地址。</p>
<h3 id="加载过程">加载过程</h3>
<p>装入主存的过程，根据逻辑地址和物理地址的映射关系，可以分成：绝对加载方式、静态重定位方式、动态重定位（运行时）方式。</p>
<p><strong>绝对加载方式</strong>逻辑地址和物理地址完全相同，<strong>编译时就确定了</strong>程序将运行在内存中的具体的位置，在程序内可能用一些符号地址代替地址的编号，编译时就会转化成绝对地址。非常显然的是，内存中程序的安排必须是完全确定的，也就是这样的系统是专用的。其次，多处理器系统在运行这个程序产生的多个进程时，可能会造成存储位置冲突。</p>
<p><strong>静态重定位</strong>编译时采用相对地址的方式，编译器假设加载是从 0 地址开始的，<strong>加载时</strong>程序代码内的所有地址拥有相同的偏移量，运行之后地址不能改变。由于运行后地址固定，不方便重新分配内存，导致内存空余的间隙不能充分利用。·</p>
<p><strong>动态重定位</strong>的地址转换过程发生在<strong>运行时</strong>，为了不影响运行速度，一般使用硬件支持。这样程序不必连续的存放在内存中，而且可以共享某一段内存，这也是现代计算机的主流方式。缺点也显然，就是更加复杂，地址转化的计算也更复杂。</p>
<h3 id="链接过程">链接过程</h3>
<p><strong>静态链接</strong>在<strong>程序运行之前</strong>，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块。静态链接时需要考虑各个模块的地址的统一、外部引用地址的统一。显然，这样编译出来的程序会很大，因为需要的东西都塞进去了，也不方便对每个模块升级，而且链接的库函数在实际执行中，可能不会全部同时用到。但是，这样做也避免了一些环境依赖。</p>
<p><strong>加载时动态链接</strong>待加载的模块在加载内存时，如果该模块中有到外部模块的引用，加载程序将查找这些模块并加载内存，并把这些引用修改为相对应用程序模块开始处的相对地址。各个模块相对独立，可以升级，不同程序也可以共享库函数。但是，<strong>加载确定之后，模块是不能变动的</strong>。</p>
<p><strong>运行时动态链接</strong>在程序执行中需要某目标模块时，由操作系统去找到该模块并将之加载内存，随后把它链接到调用者模块上。这是很主流的方式，比如 windows 的 ddl 文件就是一些用于加载时动态链接的库函数。模块就是动态的可拆卸的，可以加快加载过程，也可以节省内存空间。</p>
<h3 id="内存分区">内存分区</h3>
<p>使用过的内存分区技术如下，从开始的简单分区，到后来的分页分段和虚拟内存方案，体现了技术进步的过程。我们在这节只介绍前面两种，段和页将在虚拟内存管理中学习。</p>
<table>
<thead>
<tr>
<th><strong>内存管理技术</strong></th>
<th><strong>使用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>固定分区</td>
<td>IBM MFT</td>
</tr>
<tr>
<td>动态分区</td>
<td>IBM MVT</td>
</tr>
<tr>
<td>简单分页</td>
<td>没有使用，但为虚存分页的基础</td>
</tr>
<tr>
<td>简单分段</td>
<td>没有使用，但为虚存分段的基础</td>
</tr>
<tr>
<td>虚存分页</td>
<td>现代操作系统广泛实际使用</td>
</tr>
<tr>
<td>虚存分段</td>
<td>现代操作系统广泛实际使用</td>
</tr>
</tbody>
</table>
<p><strong>固定分区</strong>的分区数量固定，操作系统占据内存的固定部分，其他每个分区装入一个进程。分区的大小肯能相等也可能不相等。如果分区大小相等，那么程序可能无法恰好占满分区，导致内存中有很对碎片，浪费空间。分区大小不等，则需要一定的算法进行分配。</p>
<p><strong>动态分区</strong>的分区大小和数量都不固定，可以按照进程的需求分配内存空间。但是由于进程在内存中的分配和取消分配，也会产生大量内存碎片，例如下图进程 2 退出后的空隙就无法被填满。因此，提出了压缩技术，通过移动进程，使得进程占用的空间连续。但是这样也浪费了处理器的时间。</p>
<img src="http://cdn.blog-blockchain.xyz/202302081426305.png" alt="image-20230208142649104" style="zoom:50%;">
<p>简要介绍动态分区的算法：</p>
<ol>
<li>首次匹配。从头开始扫描内存，选择大小足够的第一个可用块。</li>
<li>下次匹配。从上一次放置的位置开始扫描内存，选择下一个大小足够的可用块。</li>
<li>最佳匹配。选择空间大小与需求最接近的空闲块分配。</li>
<li>最差匹配。选择满足需求的最大的空闲分区分配。</li>
</ol>
<p><strong>伙伴系统</strong>是固定分区和动态分区的折中方案。简单的说，分区的大小既不是精确按进程的需要决定，也不是按照预先确定的固定方式决定，而是按照 2 的幂次分配空间，找到满足进程需要的最小的 2 的幂次的空间。</p>
<img src="http://cdn.blog-blockchain.xyz/202302091312364.png" alt="image-20230209131214246" style="zoom: 50%;">
<h3 id="分页">分页</h3>
<p>（这一小节，如果完全没有接触过虚拟内存，可能需要较长时间理解）</p>
<p>页是进程中的块，页框是内存中的块。因此，进程和内存都分成了大小相等的块，便于映射和寻址。页和页框之间的映射，就可以在逻辑上进程的内存空间连续，物理存储上可以分开。这样就非常灵活，也避免了内存的小碎片的产生，实现了内存的离散分配。</p>
<p>页和页框的对应关系，由页表储存着，处理器会访问页表，用硬件的方式将页表项中的逻辑地址，转换成物理地址。页表项的基本结构如下图，页号表示第几个页，业内偏移量则是在一个页内的地址偏移量，这样就可以定位到某一个字节。</p>
<img src="http://cdn.blog-blockchain.xyz/202302091327454.png" alt="image-20230209132730396" style="zoom:50%;">
<p>逻辑地址到物理地址的转换过程非常的直接，偏移量部分不变，逻辑地址会根据页表查找到页框号。这样页框号和偏移量拼接起来，就是物理地址了。</p>
<img src="http://cdn.blog-blockchain.xyz/202302091340315.png" alt="image-20230209134002233" style="zoom:50%;">
<p>页表储存在内存中，进程管理块（PCB）记录着页表的起始地址，页表寄存器存放当前运行进程的页表的起始地址。我们看一个示例，内存容量共 256K，存储块的大小为 1K，那么就有 256 个页框。第 0 ～ 4 块为操作系统所使用。现有 2 个用户作业，作业 1 和作业 2，其逻辑地址空间分别占 2k 和 2.5k。那么就分别需要 2 页和 3 页。那么一种可能的内存布局方式，就如下图所示。进程左边的数字表示地址，页表中存在页号到页框号的对应。</p>
<img src="http://cdn.blog-blockchain.xyz/202302091344951.png" alt="image-20230209134444852" style="zoom:50%;">
<p>对于虚拟地址 09C4H（注意末尾的 H 表示十六进制），二进制为 0000 1001 1100 0100B（末尾 B 表示二进制）。注意虚拟地址的页的数量不一定等于页框的数量，一般是会大于，也有可能小于。所以虚拟地址页号占几位一般是通过偏移量和机器字长计算的。假设这是 16 位的机器，那么低 10 位是偏移量（对应页的大小），29C4H，高 6 位 2H 是页号，对应页框号 10，所以物理地址为 18 位 00 0010 1001 1100 0100.</p>
<h3 id="分段">分段</h3>
<p>一个程序可以分成大小不等的几个段，每个段都从 0 开始编址，并占用一段连续的地址空间。逻辑地址则由两部分构成，段号+段内偏移量。<strong>分段可以被程序员控制，但是分页不行</strong>，这样可以让程序运行时实现模块化。分段也可以避免内存的内部碎片，段之间可以动态连接。</p>
<img src="http://cdn.blog-blockchain.xyz/202302091542808.png" alt="image-20230209154241749" style="zoom:50%;">
<p>因为段的大小不等，所以逻辑地址和物理地址之间的对应关系比较复杂，但是寻址过程和分页是完全相同的。</p>
<p>分页存储管理系统不易实现「共享」，不支持「运行时动态链接」，而分段系统易于实现「共享」和「动态链接」。</p>
<h2 id="虚拟内存管理">虚拟内存管理</h2>
<p>虚拟内存最主流的就是分段和分页，他们都需要硬件支持，而且操作系统必须实现管理页和段的软件算法。虚拟内存是指外存（比如机械硬盘、固态硬盘）可以看作是内存的一部分来寻址，这样实现了对内存的拓展。</p>
<p>需要注意，分段和分页<strong>不需要一个程序的所有页或者段都在内存中</strong>，只需要加载正在运行的部分即可，这也是非常重要的节省内存空间的方法。<strong>分段或分页式的进程执行过程</strong>：进程在执行过程中，会从程序的入口加载若干块进入内存，当前驻留在内存中的部分叫做<strong>驻留集</strong>。如果逻辑地址对应的物理地址上的内容标记为失效，那么就会产生中断，进程进入阻塞阶段。接着，操作系统就会生成磁盘 IO 请求，在这个过程中，会调度其他进程执行，当磁盘 IO 完成之后，内存上就有了需要的资源，被阻塞的进程进入就绪状态。</p>
<p>按照上面的执行过程，可以发现找到尽可能的减少缺页的发生的方法，是非常重要的。如果外存加载进内存和释放的过程太频繁，就会造成抖动，大量缺页。经典的办法是利用<strong>局部性原理</strong>，短时间内程序在外存中的存储一般是连续的，也就是说具备集簇倾向。那么从外存加载数据时，就可以预测下一个需要的数据，在已经加载的数据的附近。</p>
<p>基于虚拟内存技术，内存可以实现拓展，运行更多的进程，调度效率高。分段分页即使可以实现运行时按需调配资源，可以提高内存利用效率。</p>
<img src="http://cdn.blog-blockchain.xyz/202302091628402.png" style="zoom: 50%;">
<h3 id="分页细节">分页细节</h3>
<p>之前介绍的分页，只是提到页表中逻辑地址到物理地址的对应关系，而实际的使用中还存在一些常用的优化技术。例如增加控制位，存在位 P 表示对应的页是否在内存中，M 表示距离上次装入内存中的页框的内容是否修改过。</p>
<img src="http://cdn.blog-blockchain.xyz/202302091655430.png" alt="image-20230209165541374" style="zoom:50%;">
<p>由于虚拟内存可以非常大，远大于内存，所以页表也可能很大，因此<strong>页表会存储在虚拟内存中</strong>。比如一个虚拟空间 32GB，每个页大小 1KB，那么需要 2^(35 - 10)=2^25 的页表项，非常大。</p>
<p>页表大了起来，检索速度也会变慢，因此提出了多级页表的方式，加快速度。以两级页表为例，第一层页表的每一项，指向第二层的一个页表。其中第一层页表又被叫做页目录。<strong>总共的页表项的数量是每一层级页表项数量的乘积</strong>。如下图，假设每个页表项为 4 字节，页大小 4KB，那么 4GB 的虚拟地址空间（也叫做用户地址空间）就需要 2^20 的页表项，需要 4MB 的页表。为了加快检索，而不用遍历那么多页表项去寻找匹配的虚拟地址，就采用了根页表，同时页表可以存放在虚拟内存中。</p>
<img src="http://cdn.blog-blockchain.xyz/202302101341523.png" alt="image-20230210134104435" style="zoom:50%;">
<p>根页表的每一项的数据结构和普通页表类似，也是通过根页表的编号（也被称作页目录号）找到对应的页号（比如上图 4MB 的页表）,然后根据偏移地址确定具体对应页框号的页表项。</p>
<img src="http://cdn.blog-blockchain.xyz/202302101347397.png" alt="image-20230210134758343" style="zoom:50%;">
<p>如果从虚拟地址的角度出发，那么就可以将虚拟地址分成 3 部分，第一个部分是根页表的项的编号，第二部分是第二级页表项的编号，第三部分是虚拟地址。同时第二部分也是根页表中的页内偏移量。也就是，单层页表的页表编号被拆分成两部分了。</p>
<img src="http://cdn.blog-blockchain.xyz/202302101351608.png" alt="image-20230210135159504" style="zoom:50%;">
<p>另外一种优化技术是<strong>倒置页表</strong>，之前提到每个进程需要分配一个页表，所有进程的 PCB 记录着页表的起始地址。当进程很多时，多个页表也会占据大量内存空间。因此，通过虚拟地址寻找物理地址的数据的方式做了一些更改，首先计算 <code>HASH(逻辑页号+进程ID)</code>，然后在哈希表中通过链接指针找到（类似链表的方式）找到对应的一项，然后在这一项中获得页框号。这个哈希表就叫做倒置页表。</p>
<img src="http://cdn.blog-blockchain.xyz/202302101414269.png" alt="image-20230210141445156" style="zoom: 50%;">
<h3 id="TLB-快表">TLB 快表</h3>
<p>之前的介绍中，通过页表查询的方式，往往需要两个步骤，首先是根据逻辑页号读取虚拟内存中的页表项，然后通过页表项中的物理页框号读取内存中的数据。实际上，我们可以通过高速缓存的方式提高速度。快表转换过程如下：一个虚拟地址寻找物理地址时，首先检查 TLB 中是否有页表项，如果有则直接得到物理页框号。如果没有，那么需要寻找到这个进程所在的页表，然后找到页表中的页表项，得到物理页框号，最后更新 TLB。</p>
<img src="http://cdn.blog-blockchain.xyz/202302101437066.png" alt="image-20230210143708957" style="zoom:50%;">
<p>因此，完整的虚拟地址到物理地址的转过过程如下图</p>
<img src="http://cdn.blog-blockchain.xyz/202302101439668.png" alt="image-20230210143904578" style="zoom: 67%;">
<p>虽然 TLB 速度很快，但是空间有限。究竟哪些页表项需要放入 cache，页表项和 cache 的对应关系、更新方式等，都已经在计算机组成原理中学习过了。由于计算机操作系统的课程考核不要求这一部分，全相联、组相联这些内容暂时跳过。读者感兴趣的话，可以评论，日后我继续补充。</p>
<h3 id="分段和段页式">分段和段页式</h3>
<p>类似于分页，每个进程一个段表，段表项也有存在位（对于段是否存在内存）、修改位（上次装入后是否修改）、其他控制位、段长度、段基址。和分页不同德是，物理地址的确定是段基址加上偏移量。分段的机制每个段都有长度和基址，那么限制只能访问当前段的内存，就可以控制非法访问，实现<strong>保护</strong>。一个段可以被多个进程引用，实现<strong>共享</strong>。</p>
<img src="http://cdn.blog-blockchain.xyz/202302101451137.png" alt="image-20230210145129046" style="zoom:50%;">
<p><strong>段页式</strong>的方式是分段和分页的结合，虚拟地址空间（也叫做用户地址空间）被程序员分成若干段，每段划分成若干页。每个进程一个段表、每个段一个页表。段表项包含了段长和页表起始地址等信息，页表项则包含了页框号等信息。</p>
<img src="http://cdn.blog-blockchain.xyz/202302101458517.png" alt="image-20230210145859451" style="zoom: 50%;">
<p>具体寻址过程如下，需要注意的就是段号寻找段表项，页号寻找页表项，都是需要加法。可以看到，访问段表、访问页表、读取内存数据，至少需要访问 3 次内存。</p>
<img src="http://cdn.blog-blockchain.xyz/202302101501072.png" alt="image-20230210150142996" style="zoom: 50%;">
<h3 id="系统的存储管理">系统的存储管理</h3>
<p>为了实现虚拟内存，操作系统需要实现读取策略（如何调入页）、放置策略（放在内存的哪个位置）、置换策略（把不需要的数据从内存置换出去）、驻留集管理（需要加载进程的哪些资源）等等。</p>
<p><strong>读取策略</strong>主要关注请求调页和预调页。请求调页是指如何将需要的页面调入内存，避免缺页的发生和如何处理缺页。预调页是额外读取页面，相当于做好缓存，但是需要确定命中。如果额外读取的页面未使用，则低效。</p>
<p><strong>放置策略</strong>是确定进程驻留在内存中的哪个位置，比如分区系统中的首次匹配、下次匹配等算法，就是属于这一类策略。</p>
<p><strong>置换策略</strong>是读取新页时，选择淘汰哪些页面。置换做的好，把最不可能访问的页面淘汰，可以合理分配内存。锁定一些页框不淘汰，也可以降低缺页率。基本的置换算法如下：</p>
<ol>
<li>
<p>最佳置换。置换下次访问距当前时间最长的页面。但是这很理想化，因为可能不知道所有页面未来读取的时间，除非已经知道未来页面的访问顺序了。</p>
</li>
<li>
<p>最近最少使用。置换最长时间未引用的页面。这就需要给页面增加最近访问的时间戳，开销大。</p>
</li>
<li>
<p>先进先出。采取严格的单向队列，按照循环的方式，删除最先进来的页面，也就是驻留在内存中时间最长的页面。问题明显，驻留时间最长，不代表不需要。</p>
</li>
<li>
<p>时钟置换。本质上是淘汰最近没有使用的页。规则如下：</p>
<ul>
<li>
<p>当页面载入或者再次读取时，页面的使用位设置为 1。未使用的缓冲区，使用未设位 0.</p>
<img src="http://cdn.blog-blockchain.xyz/202302102323639.png">
</li>
<li>
<p>当访问的页面不存在时，就会从指针的位置开始旋转，如果当前指针指向的页面的使用位为 1，那么就置为 0，继续到下一个位置。如果当前指向的页面使用位为 0，那么就就装入。</p>
<p><img src="http://cdn.blog-blockchain.xyz/202302102334642.png" alt="图片.png"></p>
</li>
<li>
<p>当命中时，指针位置不变。</p>
</li>
</ul>
</li>
</ol>
<p><strong>驻留集管理</strong>指进程运行过程中哪些页面需要加载进来。这需要确定进程当前活动需要多少个页框，这可以固定分配，也可变分配。当发生缺页时，需要确定置换的范围，是在一个进程的空间中置换，还是允许整个内存的范围内置换。具体细节暂时放下。</p>
<h2 id="IO-管理和磁盘调度">IO 管理和磁盘调度</h2>
<h3 id="IO-控制方式">IO 控制方式</h3>
<p>IO 的基本控制方式有轮询(忙等方式)、中断驱动、DMA、通道控制。</p>
<p><strong>轮询</strong>是通过程序完成的，需要 IO 时会通过 CPU 给 IO 控制器发出命令，然后进程阻塞，CPU 不断轮询控制器的状态，直到就绪之后<strong>经过 CPU 读入内存</strong>。</p>
<img src="http://cdn.blog-blockchain.xyz/202302110001662.png" alt="image-20230211000155595" style="zoom: 67%;">
<p><strong>中断驱动</strong>则智能一些，CPU 发送指令之后，如果是非阻塞的指令，那么继续执行进程，如果是阻塞的指令，则当前进程被换出，调度其他进程。CPU 不用轮询其他进程，而是等待 IO 控制器返回消息后，再执行需要这 IO 的程序。<strong>每次传输一个数据就会发送中断</strong>。</p>
<p><strong>DMA</strong> 这个模块会直接和 IO 控制器通信，CPU 可以去做其他事情，<strong>DMA 直接向存储器读或写数据</strong>，等待 DMA 完成了所有事情，再通知 CPU 处理，这时 CPU 处理的工作切换了，发送中断。</p>
<table>
<thead>
<tr>
<th></th>
<th>中断驱动</th>
<th>DMA</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断频率</td>
<td>每次传输一个数据即产生中断。</td>
<td>一块数据全部传送结束时才中断 CPU。</td>
</tr>
<tr>
<td>数据传输</td>
<td>数据传送在中断处理时由 CPU 控制完成。</td>
<td>数据传送在 DMA 控制器的控制下完成。</td>
</tr>
</tbody>
</table>
<p>可以知道，中断适合小数据快速传输，DMA 适合大数据传输。</p>
<p><strong>通道控制</strong>，某些 IO 设备（如存储器）需要被多用户共用，那么就可能存在多通道，每个通道又由多个控制器管理，每个控制器又连接多个设备。通道控制是 DMA 的升级版本，有自己的 IO 指令集，甚至自己就是微型计算机，并行的操作，读取速度更加快。</p>
<img src="http://cdn.blog-blockchain.xyz/202302110017351.png" alt="image-20230211001757301" style="zoom: 67%;">
<h3 id="IO-缓冲">IO 缓冲</h3>
<p>缓冲是指发出读取请求之前就开始读取数据，发出写入请求一段时间后才开始写入数据。</p>
<ul>
<li>
<p>没有缓冲时，数据单次的到达进程或者从进程送出，那么每次数据传输都需要计算和整个 IO 过程的时间。</p>
</li>
<li>
<p>当采用单缓冲时，进程的多次数据请求时，就可以一边计算一边缓冲，然后整个的传输到进程。这节省了传输时间。</p>
<img src="http://cdn.blog-blockchain.xyz/202302110031185.png" alt="image-20230211003158127" style="zoom:50%;">
</li>
<li>
<p>双缓冲有两个缓冲区，系统使用一个缓冲区传输数据时，就可以填充另外一个缓冲区，这样切换着执行，就几乎感受不到数据存设备读取到内存的时间。多个缓冲区时，原理也是类似的。</p>
<img src="http://cdn.blog-blockchain.xyz/202302110032606.png" alt="image-20230211003250549" style="zoom: 50%;">
</li>
</ul>
<p>缓冲缓解了 IO 设备速度太慢的问题，相比 CPU 的执行速度，IO 设备先攒一波，再传输数据，可以减少 CPU 等待时间和中断数量。</p>
<p>磁盘中的缓冲技术中典型的有<strong>SPOOLing</strong>，它在磁盘中建立 IO 缓冲区，对 IO 设备的输入和从 IO 设备的读取，都在磁盘的这个区域进行。也就是说，在计算机中开辟一块存储位置，用来缓冲 IO，程序实际读取的数据来此这个缓冲区（更具体的是通过输入井和输出井），而缓冲区作为操作系统和 IO 设备之间的中介或者代理。所以 SPOOLing 的全称叫做 Simultaneous Peripheral Operation On-Line，同步同时的外设操作。国内翻译直接叫做假脱机，也是这个意思。</p>
<p>另外，磁盘内部可能也存在缓冲区，在缓存没有用光的情况下，速度会快很多。管理缓冲区的策略有 LRU(Least Recently Used)，它置换出最近最久没有使用的块；也有 LFU (Least Frequently Used)，置换出最近访问次数最少的块。</p>
<h3 id="磁盘的结构和读取过程">磁盘的结构和读取过程</h3>
<p>磁盘存储器的基本结构包括了物理<strong>盘片</strong>，每个磁盘片可能有一个或者两个<strong>存储面</strong>。每个存储面被划分成若干个同心圆，每个圆环就叫做<strong>磁道</strong>。每条圆环状的磁道划分成若干个<strong>扇区</strong>，层叠起来的不同盘片的相同的磁道就叫做<strong>柱面</strong>。</p>
<p>读取和写入数据的是磁头，有的是每个盘面一个磁头，有的则更加高级，一个盘面上多个磁头，对应着盘面上的磁道。磁头有固定读取某个磁道的类型，也有可以移动到指定磁道的类型。磁盘会高速旋转，这样就实现了读取全盘。</p>
<img src="http://cdn.blog-blockchain.xyz/202302111444167.png" alt="image-20230211144437037" style="zoom:50%;">
<img src="http://cdn.blog-blockchain.xyz/202302111450182.png" alt="image-20230211145003125" style="zoom: 80%;">
<p>磁盘的读取过程大致如下：在磁头可移动系统中，将磁头臂移动到指定磁道，磁头定位到指定磁道后，等待磁盘旋转，将待访问的扇区移动到磁头位置，向磁盘传送或从磁盘传送数据的时间，取决于磁盘的旋转速度。</p>
<p>因此磁盘的读取的时间主要有三部分：寻道时间、旋转延迟、传输时间。寻道时间一般是给定的。旋转延迟一般取平均，也就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>r</mi></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>2</mn><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_r=1/(2r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>，其中 r 表示磁盘旋转速度，一般单位是每分钟多少转 rpm。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为传输时间，b 表示要传送的字节数，r 表示旋转速度，N 表示一个磁道中的字节数，那么传输时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub><mo>=</mo><mi>b</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>r</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_t=b/(rN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<p>根据以上的规则，看一个示例：考虑一个典型的磁盘，平均寻道时间为 4ms，转速为 7500r/m，每个磁道有 500 个扇区，每个扇区有 512 个字节。假设有一个文件存放在 2500 个扇区上，估算下列两种情况下读取该文件需要的时间。（1）2500 个扇区分别位于 5 个相邻磁道上，且文件按扇区顺序存放；（2）2500 个扇区随机分布。</p>
<p>（1）转速换算 7500rpm=0.125r/ms，寻道时间 4ms，旋转延迟 1/(2*0.125)=4ms，读取一个扇区的时间 512/(500*512*0.125)=0.016ms。所以连续读取 5 个磁道需要 4ms+4ms*5+0.016ms*2500= 64 ms。<strong>相邻磁道的寻道时间可以忽略</strong></p>
<p>（2）如果随机分布的话，读写的三个过程必须都出现，2500*(4+4+0.016)ms=20040ms</p>
<h3 id="磁盘调度策略">磁盘调度策略</h3>
<p>因为磁头的位置一次只能处理一个请求，如果能够合理调度请求，让上面提到的时间综合起来最短，这就是磁盘调度得目标。</p>
<p><strong>FIFO 先进先出</strong>，根据进程请求访问磁盘的先后顺序，处理访问的需求。但是大量进程竞争磁盘时，性能接近随机调度。</p>
<p><strong>PRI 优先级</strong>，根进程读取磁盘安排优先级。</p>
<p><strong>LIFO 后进先出</strong>优先处理新到的请求。</p>
<p><strong>SSTF 最短寻道时间优先</strong>选择移动到距离前位置最近的磁道。</p>
<p><strong>SCAN 电梯算法</strong>磁头只沿着一个方向移动到尽头，然后再往反方向走。</p>
<p>**C-SCAN (Circular SCAN)**当磁臂沿指定方向扫描到磁盘最后一个磁道时，磁臂返回到反方向末端，再次沿指定方向扫描。记住这是单方向扫描。因为在末端位置的时候，已经扫描过的边缘位置，可能没有必要立即再扫描一遍。</p>
<p><strong>C-LOOK</strong> 在 C-SCAN 基础上改进，当前方向没有其他请求时，直接到另外一个方向最末端的请求，然后重新开始单方向扫描。</p>
<p><strong>FSCAN</strong> 使用两个子队列，扫描开始时，所有请求放在一个队列中，另外一个队列为空。在扫描过程中，新到来的请求放在另外一个队列中，当原来队列里的请求处理完毕之后，才会处理另外一个队列。</p>
<h3 id="RAID">RAID</h3>
<p>独立磁盘冗余阵列（RAID）是将多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。具体来说，操作系统的眼中它是一个单一设备，但是它的整体性使得单一设备失效的时候，可以通过奇偶校验信息恢复数据，数据并不是单纯地存放在物理驱动器中，而是分布在各个硬盘中，实现条带化，进而实现高性能读取和容错。</p>
<p>RAID 分成多个等级</p>
<ul>
<li>
<p>level 0 不提供冗余功能，数据被划分成多个条带，条带映射到物理磁盘中。</p>
<img src="http://cdn.blog-blockchain.xyz/202302120047135.png" alt="image-20230212004707842" style="zoom:67%;">
</li>
<li>
<p>level 1 通过简单映像提供冗余功能，没有校验恢复功能，相当于直接备份。写入无优势，但是读取时会快一些。</p>
<img src="http://cdn.blog-blockchain.xyz/202302120048506.png" alt="image-20230212004824427" style="zoom: 67%;">
</li>
<li>
<p>level 2 实现了并行访问数据，提供了数据的校验。往往条带非常小，通过存储每个条带的汉明码确保数据的完整性。</p>
</li>
<li>
<p>…更多的不细究了。</p>
</li>
</ul>
<h2 id="文件系统">文件系统</h2>
<p>这一节，我们更像是了解文件系统是任何设计的，如果读者可以结合自身对 Windows 和 Linux 文件的经验，那么许多部分将会非常好理解。</p>
<p>文件系统是操作系统的重要组成部分，文件需要以一定的方式组织成特定的结构，然后长期的储存并且被进程访问。文件系统需要提供文件操作的接口，最典型的就是创建、删除、打开、关闭、读写等。文件系统还需要满足数据的管理、权限管理、IO 需求、多用户支持、性能优化等需求。</p>
<img src="http://cdn.blog-blockchain.xyz/202302120113299.png" alt="image-20230212011347222" style="zoom:50%;">
<p>设备驱动处于最底层，直接和外设通信，负责和控制器通信，给设备发出 IO 请求。基本文件系统则是处理数据存放在外存哪个位置。基本 IO 管理程序则关注磁盘调度、IO 设备调度。逻辑 IO 则是访问记录（<strong>记录是指一组基本数据单元的集合</strong>）和维护文件储存的基本数据。最上面一层则应给用户提供 IO 的接口，支持各自操作。</p>
<h3 id="文件组织">文件组织</h3>
<p>文件组织关注文件中记录的逻辑结构，一般需要满足五个原则：快速访问、易于修改、节约存储空间、易于维护、可靠。</p>
<p><strong>堆文件</strong>是最简单的文件组织方式，数据按照任意顺序排列，记录是变长的，就像随意堆积一样，搜索文件时只能穷举。</p>
<p><strong>顺序文件</strong>顾名思义就是按照一定的顺序排序，记录是定长的。</p>
<p><strong>索引顺序文件</strong>在顺序文件的基础上（比如还是保持顺序），添加了文件的关键特征，也就是文件的索引。当添加新的文件时，可以使用索引指向这个文件（溢出文件），然后插入在主文件中，不必实际地移动溢出文件。</p>
<img src="http://cdn.blog-blockchain.xyz/202302121527859.png" alt="image-20230212152722798" style="zoom: 43%;">
<p><strong>索引文件</strong>则只能通过索引访问记录。</p>
<p>**直接文件（散列文件）**可以通过哈希直接访问任何地址地数据块。</p>
<h3 id="文件目录">文件目录</h3>
<p>根据常识，文件的目录需要包括文件名、文件类型（比如文本文件或者二进制文件）、文件组织（比如目录层级）。从存储的地址方面，需要指示存储在哪个设备（卷）、外存的起始物理地址、文件存储的实际大小、文件大小最大限制。从访问控制的角度来说，需要确定所有者、访问信息（比如密码之类的）、各类用户权限信息。从使用信息来说，需要包括文件的创建时间、创建者、最后一次访问时间、最后一次访问用户、最后一次修改日期、最后一次修改者身份等。</p>
<p>目录的结构包括单级结构、两级结构、层次结构等。</p>
<p><strong>单级目录</strong>相当于简单的列表，整个文件系统只有一张目录表，每个目录项对应一个文件。可知，文件名字是不准重复的，而且查找速度慢。</p>
<img src="http://cdn.blog-blockchain.xyz/202302121746253.png" alt="image-20230212174625152" style="zoom:50%;">
<p><strong>两级结构</strong>则分成主目录和用户目录。主目录给每个用户一个目录项，用户目录则是简单的列表</p>
<img src="http://cdn.blog-blockchain.xyz/202302121745463.png" alt="image-20230212174552370" style="zoom: 50%;">
<p><strong>树状结构</strong>则可以包含多级目录，每个目录可以包含文件，也可以包含目录。所有的目录都是由根目录引出。任何文件都可以从根目录向下到各个分支来定位。多个文件可以同名，但是确保路径名是唯一的。</p>
<img src="http://cdn.blog-blockchain.xyz/202302121746361.png" alt="image-20230212174643263" style="zoom:67%;">
<p><strong>无循环图结构</strong>在树型目录的基础上，允许多个目录项指向同一个数据文件或者目录文件，相当于多了软链接。</p>
<img src="http://cdn.blog-blockchain.xyz/202302122023737.png" alt="image-20230212202318639" style="zoom:50%;">
<h3 id="文件共享">文件共享</h3>
<p>当文件允许共享时时，就会出现权限控制和并发控制的问题。权限可以大致分成读、写、执行，更加细化可以分成追加、更新、改变权限、删除等。和文件权限相关的用户身份有所有者、特定用户、组用户和全部。 Unix 一般是通过链接实现文件共享。</p>
<p><strong>硬链接</strong>是将多个文件名链接到同一个索引节点，索引节点会记录引用次数，如果减到 0 那么文件就会被删除。链接文件和被链接文件必须位于同一个文件系统中，而且不允许目录链接。</p>
<p><strong>软链接</strong>又叫符号链接，软链接文件完全不会影响原文件，它们是互相独立的。</p>
<h3 id="外存管理">外存管理</h3>
<p>外存就是各种磁盘之类的存储设备，在外存中，文件由许多的块组成。这些块有三种组织方式定长组块（每个块大小相同）、变长非跨越组块（每个块大小不同且物理上必须连续）、变长跨越组块。</p>
<img src="http://cdn.blog-blockchain.xyz/202302131952510.png" alt="image-20230213195201427" style="zoom: 67%;">
<p>文件系统会将外存分成一个或多个由一组连续分配的块组成的区域，叫做<strong>分区</strong>。<strong>FAT（文件分配表）<strong>会跟踪分区中的数据结构。文件分配到分区的过程中有</strong>预分配</strong>和<strong>动态分配</strong>两种方式。预分配需要在文件创建时声明文件的最大尺寸，动态分配在需要时才给文件分配空间。文件分配时，<strong>连续分配</strong>的方式是文件由在外存中连续的块组成，隐式的<strong>链式分配</strong>则是类似链表，块串在一块，如果要优化读写也可以合并，变成连续分配。<strong>显式链接</strong>则有些不同，不是采用链表，而是将物理块的指针存储在 FAT 表中。早期的 DOS 系统 FAT12 文件系统，FAT 表里每个项用于表示物理块号的位数是 12 比特，所以如果采用<strong>显式链接</strong>的链式分配，最多支持有 2^12 个物理块。</p>
<img src="http://cdn.blog-blockchain.xyz/202302132116437.png" alt="image-20230213211600382" style="zoom:50%;">
<p>实际在操作系统中，并不会精确到每一个扇区去存储，可是采用<strong>簇</strong>作为最小单位，一个文件的占用空间大小只能是簇的整数倍。簇越大，越适合大文件的存储，可以节省 FAT 的表项，便于管理。但是存储小文件时，占用空间可能会远超过实际大小。</p>
<p>除了 FAT（文件分配表）会记录哪些块被使用了，**DAT（磁盘分配表）**用于记录哪些空间没有被使用。DAT 的结构有如下几种情况：</p>
<ol>
<li>位表，Bit Tables。使用一个很长的比特向量，向量的每一位对应磁盘中的每一块，用 0 表示空闲，1 表示占用。</li>
<li>链接空闲分区。采取类似链表的方式，记录下一个空闲区的位置和长度，只需要知道第一个空闲分区的信息即可。</li>
<li>索引。使用索引表记录空闲空间。</li>
<li>空白块列表。每个块指定一个序号， 把所有空闲块的序号保存在磁盘中。</li>
</ol>
<p><strong>卷</strong>在本质上是指<strong>逻辑磁盘</strong>，是一组在外存上可寻址的扇区的集合，操作系统或应用程序用卷来存储数据。而分区是连续物理块的集合。</p>
<h3 id="UNIX-文件管理">UNIX 文件管理</h3>
<p>UNIX 将文件分成 6 类：</p>
<ol>
<li>普通文件（Regular, or ordinary），可以视作字节流，可以存储任意数据。</li>
<li>目录（Directory），包含文件名的列表和指向它的索引节点的指针。</li>
<li>特殊文件（Special），不包含数据，用于物理设备映射到一个文件名。</li>
<li>命名管道（Named pipes），用于进程间通信。</li>
<li>链接文件（Links），硬链接，相当于文件别名。</li>
<li>符号链接（Symbolic links），相当于软链接。</li>
</ol>
<p>UNIX 的所有文件都是通过所有节点管理的，索引节点包含了操作系统需要的文件的所有关键信息。下图就是一个索引节点，它自身就有很多的控制信息，然后包括了指向其他指针的指针和数据的指针。</p>
<p>值得关注的是，指针可以分成多级，每一级可以管理数据的数量指数级增加。而且数据的存储是采用动态分配的方式，按需分配大小。</p>
<img src="http://cdn.blog-blockchain.xyz/202302132212967.png" alt="image-20230213221211888" style="zoom: 67%;">
<p>示例：设文件索引节点中有 7 个地址项，其中 4 个地址项为直接地址索引，2 个地址项是一级间接地址索引，1 个地址项是二级间接地址索引，每个地址项大小为 4 字节，若磁盘索引块和磁盘数据块大小均为 256 字节，则可表示的单个文件的最大长度是？</p>
<p>根据上图的结构可以看到，直接地址直接指向数据块，也就是 4*256=1024 字节=1KB。一级间接地址项指向的索引项（注意<strong>地址项指向索引块</strong>）大小为 256 字节，4 字节一个地址，那么就有 64 个地址项，指向了 64 个数据块。所以支持 2*64*256 B= 32KB。二级间接地址以此类推，1*64*64*256B=1024KB。所以这个索引节点最大支持的文件大小是直接块和间接块之后，也就是 1+32+1024=1057KB。</p>
<h2 id="参考和推荐阅读">参考和推荐阅读</h2>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zbpblog.com/blog-338.html">进程互斥的软件实现方式和硬件实现方法</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/niuyourou/p/12588407.html">I/O 操作的那些事儿：轮询 ，中断 ， DMA ，通道</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/Otiger/p/14748569.html">五种 IO 模型和三种实现方式</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/51170719">RAID 磁盘阵列是什么（一看就懂）</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/qq_44824148/article/details/112037724">操作系统中的『访存次数』</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz">Michael(Jiahao) Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz/cs-courses/OS/">https://www.blog-blockchain.xyz/cs-courses/OS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post-share"><div class="social-share" data-image="/images/OS.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/defi/JayPeggers-attack/" title="JayPeggers 攻击分析"><img class="cover" src="/images/defi.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">JayPeggers 攻击分析</div></div><div class="info-2"><div class="info-item-1">分析JayPeggers协议遭受的重入攻击事件，损失约15 ETH，揭示攻击者如何通过操控代币价格计算逻辑和利用ERC721合约重入实现套利。</div></div></div></a><a class="pagination-related" href="/cs-courses/x86-masm/" title="x86汇编基础"><img class="cover" src="/images/x86_assembly.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">x86汇编基础</div></div><div class="info-2"><div class="info-item-1">深入学习x86汇编语言编程，涵盖微处理器结构、寄存器使用、指令系统、寻址方式、程序设计等内容，基于MASM语法提供完整的汇编编程教程。</div></div></div></a></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">Michael(Jiahao) Luo</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/learnerLj"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://www.linkedin.com/in/jiahao-michael-luo-8ba5942a3" rel="external nofollow noreferrer" target="_blank" title="Linkedin"><i class="fa-brands fa-linkedin"></i></a><a class="social-icon" href="mailto:luoshitou9@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">从技术到商业，从产品到设计，从生活到未来，我会在这里分享我的所思所想，欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-text">进程的描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-text">模式切换和进程切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">进程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS"><span class="toc-text">先来先服务 FCFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-RR"><span class="toc-text">时间片轮转调度算法 RR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88-SJF-SPF-SPN"><span class="toc-text">短进程优先 SJF/SPF/SPN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E6%9C%80%E7%9F%AD%E4%BC%98%E5%85%88-SRT"><span class="toc-text">剩余时间最短优先 SRT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-HRRN"><span class="toc-text">高响应比优先 HRRN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E9%A6%88%E8%B0%83%E5%BA%A6-FB"><span class="toc-text">反馈调度 FB</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-text">实时系统的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-text">实时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">调度算法的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="toc-text">优先级反转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">进程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-text">软件方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-text">硬件方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-text">管程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">消息传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-text">死锁预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-text">死锁避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">哲学家就餐问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">基本内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%85%B3%E6%B3%A8%E7%82%B9"><span class="toc-text">内存管理的关注点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">链接过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-text">内存分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5"><span class="toc-text">分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-text">分段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E7%BB%86%E8%8A%82"><span class="toc-text">分页细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB-%E5%BF%AB%E8%A1%A8"><span class="toc-text">TLB 快表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="toc-text">分段和段页式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text">系统的存储管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-%E7%AE%A1%E7%90%86%E5%92%8C%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-text">IO 管理和磁盘调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">IO 控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E7%BC%93%E5%86%B2"><span class="toc-text">IO 缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%BB%E5%8F%96%E8%BF%87%E7%A8%8B"><span class="toc-text">磁盘的结构和读取过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">磁盘调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID"><span class="toc-text">RAID</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">文件目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-text">文件共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">外存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UNIX-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">UNIX 文件管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%92%8C%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="toc-text">参考和推荐阅读</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>Post Series</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/C-language-basis/" title="C语言基础"><img src="/images/C_Programming_Language.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言基础"></a><div class="content"><a class="title" href="/cs-courses/C-language-basis/" title="C语言基础">C语言基础</a><time datetime="2021-02-02T08:15:22.000Z" title="Created 2021-02-02 16:15:22">2021-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/modular-inverses/" title="乘法逆元"><img src="/images/cryptology.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="乘法逆元"></a><div class="content"><a class="title" href="/cs-courses/modular-inverses/" title="乘法逆元">乘法逆元</a><time datetime="2022-09-27T13:49:22.000Z" title="Created 2022-09-27 21:49:22">2022-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/cpp-cryptographic-algorithm-basis/" title="信息安全算法基础"><img src="/images/cryptology.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信息安全算法基础"></a><div class="content"><a class="title" href="/cs-courses/cpp-cryptographic-algorithm-basis/" title="信息安全算法基础">信息安全算法基础</a><time datetime="2022-12-02T08:15:22.000Z" title="Created 2022-12-02 16:15:22">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/OS/" title="操作系统基础"><img src="/images/OS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统基础"></a><div class="content"><a class="title" href="/cs-courses/OS/" title="操作系统基础">操作系统基础</a><time datetime="2023-02-13T15:06:22.000Z" title="Created 2023-02-13 23:06:22">2023-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/x86-masm/" title="x86汇编基础"><img src="/images/x86_assembly.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="x86汇编基础"></a><div class="content"><a class="title" href="/cs-courses/x86-masm/" title="x86汇编基础">x86汇编基础</a><time datetime="2023-05-11T12:48:22.000Z" title="Created 2023-05-11 20:48:22">2023-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/information-theory/" title="信息论与编码"><img src="/images/info-theory.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信息论与编码"></a><div class="content"><a class="title" href="/cs-courses/information-theory/" title="信息论与编码">信息论与编码</a><time datetime="2023-05-29T00:15:22.000Z" title="Created 2023-05-29 08:15:22">2023-05-29</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/defi/permit-ecdsa-cryptography/" title="ERC-20 Permit 与 ECDSA 密码学原理"><img src="https://cdn.blog-blockchain.xyz/2026/01/7926570b23eeb56169050989a441e0a6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ERC-20 Permit 与 ECDSA 密码学原理"></a><div class="content"><a class="title" href="/defi/permit-ecdsa-cryptography/" title="ERC-20 Permit 与 ECDSA 密码学原理">ERC-20 Permit 与 ECDSA 密码学原理</a><time datetime="2026-01-09T02:00:00.000Z" title="Created 2026-01-09 10:00:00">2026-01-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/career/structural-thoughts-after-one-and-half-years-at-work/" title="职业增长的数学模型：从log(x)到eˣ的跃迁代价">职业增长的数学模型：从log(x)到eˣ的跃迁代价</a><time datetime="2025-12-13T16:00:00.000Z" title="Created 2025-12-14 00:00:00">2025-12-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/career/find-gold-then-build-factory/" title="困境：从「想明白」到「做出来」的鸿沟">困境：从「想明白」到「做出来」的鸿沟</a><time datetime="2025-10-27T17:11:20.000Z" title="Created 2025-10-28 01:11:20">2025-10-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/finance/fundiing-rate/" title="资金费率套利完整指南">资金费率套利完整指南</a><time datetime="2025-10-05T10:26:20.000Z" title="Created 2025-10-05 18:26:20">2025-10-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/finance/options-arbitrage-strategy-modeling/" title="期权组合套利策略的数学分析和建模"><img src="https://cdn.blog-blockchain.xyz/2025/08/16db5eba53f859fa8c4b45badfb216b8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="期权组合套利策略的数学分析和建模"></a><div class="content"><a class="title" href="/finance/options-arbitrage-strategy-modeling/" title="期权组合套利策略的数学分析和建模">期权组合套利策略的数学分析和建模</a><time datetime="2025-08-31T07:45:00.000Z" title="Created 2025-08-31 15:45:00">2025-08-31</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2020 - 2026 By Michael(Jiahao) Luo</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js?v=1768678502909"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="local-search-input"><input placeholder="Search for Posts" type="text"></div><hr><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div></div></div><script src="/bundle.js"></script><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})();
(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})();
(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '467d9506710fff22dc33',
      clientSecret: '2a3e530b895af9c94d4bbe95fe78c69317f4d76e',
      repo: 'blog-gitalk',
      owner: 'learnerLj',
      admin: ['learnerLj'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '7b0d66d9ef0b182d69f60a7b43e79a71'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></body></html>