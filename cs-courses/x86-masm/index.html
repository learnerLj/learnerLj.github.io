<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>x86汇编基础 | Jiahao Luo</title><meta name="author" content="Michael(Jiahao) Luo"><meta name="copyright" content="Michael(Jiahao) Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><meta name="description" content="深入学习x86汇编语言编程，涵盖微处理器结构、寄存器使用、指令系统、寻址方式、程序设计等内容，基于MASM语法提供完整的汇编编程教程。">
<meta property="og:type" content="article">
<meta property="og:title" content="x86汇编基础">
<meta property="og:url" content="https://www.blog-blockchain.xyz/cs-courses/x86-masm/index.html">
<meta property="og:site_name" content="Jiahao Luo">
<meta property="og:description" content="深入学习x86汇编语言编程，涵盖微处理器结构、寄存器使用、指令系统、寻址方式、程序设计等内容，基于MASM语法提供完整的汇编编程教程。">
<meta property="og:locale">
<meta property="og:image" content="https://www.blog-blockchain.xyz/images/x86_assembly.jpg">
<meta property="article:published_time" content="2023-05-11T12:48:22.000Z">
<meta property="article:modified_time" content="2025-06-18T20:06:27.909Z">
<meta property="article:author" content="Michael(Jiahao) Luo">
<meta property="article:tag" content="assembly">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.blog-blockchain.xyz/images/x86_assembly.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "x86汇编基础",
  "url": "https://www.blog-blockchain.xyz/cs-courses/x86-masm/",
  "image": "https://www.blog-blockchain.xyz/images/x86_assembly.jpg",
  "datePublished": "2023-05-11T12:48:22.000Z",
  "dateModified": "2025-06-18T20:06:27.909Z",
  "author": [
    {
      "@type": "Person",
      "name": "Michael(Jiahao) Luo",
      "url": "https://www.blog-blockchain.xyz/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://www.blog-blockchain.xyz/cs-courses/x86-masm/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?372b8854d18acf62880149b1e08e1901";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=QXcJQjXxTMeUwnWykFW2xw"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'QXcJQjXxTMeUwnWykFW2xw')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'QXcJQjXxTMeUwnWykFW2xw', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'x86汇编基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Jiahao Luo" type="application/atom+xml">
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css');loadCss('https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css');loadCss('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css"></noscript></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">55</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">28</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jiahao Luo</span></a><a class="nav-page-title" href="/"><span class="site-name">x86汇编基础</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">x86汇编基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-11T12:48:22.000Z" title="Created 2023-05-11 20:48:22">2023-05-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-06-18T20:06:27.909Z" title="Updated 2025-06-19 04:06:27">2025-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/courses/">courses</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>47mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><blockquote>
<ol class="series-items"><li><a href="/cs-courses/C-language-basis/" title="C语言基础">C语言基础</a></li><li><a href="/cs-courses/modular-inverses/" title="乘法逆元">乘法逆元</a></li><li><a href="/cs-courses/cpp-cryptographic-algorithm-basis/" title="信息安全算法基础">信息安全算法基础</a></li><li><a href="/cs-courses/OS/" title="操作系统基础">操作系统基础</a></li><li><a href="/cs-courses/x86-masm/" title="x86汇编基础">x86汇编基础</a></li><li><a href="/cs-courses/information-theory/" title="信息论与编码">信息论与编码</a></li></ol>
</blockquote>
<p>这是电子科技大学的汇编程序设计的课程复习，由本人总结，主要资源来自 PPT 和自编教材，少部分辅以网上的博客（会给出参考链接）。课程是基于 x86 汇编，汇编语法和汇编器采用 MASM，程序主要是 flat 模式，语法可能和其他的汇编器不同。这篇文章的主要目的是总结和复习，所以可能较为简洁，读者可以在评论区提问，我会不断完善。如果由不准确或者错误的地方，欢迎指正。</p>
<h2 id="微处理器和寄存器简介">微处理器和寄存器简介</h2>
<p>由于汇编需要程序员考虑处理器和寄存器的状态，因此了解基本的内容，有利于理解汇编是如何在 CPU 上工作的。汇编语言与机器语言（字节码）是绑定的，大部分指令直接对应 CPU 的指令，因此汇编不具有可移植性，无法在不同的指令架构下运行。</p>
<h3 id="CPU-执行指令">CPU 执行指令</h3>
<p>我们学习 CPU，主要是关注 CPU 内的寄存器、访存方式、输入输出。在计算机组成原理中，我们已经学习过 CPU 的概念图，每次运行：</p>
<ol>
<li>取指令（Instruction Fetch）：CPU 发送读取内存的地址，获取指令代码，然后将指令保存在指令寄存器 IR 中。</li>
<li>指令译码（Instruction Decode）：CPU 将 IR 中的指令中的操作码、操作数、地址等信息解码，然后确定操作数的存储位置、指令要完成的操作以及需要的寄存器等。</li>
<li>执行指令（Execute）：CPU 会对操作数进行运算或将操作数存储到特定的位置。对于一些需要访问内存或 IO 设备的指令，CPU 会将内存或 IO 设备中的数据读取到 CPU 的寄存器中。(有时候，会把<strong>读取操作数单独作为一个步骤，放在执行指令前</strong>)。</li>
<li>写回结果（Write Back）：如果是运算指令，CPU 将结果存储到指定的寄存器中；如果是访存指令，CPU 将结果写回到指定的内存地址中。</li>
</ol>
<img src="http://cdn.blog-blockchain.xyz/202304211539487.png" alt="image-20230421153931153" style="zoom: 33%;">
<ul>
<li>GPRs：通用寄存器（General Purpose Registers），在计算机系统中用于存储操作数、地址和控制信息等临时数据的寄存器，是 CPU 内部存储器中的一部分，具有快速读写的特点。</li>
<li>MAR：存储器地址寄存器（Memory Address Register），用于存储 CPU 将要访问的存储器地址。</li>
<li>MDR：存储器数据寄存器（Memory Data Register），用于存储 CPU 从存储器中读取的数据或将要写入存储器的数据。</li>
<li>IR：指令寄存器（Instruction Register），用于存储 CPU 当前执行的指令。</li>
<li>ALU：算术逻辑单元（Arithmetic Logic Unit），CPU 中用于执行算术和逻辑运算的部件，它可以对多个操作数进行运算并产生结果。</li>
</ul>
<h3 id="8086-8088">8086/8088</h3>
<h4 id="特点和工作模式">特点和工作模式</h4>
<p>8086/8088 是 Intel 推出的第一款 16 位微处理器，具有以下几个特点：</p>
<ol>
<li>采用并行流水线工作方式：8086/8088 将 CPU 划分成多个功能部分，如指令预取队列、指令译码器、算术逻辑部件(ALU)等，并设置<strong>指令预取队列</strong>，实现流水线工作。这种工作方式可以提高 CPU 的运算速度，同时也为后续的 CPU 设计提供了基础。</li>
<li>对内存空间实行分段管理：8086/8088 采用了分段管理技术，将内存分为多个段并设置<strong>4 个段地址寄存器(CS、DS、ES、SS)，每个段可以达到 64KB，多段寻址可以实现对 1MB 空间的寻址</strong>。通过对不同段进行划分，可以灵活地管理内存空间，同时也为后续的 CPU 设计提供了借鉴。</li>
<li>支持多处理器系统：8086/8088 可以<strong>通过总线接口支持多处理器系统，可以与其他 8086/8088 或协处理器(Coprocessor)进行通信，实现共享计算资源</strong>，提高系统的运算效率。此外，协处理器也可以<strong>扩展 CPU 的指令集</strong>，增强 CPU 的运算能力。</li>
</ol>
<p>8088 有两种工作模式：最大模式和最小模式。<strong>最大模式</strong>是指 CPU<strong>通过外部总线与外围设备进行通信</strong>，包括访问内存、输入输出、中断响应等。在最大模式下，<strong>CPU 需要使用多个芯片来实现外部通信功能</strong>，包括地址数据总线转换芯片、系统计时控制芯片、输入输出控制芯片等。</p>
<p><strong>最小模式</strong>是指<strong>CPU 不通过外部总线与其他设备进行通信，而是通过芯片组内部的接口实现通信</strong>。在最小模式下，CPU<strong>只需要使用一个称为多路复用器的芯片</strong>来实现地址和数据的<strong>复用</strong>输出，减少了芯片数量和复杂性。</p>
<h4 id="主要引脚">主要引脚</h4>
<img src="https://cdn.blog-blockchain.xyz/202304211653166.jpeg" style="zoom: 33%;">
<p>地址引脚：</p>
<ul>
<li>AD0-AD7：低 8 位地址和低 8 位数据信号的线。当 CPU 需要从存储器中读取数据时，这些线就是输入数据信号的线；当 CPU 需要将数据写入存储器时，这些线就是输出数据信号的线；当 CPU 需要向存储器发送地址时，这些线就是输出地址信号的线。</li>
<li>A8-A15：高 8 位地址信号的线。在 8086 中，这些线也用于传输低 8 位数据信号。因为<strong>8086 的总线是 16 位的，8088 是 8 位的</strong>。</li>
<li>A16-A19/S3-S6：高 4 位地址信号的线，也与状态信号分时复用。这些线用于传输 CPU 的高 4 位地址信号，用于扩展地址空间。<strong>在 8088 中，这些线同时用作状态信号</strong>，用于传输一些特殊的控制信息。<strong>在 8086 中，这些线不用于状态信号</strong>，而是专门用于传输高 4 位地址信号。</li>
</ul>
<p>控制引脚：</p>
<ul>
<li>
<p>RD（Read）：读信号，用于从内存或 I/O 设备读取数据。</p>
</li>
<li>
<p>WR（Write）：写信号，用于向内存或 I/O 设备写入数据。</p>
</li>
<li>
<p>IO/M（Input/Output Memory）：指示当前访问的是（0）内存还是（1）I/O 端口。<strong>8086 的信号与 8088（上一句）的相反</strong>。</p>
</li>
<li>
<p>DEN（Data Enable）：数据使能信号，用于表示当前数据线的数据有效。</p>
</li>
<li>
<p>DT/R（Data Transmit/Receive）：数据传输/接收模式选择信号。</p>
</li>
<li>
<p>ALE（Address Latch Enable）：地址锁存使能信号。当其为高电平时，表示地址线上的地址被锁存到一个锁存器中，确保 CPU 在进行读写操作时，始终使用的是同一个地址。</p>
</li>
<li>
<p>READY：用于与外部设备同步。READY 信号的作用是为了控制 CPU 的读写速度，因为 CPU 和外部设备的速度不一定相同。当 CPU 向外部设备请求数据时，外部设备可能还没有准备好数据，如果 CPU 继续读取数据，可能会读到错误的数据。通过 READY 信号，外部设备可以告诉 CPU 何时可以读取数据，确保数据的正确性。</p>
</li>
<li>
<p>RESET 是复位信号，当其为高电平时，CPU 会被强制复位，内部寄存器会被清零或者被设为特定的值，以确保 CPU 从初始状态开始执行。复位后的值如下表：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>内部寄存器</strong></th>
<th><strong>内容</strong></th>
<th><strong>内部寄存器</strong></th>
<th><strong>内容</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CS</strong></td>
<td><strong>FFFFH</strong></td>
<td><strong>IP</strong></td>
<td><strong>0000H</strong></td>
</tr>
<tr>
<td><strong>DS</strong></td>
<td><strong>0000H</strong></td>
<td><strong>FLAGS</strong></td>
<td><strong>0000H</strong></td>
</tr>
<tr>
<td><strong>SS</strong></td>
<td><strong>0000H</strong></td>
<td><strong>其余寄存器</strong></td>
<td><strong>0000H</strong></td>
</tr>
<tr>
<td><strong>ES</strong></td>
<td><strong>0000H</strong></td>
<td><strong>指令队列</strong></td>
<td><strong>空</strong></td>
</tr>
</tbody>
</table>
<h4 id="内部结构和寄存器">内部结构和寄存器</h4>
<p>大致分为执行单元 EU 和总线接口单元 BIU，重点关注的是<strong>通用寄存器和标志寄存器</strong>，这些寄存器在汇编中会经常用到。</p>
<img src="http://cdn.blog-blockchain.xyz/202304211730182.png" alt="21819785540 (1)" style="zoom:67%;">
<p>通用寄存器除了可以作为通用的寄存器，用法习惯上也有一些差别：</p>
<ol>
<li>AX：<strong>IO 的数据</strong>暂存在这里，<strong>中间运算结果</strong>也存这里。</li>
<li>BX：<strong>内存寻址</strong>时地址存这里。</li>
<li>CX：<strong>循环和串操作</strong>存这里，因为串操作常常需要循环。</li>
<li>DX：存放<strong>I/O 端口地址</strong>还有<strong>32 位除法</strong>的高 16 位。</li>
<li>SP：表示堆栈指针，日后会详细学习它的计算方法。</li>
<li>BP：存放栈基址，比如要<strong>访问函数的参数和局部变量</strong>。</li>
<li>DI 和 SI：一般用于<strong>串操作</strong>，DI 寄存器通常作为目的地址寄存器，SI 寄存器作为源地址寄存器，用于在内存中移动和复制字符串。</li>
</ol>
<p>段寄存器在保护模式基本用不到，因为整个内存空间是连续的，了解含义即可。</p>
<ul>
<li>IP：下一条要执行指令的地址。</li>
</ul>
<p>下面的段寄存器都是存放对应段的基址，在实模式下都是段基址，一个段 64KB。但是保护模式下一个段最大 4GB,段寄存器存储选择子（16 位）的地址，选择子包括段基地址和段属性信息，由操作系统负责将选择子转换成段基地址。</p>
<ul>
<li>CS 寄存器（<strong>代码段</strong>寄存器）</li>
<li>DS 寄存器（<strong>数据段</strong>寄存器）</li>
<li>ES 寄存器（<strong>附加段</strong>寄存器）</li>
<li>SS 寄存器（<strong>堆栈段</strong>寄存器）</li>
</ul>
<p>实际汇编的时候，是用到 32 位的 flat 模式，也就是寄存器参考下面的 IA-32，主要是理解 EAX、AX、AH、AL 之间的关系，在小端序下的值如何存储。</p>
<p>IA-32 是 <strong>32</strong> 位处理器，4GB 物理地址空间，64TB 的虚拟地址寻址空间。支持分段、分页的内存管理方式，有<strong>实地址模式、保护模式、虚拟 8086 模式</strong>三种工作方式。</p>
<img src="https://cdn.blog-blockchain.xyz/202304211719262.png" alt="IA-32寄存器" style="zoom: 67%;">
<h4 id="标志寄存器">标志寄存器</h4>
<p>标志寄存器在汇编中非常常用，不能手动赋值。标志位的设置和清除是由 CPU 执行指令时自动完成的，程序员可以通过各种指令来检查这些标志位的状态，并根据需要进行相应的操作。许多指令有不同的修改标志寄存器的规定，并且标志寄存器用于提供控制信息。</p>
<ul>
<li>CF（进位标志）：最高有效位的<strong>进位或借位</strong>，CF 为 1，否则为 0。</li>
<li>PF（奇偶标志）：记录结果中 1 的个数的奇偶性。如果结果中<strong>1 的个数为偶数，PF 为 1</strong>，否则为 0。</li>
<li>AF（辅助进位标志）：记录<strong>低四位的进位或借位</strong>。如果最后一次操作需要进位或借位，AF 为 1，否则为 0。</li>
<li>ZF（零标志）：记录结果是否为<strong>0</strong>。如果结果为 0，ZF 为 1，否则为 0。</li>
<li>SF（符号标志）：记录结果的<strong>符号</strong>。如果结果为负数，SF 为 1，否则为 0。</li>
<li>OF（溢出标志）：记录结果是否<strong>溢出</strong>。如果结果溢出，OF 为 1，否则为 0。</li>
</ul>
<p>注意是直接运算来判断标志位，而不是转化成补码后判断标志位。比如溢出标志是根据结果和操作数确定的。以上的标志位需要熟练掌握。</p>
<p>（<strong>例题</strong>）！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>
<p>还有 3 个不常用的控制标志位，了解即可：</p>
<ul>
<li>TF（跟踪标志）：用于<strong>单步调试</strong>。如果 TF 为 1，则 CPU 在执行一条指令后暂停执行并进入单步调试状态，否则为 0。</li>
<li>IF（中断标志）：用于控制<strong>可屏蔽中断</strong>的开关。如果 IF 为 1，则 CPU 允许可屏蔽中断，否则为 0。</li>
<li>DF（方向标志）：用于指示字符串操作指令的方向。如果 DF 为 1，则字符串操作指令向前移动（由高地址到低地址），否则为 0（向后移动，由低地址到高地址）。</li>
</ul>
<h4 id="堆栈">堆栈</h4>
<p>物理地址受限于引脚数量，可以知道最大 20 位，1MB。<strong>一个字两个字节，地址小的字节的地址作为字的地址。小端序，数字低位低地址，字符串顺序存放</strong>。</p>
<p>逻辑地址分成两部分，16 位段地址，16 位段内地址。通过段地址找到段在内存中的起始位置，通过段内地址找到在段内的偏移量，这样就可以定位一个字节。简单的说，段地址+段内地址就是字节所在的地址。但是<strong>段地址不是随意的，必须是 16 的倍数</strong>，因为规定 16 位为一个小节（Paragraph）。<strong>段最大长度 64KB</strong>。所以，段地址默认低四位为 0，<strong>段寄存器的值需要左移 4 位才是它实际表示的值</strong>。所以，<strong>根据段寄存器和段内偏移量计算地址时，需要注意</strong>。</p>
<p>堆栈的<strong>最下端是固定的</strong>，叫做栈底。另外一端，叫做栈顶，是最后压栈的元素，SP 就是指向这个元素。SS 指向的是栈所在的存储位置。需要注意：</p>
<ol>
<li>栈底是堆栈最下面的字的地址。</li>
<li>堆栈的每个元素都是字为单位，一层 2 个字节。</li>
<li><strong>堆栈增长的方向是地址减小的方向</strong>，也就是栈底是高地址，栈顶是低地址。</li>
<li>SP 的值为与栈开始位置（SS 寄存器的值）的距离，字节为单位。</li>
<li>SP 初始化时在栈底下面两个字节，也就是栈底的段内相对地址+2，此时为最大值，表示栈为空。</li>
<li>SP 为 0，表示堆栈满了。</li>
</ol>
<img src="http://cdn.blog-blockchain.xyz/202304232012224.png" alt="311634024676480 (1) (1)" style="zoom:50%;">
<p>上面的栈的示意图，是每一层一个字节。</p>
<h3 id="保护模式的段寻址">保护模式的段寻址</h3>
<p>主要是学习 IA-32 以后的段寻址的方式，虽然我们主要是使用 flat 32 模式，它是一种特殊的保护模式，不用考虑分段，都是虚拟地址。</p>
<p>在学习段寄存器时提到，保护模式下段寄存器的内容不是段的起始地址，而是段选择子（也叫做段选择器）的地址，段选择器这个数据结构包括了段基地址和段长等属性。还需要了解一些概念：</p>
<ul>
<li>段描述符：每个段对应的元信息，包括段段长、段基地址等信息。</li>
<li>描述符表：包含了所有内存段的描述符。它可以被认为是一个数组，每个元素就是段描述符。</li>
<li>段选择器：用于访问描述符表，定位到自己需要的段的描述符。这样获取了段的信息之后，就可以访问段所在的内存了。</li>
</ul>
<p><strong>段选择器</strong>的长度就是段寄存器的长度，只有 16 位。</p>
<ul>
<li>0-1：RPL，表示优先级，寻址时基本不用注意。</li>
<li>2：TI，关键位，<strong>0 表示描述符在 GDT 中，1 表示在 LDT 中</strong>。</li>
<li>3-15：在描述符表中的索引记住时<strong>高 13 位</strong>。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 15      3   2     0</span><br><span class="line">+----------+-------+</span><br><span class="line">| Index    | TI RPL|</span><br><span class="line">+----------+-------+</span><br></pre></td></tr></tbody></table></figure>
<p><strong>段描述符</strong>为 64 位，下图需要拼起来，第一条是高 32 位，第二条是低 32 位。</p>
<img src="http://cdn.blog-blockchain.xyz/202304232102139.png" alt="image (1)" style="zoom: 80%;">
<p>比如对于 0x98A46A40 0xAF0FC083，按照上图，段基址应该是 0x9840 AF0F。（顺带吐槽，chatGPT 推理能力真差）。简单的说，高 32 位取头尾字节，低 32 位取头 2 个字节。</p>
<p>属性中的 <code>G</code> 比较特殊表示粒度，G=1 时单位就变成了 4K，段限长取最大时，一个段就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>∗</mo><mn>4</mn><mi>K</mi><mi>B</mi><mo>=</mo><mn>4</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{20}*4KB=4GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.05017em;">GB</span></span></span></span>。否则单位就是 1 个字节。</p>
<p><strong>段描述符表</strong>有两个常用的，GDT 是全局描述符表，系统中只有一个。LDT 是局部描述符表，每个进程一个，里面都属局部描述符，是进程使用的段的元信息。可以通过 GDTR 找到 GDT 的位置，但是寻找 LDT 的位置时，需要根据 LGTR 在 GDT 中寻找。<strong>因为 GDTR 是 48 位，LGTR 是 16 位</strong>。在<strong>多任务的 Windows 系统中 LDTR 只有一个</strong>，它用来指示当前任务，当前任务切换时需要改变 LDTR 的内容。</p>
<p>寻址时，首先从段寄存器获取 16 位的段选择子，看第 3 位的 TI：</p>
<ul>
<li>为 0，表示段描述符在 GDT 中。从 <strong>GDTR 中高 32 位是 GDT 的地址</strong>，低 16 位是 GDT 的限长。然后<strong>段选择器的高 13 为是索引地址</strong>，找到段描述符。段描述符的基址寻址，如上面所示。最后再加上段内偏移量即可。</li>
</ul>
<p><img src="http://cdn.blog-blockchain.xyz/202304240039936.png" alt="image (1)"></p>
<ul>
<li>为 1，表示段描述符在 LDT 中。同样先在 GDT 中找到段描述符，LDTR 的高 13 为 作为索引。但是需要注意，这不再是寻找的字节所在的段的段描述符，而是 LDT 的段描述符，需要根据它寻找 LDT 的起始地址。找到 LDT 起始地址之后，用段选择器的 高 13 位作为索引，就找到了真正的段描述符。</li>
</ul>
<p><strong>（例题）！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</strong></p>
<h2 id="指令系统">指令系统</h2>
<p>CPU 的指令一般由三部分组成：操作码，表示执行何种操作；目标操作数，存储结果；源操作数，存储参与运算的数据。这三部分不一定是严格区分的，比如 ADD AX BX，AX BX 都是源操作数；再比如 <code>TEST AX BX</code> 表示两个数相与，但是目标操作数并不是 AX 或者 BX，而是只修改标志位。</p>
<p>操作数有 3 个来源，第一种是硬编码到指令中的<strong>立即数</strong>；第二种是<strong>寄存器</strong>，可以是 8 位（AL、AH）、16 位（AX）、32 位（EAX）；第三种<strong>存储器</strong>，也就是内存，比比如定义数据时的符号地址，或者是寄存器种的地址的值 <code>[AX]</code>。</p>
<h3 id="寻址方式">寻址方式</h3>
<ol>
<li>
<p>立即数寻址，和国内不同。简单地说就是操作数硬编码到指令。<strong>立即数无法截断，不能超过目的操作数的长度</strong>。比如 <code>MOV AL 260</code> 就会报错，<code>MOV AL 1</code> 其中的 1 就会自动拓展到 8 位。</p>
</li>
<li>
<p>寄存器寻址，操作数都在寄存器中。</p>
</li>
<li>
<p>直接寻址。通过内存地址来访问数据。<strong>内存操作数的长度必须和另一个操作数相同</strong>。</p>
</li>
<li>
<p>寄存器间接寻址。寄存器中是操作数在内存中的地址，然后 <code>[EAX]</code> 就是表示内存中的值。需要注意：</p>
<ol>
<li><strong>不能使用 16 位的寄存器存储地址</strong>。</li>
<li>没有说明长度，默认使用另外另外一个操作数的长度。比如 <code>MOV EAX,1234H,  MOV BX, [EAX]</code> 是读取从 1234H 开始的 2 个字节。</li>
<li>寄存器都是默认在数据段，只有 EBP 和 ESP 默认在堆栈段。</li>
<li><strong>保护模式下不能直接访问具体的存储单元</strong>。比如 <code>MOV EAX,1234H,  MOV BX, [EAX]</code> 会报错。使用 <code>MOV BX [1234H]</code> 和 <code>MOVE BX 1234H</code> 是一个效果。</li>
</ol>
</li>
<li>
<p>寄存器相对寻址。寄存器中的地址，加上一个偏移量来确定地址。它的写法很多，但是<strong>偏移量不能放在括号后面</strong>，一下几种都是等效的。</p>
<ol>
<li><code>MOV AX, [EBX+offset]</code></li>
<li><code>MOV AX, offset[EBX]</code></li>
<li><code>MOV AX, offset+[EBX]</code> 或者 <code>MOV AX, [EBX]+offset</code></li>
<li>但是<strong>不能</strong> <code>MOV AX, [EBX]offset</code></li>
</ol>
</li>
<li>
<p>基址-变址寻址，简单说就是寄存器里的地址可以乘 2、4、8.</p>
</li>
<li>
<p>隐含寻址。一些指令是默认了操作数的来源，比如 <code>MUL BL</code> 省略的另外一个操作数是 AL，结果默认是写入 <code>AX</code>。</p>
</li>
</ol>
<h3 id="常用指令">常用指令</h3>
<h4 id="数据传送指令">数据传送指令</h4>
<p>这一类指令<strong>不修改标志位</strong>！</p>
<h5 id="MOV">MOV</h5>
<p><code>MOV dest src</code>，表示将 src 的值，复制给 dest，注意是底层的字节序列的赋值。</p>
<p>MOV 的两个操作数必须长度相同，但是存在以下的几种自动拓展的情况：</p>
<ol>
<li>src 是立即数的话，必须小于等于 dest 长度，并且可以拓展。</li>
<li>内存之间不能直接传送。</li>
<li>CS 寄存器不能被修改，可以作为 src。</li>
<li>段寄存器之间不能直接赋值，但是可以通过通用寄存器承接的方式赋值。</li>
<li>标志寄存器不参与传送。</li>
<li>一个存储单元，必须要有起始地址及类型（长度）。如果在指令中没给出长度，根据另外一个操作数确定。如果给出长度，两个操作数的长度不能矛盾。</li>
</ol>
<img src="http://cdn.blog-blockchain.xyz/202304242028644.png" alt="image-20230424202824549" style="zoom:50%;">
<p>例题：</p>
<ol>
<li>MOV AL，BX。长度不一致</li>
<li>MOV [BX][SI]，AX。内存寻址必须 32 位。</li>
<li>MOV DS，1000H。立即数无法给段寄存器赋值。</li>
<li>MOV [1200]，SI。不能直接访问具体的存储单元。</li>
<li>MOV AX，CS。正确</li>
<li>MOV DS，CS。段寄存器之间不能直接赋值。</li>
</ol>
<h5 id="MOVZX-MOVSX">MOVZX/MOVSX</h5>
<p>零拓展和符号拓展，可以拓展源操作数，达到目标操作数的长度，然后传送。</p>
<h5 id="堆栈指令">堆栈指令</h5>
<p><strong>对于 16 位的实模式</strong>，堆栈指令的操作数<strong>不能是立即数</strong>，可以是 16 位的寄存器或者内存中的一个字，而且必须显式指定长度为一个字。最常见的指令为 <code>PUSH OPRD</code> <code>POP OPRD</code>，操作数必须满足上面的要求。 <code>PUSHF OPRD</code> <code>POPF OPRD</code> 会把标志寄存器的值压入堆栈，然后据一定的规则修改在标志寄存器中的值。</p>
<p>由于堆栈是 16 位一层，而且 SP 表示和 SS 的距离，所以每次 <code>PUSH</code>，SP = SP-2。再次强调，小端序，栈底高地址。反之 <code>POP</code> 造成 SP=SP+2。</p>
<p><strong>对于 32 位保护模式</strong>，堆栈元素大小是 32 位，<strong>允许立即数入栈</strong>。新加入了 <code>PUSHA</code> 将 8 个 16 位通用寄存器按 AX、CX、DX、BX、SP、BP、SI 与 DI 的顺序入栈；<code>PUSHAD</code> 则是将这 8 个 32 位寄存器的值顺序入栈。<code>POPA</code> 则相反，将栈顶的 8 个字依次送入 DI、 SI 、BP、 SP 、 BX 、 DX 、CX 与 AX。<code>POPAD</code> 也是类似的。</p>
<p>同样也有修改标志位的指令，保护模式下的寄存器是 32 为，而实模式下的标志寄存器是 16 为，所以 <code>PUSHFD</code> <code>POPFD</code> 也是类似的，只是标志寄存器变成了 32 位。</p>
<h5 id="交换指令">交换指令</h5>
<p>交换指令是一种用于交换两个操作数的值的指令，常见的有 XCHG 指令 <code>XCHG destination, source</code>。这两个操作数必须至少有一个是寄存器，而且不能是段寄存器。</p>
<h4 id="IO-指令">IO 指令</h4>
<p>输入输出指令是 CPU 和外设之间进行数据交换的指令，用于完成计算机系统的输入输出操作。输入指令将数据从外设传输到 CPU，输出指令将数据从 CPU 传输到外设。</p>
<p>输入输出指令一般使用 IN 和 OUT 指令来实现。IN 指令用于将数据从端口读入到寄存器中，OUT 指令用于将寄存器中的数据输出到指定的端口中。这些指令需要指定端口号和数据长度。<code>IN  acc，PORT</code> <code>OUT  PORT，acc</code>。</p>
<p>回忆寄存器的作用，AX 放 IO 数据，DX 放 IO 地址。根据数据的大小，可以选择 AL、AX、EAX（保护模式）。<code>PORT</code> 可以使用直接寻址和间接寻址，直接寻址就是根据 8 位 <code>PORT</code> 的值寻址，注意是无符号数，范围是 0-255。间接寻址则是超过 255 时，<strong>端口地址只能由 DX 指定</strong>。也就是说，DX 都可以用来寻址。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IN  AX，80H</span><br><span class="line">MOV DX，2400H</span><br><span class="line">IN  AL，DX</span><br><span class="line">OUT  35H ，EAX</span><br></pre></td></tr></tbody></table></figure>
<h4 id="取地址指令">取地址指令</h4>
<p>LEA 的全称是 Load Effective Address（加载有效地址），用于内存单元所在的地址写入寄存器。<code>LEA REG，MEM </code>，源操作数必须是来自内存，目标操作数在保护模式下可以是 32 位寄存器（flat 模式地址都是 32 位）。但是也可以是 <strong>16 位寄存器，只保留地址的低 16 位</strong>，比如 <code>LEA SI, [EDI]</code> SI 中只存储了 EDI 的低 16 位</p>
<p>LEA 还可以执行加法，比如 <code>LEA  AX, [BX][DI] </code> 是将 <code>BX+DI</code> 送入 AX 中。这是因为 <code>OFFSET</code> 伪指令是不能读取寄存器，所以无法使用寄存器执行加法。</p>
<p>例题：将数据段中首地址为 MEM1 的 50 个字节的数据传送到同一逻辑段首地址为 MEM2 的区域存放。编写相应的程序段 。</p>
<p>分析，50 次循环，每次把一个字节传送，同时更新源操作数地址和目的操作数的地址。串操作一般用 SI 和 DI，计数器用 CX，暂存数据用 AX，注意保护模式用 32 位。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    LEA ESI, MEM1</span><br><span class="line">    LEA EDI, MEM2</span><br><span class="line">    MOV CL, 50</span><br><span class="line">NEXT:</span><br><span class="line">	MOV AL, [ESI];用AL是因为可以指定一个字节</span><br><span class="line">	MOV [EDI], AL</span><br><span class="line">	INC ESI</span><br><span class="line">	INC EDI</span><br><span class="line">	DEC CL</span><br><span class="line">	JNZ NEXT; DEC 会影响到ZF标志位, CL不为0时 ZF=0，那么就循环</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="标志位操作指令">标志位操作指令</h4>
<p>标志位操作指令是一类用于修改和操作标志寄存器的指令。这些指令可以用于设置、清除或测试标志位的值。<code>LAHF</code> 全称是 Load AH from Flags，用于将当前的标志寄存器的<strong>低 8 位</strong>拷贝到**<code>AH</code>寄存器**中。<code>SAHF</code>, “Store AH into Flags” 则是相反的作用。</p>
<h3 id="算术运算">算术运算</h3>
<p>算术运算指令是用来进行数值运算的汇编指令，大多会影响标志位，特殊的会作特别的说明。</p>
<h4 id="加法指令">加法指令</h4>
<p>加法指令得要求和 MOV 指令基本相同，核心是目标操作数要可以写入，两个操作数不能都是来自内存。</p>
<p>常见的 <code>ADD OPRD1 OPRD2</code> 会影响所有标志位。<code>ADC</code> 指令则会加上 CF 的值，这样实现大整数的相加，因此<strong>初始化时应该 CF 置零</strong>。例如需要完成 20 个字节的操作数的加法，我们就需要「进位加法」：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	LEA ESI, M1</span><br><span class="line">	LEA EDI, M2</span><br><span class="line">	MOV CL, 20</span><br><span class="line">	CLC;使得CF为0</span><br><span class="line">NEXT:</span><br><span class="line">	MOV AL, [ESI]</span><br><span class="line">	ADC AL, [EDI]</span><br><span class="line">	INC ESI</span><br><span class="line">	INC EDI</span><br><span class="line">	DEC CL</span><br><span class="line">	JNZ NEXT</span><br></pre></td></tr></tbody></table></figure>
<p><code>INC reg</code> 和 <code>DEC reg</code> 指令在循环中按字节操作时，经常出现，分别是加一和减一。他会<strong>影响除了 CF 标志位的所有其他标志位</strong>。</p>
<h4 id="减法指令">减法指令</h4>
<p><code>SUB</code> 指令和 <code>ADD</code> 指令是类似的；<code>SBB</code> 和 <code>ADC</code> 是对应的，全称是 Subtract with Borrow，也就是需要多减去进位（借位）标志，也就是 CF 标志。</p>
<p><code>NEG OPRD</code> 指令则是对操作数取负数，相当于用 0 减去它。实际操作是按位取反+1。同样的，操作数必须是来自内存或者寄存器。它会影响常用的 6 个标志寄存器，课程只关心 CF 和 OF：</p>
<ul>
<li>只有当操作数为 0 时，CF 才为 0，其他为 1。</li>
<li>当操作数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">-2^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>15</mn></msup></mrow><annotation encoding="application/x-tex">-2^{15}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">15</span></span></span></span></span></span></span></span></span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span> 时，结果时操作数本身，OF 为 1。其他情况 OF 为 0.</li>
</ul>
<p><code>CMP OPRD1，OPRD2</code> 指令<strong>不更改操作数，只按照 <code>OPRD1-OPRD2</code> 影响所有标志位</strong>，它的作用是根据标志位判断大小关系。但是它的操作数和 ADD 指令一样，<strong>OPRD1 必须是可以写入的，而且两个操作数不能全来自内存</strong>。具体来说</p>
<p>对于无符号数 <code>CMP AX BX</code>，用 CF、ZF 判断：</p>
<ul>
<li>
<p>若 AX &gt; BX，则 CF=0, ZF=0</p>
</li>
<li>
<p>若 AX &lt; BX，则 CF=1, ZF=0</p>
</li>
<li>
<p>若 AX = BX，则 ZF=1</p>
</li>
</ul>
<p>对于有符号数，用 SF、OF、ZF 判断：</p>
<ul>
<li>若 AX &gt; BX，则 OF=SF,ZF=0</li>
<li>若 AX &lt; BX，则 OF≠SF,ZF=0</li>
<li>若 AX=BX，则 ZF=1</li>
</ul>
<p>一般的用法，比如在后面接跳转指令。<strong>JG</strong>(Jump if Greater) 指令表示有符号数“大于”跳转，当 OF=SF,ZF=0 时，跳转。<strong>JA</strong>(Jump if Above) 指令表示“大于（无符号数）”跳转，当 CF=0, ZF=0 时，跳转。</p>
<p>例题：在 20 个从 BUF 开始的无符号数中，找出最大的数，并将其存放在 MAX 单元中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    LEA EBX MAX</span><br><span class="line">    LEA ESI BUF</span><br><span class="line">    MOV CL, 19</span><br><span class="line">    MOV EAX, [ESI]</span><br><span class="line">NEXT:</span><br><span class="line">	INC ESI</span><br><span class="line">	CMP EAX, [ESI]</span><br><span class="line">    JB ASSIGN;如果EAX的数比较小</span><br><span class="line">CONTINUE:</span><br><span class="line">	DEC CL</span><br><span class="line">    JNZ NEXT;继续循环</span><br><span class="line">    MOV [EBX], EAX；循环结束</span><br><span class="line">    HLT</span><br><span class="line"></span><br><span class="line">ASSIGN:</span><br><span class="line">	MOV EAX, [ESI]</span><br><span class="line">	INC ESI</span><br><span class="line">	JMP CONTINUE</span><br></pre></td></tr></tbody></table></figure>
<h4 id="乘法指令">乘法指令</h4>
<p><code>MUL OPRD</code> 是无符号乘法，其中操作数只能来自寄存器或者内存。表达的意思是，将 <code>OPRD</code> 乘以</p>
<ul>
<li>AL，存入 AX</li>
<li>AX，存入 DX:AX</li>
<li>EAX，存入 EDX:EAX</li>
</ul>
<p>也就是说，运算结果是操作数的两倍，隐藏的操作数由 <code>OPRD</code> 决定。<strong>标志位的影响也比较特殊，只关注 CF 和 OF 标志</strong>，如果隐藏的操作数存不下，需要 AH 或 DX 或者 EDX 存储结果时，CF=1,OF=1。否则 CF=0,ZF=0。</p>
<p><code>IMUL OPRD</code> 的用法完全一样，只是把操作数当作有符号整数。但是由于带符号数都会进行符号扩展，所以判断有些复杂。</p>
<p><strong>增加判断的例题！！！！！！</strong></p>
<p>32 位下，<code>IMUL</code> 指令增加了操作数的形式。</p>
<ul>
<li><code>IMUL DEST, SRC </code> 表示 <code>DEST&lt;=(DEST)×(SRC)</code></li>
<li><code> IMUL DEST, SRC1, SRC2</code> 表示 <code>DEST&lt;=(SRC1) ×(SRC2) </code>。</li>
</ul>
<h4 id="除法指令">除法指令</h4>
<p>除法指令中只给出除数，而被除数和商、余数都为隐含。存储的位置和乘法是对应的。因为被除数长度必须是除数长度的两倍，因此常常需要和扩展指令 <code>CBW</code> <code>CWD</code> <code>CDQ</code> 配合使用。</p>
<table>
<thead>
<tr>
<th><strong>被除数</strong></th>
<th><strong>除数</strong></th>
<th><strong>商</strong></th>
<th><strong>余数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>AX</td>
<td>reg8/mem8</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td>DX:AX</td>
<td>reg16/mem16</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr>
<td>EDX:EAX</td>
<td>reg32/mem32</td>
<td>EAX</td>
<td>EDX</td>
</tr>
</tbody>
</table>
<p>拓展指令是<strong>零操作数指令，隐含的地址为 AX, DX,EAX,EDX</strong>。</p>
<p>CBW(Convert Byte to Word) 表示字节拓展到字，也就是说</p>
<ul>
<li>若 AL 最高位=1，则执行后 AH=FFH</li>
<li>若 AL 最高位=0，则执行后 AH=00H</li>
</ul>
<p>CWD(Convert Word to Doubleword) 也是完全类似的：</p>
<ul>
<li>若 AX 最高位=1，则执行后 DX=FFFFH</li>
<li>若 AX 最高位=0，则执行后 DX=0000H</li>
</ul>
<p>CDQ(Convert Doubleword to Quadword) 表示双字拓展成四字，只是从 DX 变成了 EDX。</p>
<h4 id="BCD-码调整指令">BCD 码调整指令</h4>
<p>BCD 码调整指令是一组用于将二进制码转换为二进制编码十进制（BCD）码的指令。BCD 码是一种用于表示十进制数的二进制编码形式，使用四位二进制数表示一位十进制数。</p>
<p>BCD 码分为压缩型和非压缩型，压缩型一个字节表示 2 个 BCD 码，比如 0010 0011 表示十进制的 23。</p>
<img src="http://cdn.blog-blockchain.xyz/202304261102698.png" alt="image-20230426110208453" style="zoom:67%;">
<p>非压缩型只看一个字节的低四位表示的 BCD 码，忽略高 4 位，常为 0000 或 0011。比如 0000 1001 与 0011 1001 都是十进制数 9 的非压缩型 BCD 码</p>
<img src="http://cdn.blog-blockchain.xyz/202304261103594.png" alt="image-20230426110350424" style="zoom:67%;">
<p>BCD 码的运算过程可以将转化成二进制运算，然后再把二进制的结果转化成 BCD 码。但是这样效率比较低，8086 使用的是直接使用 BCD 码参与二进制运算，然后用指令将结果校正成 BCD 码。</p>
<p>这里我们了解一下即可，记住指令和全称表达的意思。</p>
<ol>
<li>DAA（Decimal Adjust AL after Addition）：用于在将两个<strong>十进制数</strong>相加后，调整 AL 中存储的 BCD 码结果。</li>
<li>AAA（ASCII Adjust AL after Addition）：用于在将两个<strong>ASCII 码数</strong>相加后，调整 AL 中存储的二进制码结果。</li>
<li>DAS（Decimal Adjust AL after Subtraction）：用于在将两个十进制数相减后，调整 AL 中存储的 BCD 码结果。</li>
<li>AAS（ASCII Adjust AL after Subtraction）：用于在将两个 ASCII 码数相减后，调整 AL 中存储的二进制码结果。</li>
<li>AAM（ASCII Adjust AX after Multiply）：用于在将两个 ASCII 码数相乘后，调整 AX 中存储的二进制码结果，将其转换为两个十进制数的积。</li>
<li>AAD（ASCII Adjust AX before Division）：用于在将两个 ASCII 码数相除前，将 AX 中存储的二进制码结果转换为两个十进制数的商和余数。</li>
</ol>
<h3 id="逻辑运算">逻辑运算</h3>
<p><code>NOT</code> 指令<strong>不会影响标志位</strong>，但是其他逻辑运算指令都会使<strong>OF=CF=0</strong>，SF ZF PF 根据结果确定。<code>AND</code> <code>OR</code> <code>XOR</code> 都是逻辑指令，<code>TEST</code> 则特殊，只是修改标志位不实际写入目标位置。</p>
<p>例如：从地址为 3F8H 端口中读入一个字节数，如果该数 bit1 位为 1，则将 DATA 为首地址的一个字输出到 38FH 端口，否则就不能进行数据传送。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	LEA ESI, DATA</span><br><span class="line">	MOV DX, 3F8H</span><br><span class="line">WAIT:</span><br><span class="line">	IN AL, DX</span><br><span class="line">	AND AL, 02H</span><br><span class="line">	JZ WAIT</span><br><span class="line"></span><br><span class="line">	MOV DX, 38FH</span><br><span class="line">	MOV AX, [ESI]</span><br><span class="line">	OUT DX, AX</span><br></pre></td></tr></tbody></table></figure>
<p>例如：将一个 8 位二进制数 9 变为字符‘9’（57=39H=0011 1001B），9=1001H，所以 <code>OR  AL '9'</code> 这样就可以实现。</p>
<p>例如：从地址为 3F8H 的端口中读入一个字节数，当该数的 bit1， bit3， bit5 位同时为 1 时，则从 38FH 端口将 DATA 为首地址的一个字输出，否则就从端口重新输入。</p>
<p>分析可以知道，AND 0010 1010B，如果结果是这个数，那么就符合要求。这就要使用到减法指令中的 <code>CMP</code>，对应的有符号数大于用 <code>JG</code>，无符号数 <code>JA</code>，相等都是 <code>JZ</code>。另外一种办法是，AND 之后看结果是否 3 个 1 都有，可以用 <code>XOR</code> 实现。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	LEA ESI, DATA</span><br><span class="line">	MOV DX, 38FH</span><br><span class="line">WAIT:</span><br><span class="line">	IN AL, DX</span><br><span class="line">	CMP AL, 2AH</span><br><span class="line">	JZ WAIT</span><br><span class="line"></span><br><span class="line">	MOV DX, 38FH</span><br><span class="line">	MOV AX, [ESI]</span><br><span class="line">	OUT DX, AX</span><br></pre></td></tr></tbody></table></figure>
<h3 id="移位指令">移位指令</h3>
<p>移位的标志位一般只考虑 CF，<strong>CF 标志是这次操作移出的那一位</strong></p>
<p>移位指令的次数，<strong>只能由 CL 或者 8 位立即数指定</strong>。<code>SAL  OPRD，CL/imm8</code> (Shift Arithmetic Left)一般用于带符号数，右边补 0，注意<strong>左移在小端序中实际是向高地址方向移动，在大端序中是向低地址移动</strong>。<code>SHL</code>(Shift Logical Left)实际上也是相同的。</p>
<p>对应的，右移也分为 <code>SAR</code> 和 <code>SHR</code>，分别用于带符号数和无符号数。</p>
<p>也有循环移位指令，对标志位修改和其他移位指令一样，但是 <code>ROL</code>（Rotate Left） <code>ROR</code>（Rotate Right） 指令是不带进位的循环移位，相当于操作数转圈。<code>RCL</code> <code>RCR</code> 则是把 CF 也作为数字的一部分，开始移位。比如 <code>0100 1101</code> ,初始 CF=1</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果是ROR:</span><br><span class="line">ROR：`0010 0110` CF=1</span><br><span class="line">ROR: `0001 0011`，CF=0</span><br><span class="line">如果是RCR:</span><br><span class="line">ROR：`1010 0110` CF=1</span><br><span class="line">ROR: `1101 0011`，CF=0</span><br></pre></td></tr></tbody></table></figure>
<h3 id="串操作指令">串操作指令</h3>
<p>串操作实际上就是循环处理，但是自动修改 ESI 和(或)EDI，使其指向下一个单元。注意，DF=0 则地址增加，DF=1 则地址减小。循环计数的寄存器 ECX 也会对应减少。这样的操作，会通过「重复前缀」实现，前缀的意思就是它放在其他指令的前面，修饰这条指令，在满足条件下重复指令。<strong>重复前缀修改 ECX 不修改标志位</strong>。</p>
<ul>
<li>REP: ECX 不为 0 就重复。</li>
<li>REPE 和 REPZ：则是增加了条件 ZF=1，才重复。分别用于判断字符串相等和字符串为 0.</li>
</ul>
<p><strong>MOVS 这类指令可以使用 MOVSB、MOVSW、MOVSD，这样指定长度就不需要操作数，默认了操作数来源。同理，CMPS、SCAS 也是这样</strong></p>
<p>例子：用 MOVS 指令实现将 200 个字节数据从 MEM1 开始的一个内存区送到另一个从 MEM2 开始的区域的程序段</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LEA  ESI，MEM1</span><br><span class="line">LEA  EDI，MEM2</span><br><span class="line">MOV  ECX，200</span><br><span class="line">CLD</span><br><span class="line">REP  MOVSB</span><br><span class="line">HLT</span><br></pre></td></tr></tbody></table></figure>
<p>例子：比较两组(200 个字节)对应数据，找出第一个不同数据放入 AL，其地址放入 EBX。<code>CMPS</code> 相当于 字符串相减<code>src - dst</code>，影响标志位。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LEA  ESI，MEM1</span><br><span class="line">LEA  EDI，MEM2</span><br><span class="line">MOV  ECX，200</span><br><span class="line">CLD</span><br><span class="line">REPE CMPSB ;在ECX不为零且[ESI]等于[EDI]的情况下，重复执行以下操作：比较[ESI]和[EDI]指向的字节，递增ESI和EDI，递减ECX。</span><br><span class="line">JZ  STOP</span><br><span class="line">DEC  ESI</span><br><span class="line">MOV  AL，[ESI]</span><br><span class="line">MOV  EBX，ESI</span><br><span class="line">STOP：HLT</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>例子：<code>SCAS</code>（Scan String Byte） 则是根据长度和 AL/AX/EAX - [EDI]，32 位下时双字。只影响标志位。在内存块中搜索特定的字节值（在本例中为 0x42）</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">; 初始化寄存器</span><br><span class="line">MOV EDI, OFFSET MemoryBlock ; 设置EDI指向内存块的起始位置</span><br><span class="line">MOV ECX, 1000               ; 设置要搜索的字节数（1000字节）</span><br><span class="line">MOV AL, 0x42                ; 设置要查找的值（0x42）</span><br><span class="line">CLD                         ; 清除DF标志，使EDI递增</span><br><span class="line"></span><br><span class="line">; 使用REPNE和SCASB指令进行搜索</span><br><span class="line">REPNE SCASB</span><br><span class="line"></span><br><span class="line">; 检查搜索结果</span><br><span class="line">JNE NotFound                ; 如果ZF=0，表示没有找到目标值，跳转到NotFound标签</span><br><span class="line">DEC EDI                      ; 如果找到目标值，将EDI减1以获取正确的内存地址</span><br><span class="line"></span><br><span class="line">; 在此处处理找到的值，EDI指向找到的值的内存地址</span><br><span class="line">; ...</span><br><span class="line"></span><br><span class="line">NotFound:</span><br><span class="line">; 在此处处理未找到目标值的情况</span><br><span class="line">; ...</span><br><span class="line"></span><br><span class="line">MemoryBlock:</span><br><span class="line">DB 0x11, 0x22, 0x33, 0x42, 0x55, 0x66, 0x77, 0x88, 0x99 ; 内存块数据</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><code>LODS</code>（Load String）指令从[ESI]加载字符串到 AL、AX、EAX，显然<strong>LODS 指令加重复前缀无意义。</strong></p>
<p><code>STOS</code>（Store String）则是相反的，从 AL、AX、EAX 加载字符串到[EDI]。</p>
<p>例如：将累加器中的值（假设为<code>AL</code>）存储到目标地址为<code>destination</code>的字符串中，共存储<code>length</code>次：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV ECX, length     ; 设置要存储的次数</span><br><span class="line">MOV EDI, destination ; 设置目标字符串的起始地址</span><br><span class="line">MOV AL, value       ; 设置要存储的值</span><br><span class="line">CLD                 ; 清除方向标志，使 DI 递增</span><br><span class="line">REP STOSB           ; 重复执行 STOSB，直到存储了 length 个值</span><br></pre></td></tr></tbody></table></figure>
<h3 id="程序控制指令">程序控制指令</h3>
<p>转移指令主要由下面几种：</p>
<ul>
<li>JMP OPRD：它是无条件转移，从下一条指令开始计算偏移量。实际使用可以 <code>JMP Label</code> 即可。但是如果是 <code>JMP EBX</code> 这样 32 位的数据，就是直接跳转到 EBX 的位置。</li>
</ul>
<p>标志位：</p>
<ul>
<li>JC：CF 为 0 跳转。</li>
<li>JZ：ZF 为 0 跳转。</li>
<li>JO：OF</li>
<li>JP：PF</li>
</ul>
<p>比较类：</p>
<ul>
<li>JA、JB、JAE、JBE：是无符号数，接在 CMP 后面。</li>
<li>JG、JL：是有符号数，也是 CMP 后面。</li>
</ul>
<p>CX/ECX：</p>
<ul>
<li>JCXZ、JECXZ：根据 CX、ECX 跳转。</li>
</ul>
<p>例题：统计内存数据段中以 TABLE 为首地址的 100 个 8 位有符号数中正数、负数和零的个数。LOOP 是自动 ECX-1 得控制流指令，ECX=0 是退出。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">.DATA</span><br><span class="line">TABLE   DB   100 DUP (?) ; 100个8位有符号数（您需要手动设置这些数值）</span><br><span class="line">posCount    DD   0 ; 正数计数器</span><br><span class="line">negCount    DD   0 ; 负数计数器</span><br><span class="line">zeroCount   DD   0 ; 零计数器</span><br><span class="line"></span><br><span class="line">.CODE</span><br><span class="line">main PROC</span><br><span class="line">    ; 设置计数器</span><br><span class="line">    MOV ECX, 100</span><br><span class="line"></span><br><span class="line">    ; 设置源字符串的起始地址</span><br><span class="line">    LEA ESI, TABLE</span><br><span class="line"></span><br><span class="line">    ; 清除方向标志，使 ESI 递增</span><br><span class="line">    CLD</span><br><span class="line"></span><br><span class="line">CountLoop:</span><br><span class="line">    ; 加载下一个字节</span><br><span class="line">    LODSB</span><br><span class="line"></span><br><span class="line">    ; 检查零</span><br><span class="line">    OR AL, AL</span><br><span class="line">    JZ ZeroFound</span><br><span class="line"></span><br><span class="line">    ; 检查正数</span><br><span class="line">    JS NegativeFound</span><br><span class="line">    ; 如果是正数</span><br><span class="line">    ADD DWORD PTR posCount, 1</span><br><span class="line">    JMP ContinueLoop</span><br><span class="line"></span><br><span class="line">NegativeFound:</span><br><span class="line">    ; 如果是负数</span><br><span class="line">    ADD DWORD PTR negCount, 1</span><br><span class="line">    JMP ContinueLoop</span><br><span class="line"></span><br><span class="line">ZeroFound:</span><br><span class="line">    ; 如果是零</span><br><span class="line">    ADD DWORD PTR zeroCount, 1</span><br><span class="line"></span><br><span class="line">ContinueLoop:</span><br><span class="line">    ; 继续循环</span><br><span class="line">    LOOP CountLoop</span><br><span class="line"></span><br><span class="line">    ; ... 其他代码 ...</span><br><span class="line">    ; 程序结束</span><br><span class="line">    ret</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
<h3 id="过程调用">过程调用</h3>
<p>flat 模式下过程调用是 EIP 压栈，然后入口送入 EIP 中。子过程执行之后 RET 返回原程序</p>
<h2 id="汇编程序基础">汇编程序基础</h2>
<p>在汇编中，指令的基本格式如下，标号就之前 <code>NEXT</code> 这样的东西，用来表示这个语句的位置，注意不要和保留字冲突。指令助记符就是指令名字，操作数表示可以多次出现，注释也可以多次出现。</p>
<img src="http://cdn.blog-blockchain.xyz/202305102346732.png" alt="image-20230510234620668" style="zoom:50%;">
<p>除了之前学过的指令还有伪指令，它们不是 CPU 可以直接执行的指令，而是为了方便编写程序的一些指令，编译器或者汇编器会进行处理，按照伪指令的逻辑，生成代码。一些常见的伪指令示例包括：</p>
<ul>
<li><code>DB</code>：定义一个或多个字节的数据。</li>
<li><code>DW</code>：定义一个或多个字的数据。</li>
<li><code>DD</code>：定义一个或多个双字的数据。</li>
<li><code>EQU</code>：为一个值或地址分配一个符号名称。</li>
<li><code>END</code>：标记程序的结束。</li>
</ul>
<p>还有多行注释，<code>@</code> 是自定义符号，注释中不能出现，否则会造成矛盾。：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COMMENT @</span><br><span class="line">这是多行注释。</span><br><span class="line">@</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数据定义">数据定义</h3>
<p>汇编中的字面常量，数字一般是十进制，<code>1101B</code> <code>aef4H</code> 这些根据后缀指定二进制或者十六进制。字符串是用单引号和双引号都可以，字符用单引号，都是 ASCII 码表示。</p>
<p>变量会定义数据的类型，主要是指变量的长度。一般用缩写即可，都是 <code>Define Byte/Word/Doubleword</code>，对应<code>DB/DW/DD</code>。变量一般会放在数据区，比如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.DATA</span><br><span class="line">DATA1    BYTE   12H</span><br><span class="line">DATA2    DB      20H,30H</span><br><span class="line">DATA3    WORD    5678H</span><br><span class="line">DATA4  DB ?,?,?</span><br><span class="line">DATA5	DB "abcdse"</span><br></pre></td></tr></tbody></table></figure>
<img src="http://cdn.blog-blockchain.xyz/202305110026190.png" alt="Untitled" style="zoom: 60%;">
<p>变量名表示在数据区（段）内的偏移量，比如 <code>DATA1</code> 表示 0。一个变量也可以表示一个数组，比如 <code>20H,30H</code> 用逗号分隔，表示两个字节元素的数组。如果是 <code>?</code> 表示不初始化。字符串会自动解析成对应类型。</p>
<p>关于字符串的字面常量，需要注意除了 byte 类型，元素长度必须不大于类型长度，而且内存布局是小端序。如果元素比较短，那么高位自动填充 0。比如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DATA1	DB "abcdse"</span><br><span class="line">; 'a' 'b' 'c' 'd' 's' 'e'</span><br><span class="line">DARA2 DW "abcds";报错，元素长度不匹配。</span><br><span class="line">DARA3 DW "abc","ds"	;报错，"abc"超过了一个字。</span><br><span class="line">DARA3 DW "ab","cd","s"</span><br><span class="line">;'b' 'a' 'd' 'c' 'e' s '0'</span><br><span class="line">DARA3 DD "abcd"</span><br><span class="line">;'d' 'c' 'b' 'a'</span><br></pre></td></tr></tbody></table></figure>
<p>为了方便创建数组，甚至复杂的数据，提出了 <code>DUP</code> 伪指令，注意<code>重复次数+DUP(元素字面量)</code> 是一组的。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;基本语法：变量名+类型+重复次数+DUP(需要重复的元素的字面量)</span><br><span class="line">DATA1  DB   10H  DUP(?)	;重复了10H个未初始化的字节。</span><br><span class="line">DATA_B  DB   20H  DUP(‘AB’);重复20H个 "AB"</span><br><span class="line"></span><br><span class="line">;4 DUP(2)表示 2,2,2,2然后一起组成 10H DUP(2,2,2,2,7),</span><br><span class="line">DATA_C   DB   10H  DUP(4  DUP(2),7)</span><br></pre></td></tr></tbody></table></figure>
<p>局部变量在子程序中定义，默认 <code>dword</code> 类型，基本语法<code>local 变量名[元素个数] :类型</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Local var1[1024]:byte ;定义了一个1024字节长的局部变量lvar1</span><br><span class="line">Local var3,var4:byte ;定义了dword型局部变量var3,byte型局部变量var4</span><br></pre></td></tr></tbody></table></figure>
<p>使用变量时，变量表示地址，但是直接引用变量，是提取地址里面的内容。变量也可以相对寻址，写入特定的位置，比如 <code>MOV  DA3[ESI]，AL</code>。特别是在 <code>MOV</code> 指令中，赋值长度一般由寄存器决定。</p>
<h3 id="标号和符号定义">标号和符号定义</h3>
<p>给语句的标号，实际上有一些属性。当使用 <code>::</code> 而不是 <code>:</code> 时表示全局标号。而且放在指令前面是，是 <code>NEAR</code> 类型标号，只能段内转移，段外要调用，要用 <code>标号名字 NEAR FAR</code>，而且不用冒号，下一条指令换行写。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUB1_FAR    LABEL    FAR</span><br><span class="line">SUB1:  MOV  AX,30H</span><br></pre></td></tr></tbody></table></figure>
<p>而且标号可以设置别名，改变变量属性。使用 <code>DATA_BYTE</code> 就可以把下面的 <code>DATA_WORD</code> 变量当作 byte 类型用了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DATA_BYTE   LABEL  BYTE</span><br><span class="line">DATA_WORD  DW  20H  DUP(?)</span><br></pre></td></tr></tbody></table></figure>
<p><code>EQU</code> 伪指令相当于宏定义，编译时直接替换，所以指代必须唯一。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">COUNT  EQU  5</span><br><span class="line">STR1 EQU “ABCD”</span><br><span class="line">CBD     EQU  DAA; 指令别名</span><br><span class="line">CREG  EQU  CX;CREG等价与CX</span><br><span class="line">NUM    EQU  COUNT+5</span><br><span class="line">ADR1  EQU  DS:[EBP+14];在DS数据段中以BP作基址寻址的一个存储单元。</span><br></pre></td></tr></tbody></table></figure>
<p><code>=</code> 类似 EQU，但是只能是一些字面量的别名。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONT=5</span><br><span class="line">NUM=14H</span><br><span class="line">NUM=NUM+10H</span><br></pre></td></tr></tbody></table></figure>
<h3 id="表达式和变量修饰符">表达式和变量修饰符</h3>
<p><code>+、—、＊、 / 、MOD、SHL、SHR、[ ]</code> 这些表达式时汇编器自己定义的，也会由汇编器编译成字节码，用于方便编程程序。需要注意，<code>SHR</code> <code>SHL</code> 是中缀运算符，用于表示<strong>常量移位</strong>临时的计算结果，结果相当于立即数。<code>[]</code>则是表示相加，<code>MOV AX，DA_WORD[20H]</code> 相当于 <code>MOV AX，DA_WORD+20H</code>，但是方括号外的加法是不允许的，比如 <code>ARRAY+EBX[ESI]</code>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NUM=11011011B</span><br><span class="line">MOV   AX , NUM SHL  1</span><br><span class="line">MOV   BX ,  NUM SHR 2</span><br><span class="line">ADD   DX ,  NUM SHR 6</span><br></pre></td></tr></tbody></table></figure>
<p><code>NOT、AND、OR、XOR</code> 这些逻辑运算符，除了 <code>NOT</code> 是前缀，其他都是中缀，也是用于常量，返回立即数。</p>
<p><code>EQ（等于）、NE（不等于）、LT（小于）、 LE（小于等于）、GT（大于）、 GE（大于等于）</code> 这些关系运算符都是中缀，返回值要么全 1 表示真，要么全 0 表示假。</p>
<p>还有一些提取变量信息的运算符，也是相当于返回立即数。</p>
<ul>
<li><code>SEG</code> 是<strong>16 位</strong>下使用的返回变量段标号的，我们基本不会用到。</li>
<li><code>OFFSET</code> 则常用很多，提取变量的地址。<strong>OFFSET 无法获取寄存器值，所以 OFFSET ADDR[ESI]是错误的</strong>。</li>
<li><code>TYPE</code> 会返回变量的类型的长度。</li>
<li><code>LENGTH</code> 专门用于提取 <code>DUP</code> 的重复次数，是最外层的第一个 DUP。如果第一个元素不是 DUP，那么为 1.</li>
<li><code>LENGTHOF</code> 则是变量按照类型长度去数，有多少个元素。注意下面的变量，可以没有变量名。</li>
<li><code>SIZE</code>则是纯一层 DUP 定义数组的大小，LENGTH 和 TYPE 的乘积。实际编程我们不用它。</li>
<li><code>SIZEOF</code> 则有用很多，表示变量的大小，等于 LENGTHOF 和 TYPE 返回值的乘积</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K1  DB   10H DUP(0), 20H</span><br><span class="line">K2  DB    10H，20H，30H，40H</span><br><span class="line">DB   50H, 60H</span><br><span class="line">K3  DW  20H DUP(0,1,2 DUP(0))</span><br><span class="line">K4  DB   ‘ABCDEFGH’</span><br></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th>变量</th>
<th>TYPE</th>
<th>LENGTH</th>
<th>LENGTHOF</th>
<th>SIZE</th>
<th>SIZEOF</th>
</tr>
</thead>
<tbody>
<tr>
<td>K1</td>
<td>1</td>
<td>10H</td>
<td>11H</td>
<td>10H</td>
<td>11H</td>
</tr>
<tr>
<td>K2</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>K3</td>
<td>2</td>
<td>20H</td>
<td>80H</td>
<td>40H</td>
<td>100H</td>
</tr>
<tr>
<td>K4</td>
<td>1</td>
<td>1</td>
<td>8</td>
<td>1</td>
<td>8H</td>
</tr>
</tbody>
</table>
<p>在赋值时，有时候还可以手动指定类型长度 <code>类型+PTR+变量名</code>，相当于在使用时类型转换了。但是很多时候汇编器会根据寄存器的长度，推理出赋值的长度。</p>
<p>为了拆分一个字的<strong>常数</strong>，<code>HIGH/LOW</code> 修饰符就可以获得一个字的高 8 位和低 8 位。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONST  EQU   ABCDH</span><br><span class="line">MOV   AH ,HIGH  CONST</span><br><span class="line">MOV   AL, LOW  CONST</span><br></pre></td></tr></tbody></table></figure>
<h3 id="过程定义">过程定义</h3>
<p>主要学习定义子程序的语法，子过程的名字可以用 CALL 或者 INVOKE 调用，之后是可见属性三选一，一个模块类似于一个 C++类。寄存器列表，将会在编译过程增加指令，将这些寄存器自动压栈，ret 前自动出栈。比如<code>PROC USES EAX ECX</code>，先当于<code>PUSH EAX PUSH ECX   POP ECX POP EAX</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">子程序名字 PROC [PRIVATE/PUBLIC/EXPORT] [USES 使用的寄存器列表]</span><br><span class="line">LOCAL 局部变量定义</span><br><span class="line">指令</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">子过程名字 ENDP</span><br></pre></td></tr></tbody></table></figure>
<p><code>RET</code> 指令实际上从堆栈中弹出一个值，并将程序计数器（PC）设置为该值，从而将执行流程跳转到该地址。<code>RET n</code> 是 <code>RET</code> 指令的一个变体，其中 <code>n</code> 是一个立即数，表示在从子程序返回之后，还需要从堆栈中移除的字节数。这用于清除主程序调用子程序时，压入的参数。</p>
<h3 id="程序结构">程序结构</h3>
<ul>
<li><code>.386</code> 指定指令集。</li>
<li><code>.MODEL</code> 指定内存模式，比如 flat 模式，语言模式，比如 API 调用。</li>
<li><code>OPTION</code> 设定语句定义，必须大小写不敏感等等。</li>
<li><code>INCLUDE</code> 是头文件，<code>INCLUDELIB</code> 包含库文件。</li>
<li><code>ExitProcess PROTO, dwExitCode:DWORD</code> 部分程序在 <code>.DATA</code> 之前，需要声明用到的 API 函数，格式是 <code>函数名字 PROTO, 参数:类型</code>，但是也可以直接 <code>INCLUDE</code> 头文件，就不用手动声明了。</li>
<li><code>.CONST</code> 是常量，只读不可写。之后就是代码的部分，格式基本固定的。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">OPTION casemap:none</span><br><span class="line">;  &lt;一些include语句&gt;</span><br><span class="line">INCLUDE user32.inc</span><br><span class="line">INCLUDE kernel32.inc</span><br><span class="line">INCLUDELIB user32.lib</span><br><span class="line">INCLUDELIB kernel32.lib</span><br><span class="line">.STACK [堆栈段的大小]</span><br><span class="line">.DATA</span><br><span class="line">;  &lt;一些初始化过的变量定义&gt;</span><br><span class="line">.DATA?</span><br><span class="line">;  &lt;一些没有初始化过的变量定义&gt;</span><br><span class="line">.CONST</span><br><span class="line">;  &lt;一些常量定义&gt;</span><br><span class="line">.CODE</span><br><span class="line">main PROC</span><br><span class="line">;     &lt;其他语句&gt;</span><br><span class="line">main  ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
<p>可以在代码中调用库函数，<code>invoke  函数名[，参数1][，参数2]……</code> 比如 <code>invoke ExitProcess,NULL</code>。</p>
<p><code>$</code> 表示位置计数器，实际上就是当前位置的地址，这就方便计算偏移量，比如某些变量的长度等。<code>ORG 数值表达式</code> 可以设置 $ 的值，这样可以在任意位置写入，也可以保留一部分未使用的内存。</p>
<h3 id="Windows-的输入输出">Windows 的输入输出</h3>
<p>课程使用的是封装好的 Win32 SDK，叫做 Irvine32.LIB，<strong>函数调用不带参数，而是寄存器传参数</strong>。</p>
<p>例如：编程实现从键盘输入 16 进制数，然后以二进制形式显示输出。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO,dwExitCode:DWORD</span><br><span class="line">INCLUDE Irvine32.inc</span><br><span class="line">INCLUDELIB Irvine32.lib</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">	call ReadHex     ;输入16进制数</span><br><span class="line">	call WriteBin     ;输出二进制数</span><br><span class="line">	INVOKE ExitProcess, 0</span><br><span class="line">main ENDP</span><br><span class="line">END  main</span><br></pre></td></tr></tbody></table></figure>
<p>简单了解一下一些函数：</p>
<ol>
<li><code>ReadChar</code> 从键盘读取一个字符， 它的 ASCII 码存在 AL，一些特殊键就为 0.</li>
<li><code>ReadDec</code> 从键盘读取 32 bit 无符号十进制整数，存在 EAX</li>
<li><code>ReadHex</code> 32bit 十六进制整数</li>
<li><code>ReadInt</code> 32 bit 有符号整数，第一个字符可以是 <code>+</code> <code>-</code></li>
<li><code>ReadKey</code> 检查键盘输入缓冲区，如果没有有按键数据则 ZF=1，有则 ZF=0，且存入 AL</li>
<li><code>ReadString</code> 从键盘读取一个字符串，直到用户键入回车键。EDX 是存储的变量的地址，ECX 是最大读取长度+1，读取的字符串末尾有 NULL。</li>
</ol>
<p>输出函数：</p>
<ul>
<li><code>WirteBin</code> EAX 的值二进制打印。</li>
<li><code>WirteBinB</code> EAX 的值，按照 EBX1,2,4 这样，显示 1，2，4 个字节。</li>
<li><code>WriteChar</code></li>
<li><code>WriteDec</code></li>
<li><code>WriteHex</code> 注意这个会补前置 0</li>
<li><code>WriteHexB</code></li>
<li><code>WriteInt</code></li>
<li><code>WriteString</code> 从 EDX 里面的地址开始，一直打印到表示结束的 0</li>
</ul>
<h2 id="程序设计基础">程序设计基础</h2>
<p>例题 1：输入学号查学生的数学成绩，成绩按照学号顺序排列，每个字节一个成绩。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">INCLUDE Irvine.inc</span><br><span class="line">INCLUDELIB Irvine32.lib</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">table DB 81, 78, 90, 64, 85, 76, 93, 82, 57, 80</span><br><span class="line">	DB   73, 62, 87, 77, 74, 86, 95, 91, 82, 71</span><br><span class="line">math DB ?</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">xor eax eax</span><br><span class="line">call ReadDec</span><br><span class="line">lea ebx table</span><br><span class="line">dec ebx</span><br><span class="line">and eax 0FH</span><br><span class="line">mov al, eax[ebx]</span><br><span class="line">mov math al</span><br><span class="line">call WriteDec</span><br><span class="line">invoke ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
<p>例题 2：数据段的 ARY 数组中存放有 10 个无符号数，试找出其中最大者送入 MAX 单元。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">ARY    DB     17,5,40,0,67,12,34,78,32,10</span><br><span class="line">MAX    DB   ?</span><br><span class="line">.code</span><br><span class="line">main PROC</span><br><span class="line">    LEA ESI, ARY</span><br><span class="line">    MOV AL, [ESI]</span><br><span class="line">    MOV ECX, 9</span><br><span class="line">    INC ESI</span><br><span class="line"></span><br><span class="line">NEXT:</span><br><span class="line">	CMP AL, [ESI]</span><br><span class="line">	JL SETMAX</span><br><span class="line">CONTINUE:</span><br><span class="line">	INC ESI</span><br><span class="line">	DEC ECX</span><br><span class="line">	JNZ NEXT</span><br><span class="line">	JMP ASSIGN</span><br><span class="line">SETMAX:</span><br><span class="line">	MOV AL, [ESI]</span><br><span class="line">	JMP CONTINUE</span><br><span class="line">ASSIGN:</span><br><span class="line">	MOV MAX, AL</span><br><span class="line"></span><br><span class="line">	INVOKE ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
<p>例题 3：设有两个数组 X 和 Y，它们都有 8 个元素，其元素按下标从小到大的顺序存放在数据段中。完成下列计算：Z1=X1+Y1 Z2=X2-Y2 Z3=X3+Y3 , Z4=X4-Y4 Z5=X5-Y5 Z6=X6+Y6, Z7=X7+Y7 Z8=X8-Y8</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">.STACK  4096</span><br><span class="line">ExitProcess PROTO,dwExitCode:DWORD</span><br><span class="line">.DATA</span><br><span class="line">X  DB 0A2H,7CH,34H,9FH,0F4H,10H,39H,5BH</span><br><span class="line">Y  DB 14H,05BH,28H,7AH,0EH,13H,46H,2CH</span><br><span class="line">Z DB 8 DUP(?)</span><br><span class="line">ADDSUB DB 10011010B	;0表示+，1表示-</span><br><span class="line">.CODE</span><br><span class="line">	MOV ECX 8</span><br><span class="line">	MOV ESI 0</span><br><span class="line">	MOV BL, ADDSUB</span><br><span class="line">LOP:</span><br><span class="line">	MOV AL, [ESI+X]</span><br><span class="line">	SHR BL,1;设置CF</span><br><span class="line">	JC SUB1	;CF=1</span><br><span class="line">	;加法</span><br><span class="line">	ADD AL,[ESI+Y]</span><br><span class="line">	JMP CONTINUE</span><br><span class="line">SUB1:</span><br><span class="line">	SUB AL [ESI+Y]</span><br><span class="line">CONTINUE:</span><br><span class="line">	MOV[Z+ESI],AL</span><br><span class="line">	INC ESI</span><br><span class="line">	LOOP LOP;相当于ECX自减，然后不为0继续跳转LOP</span><br><span class="line"></span><br><span class="line">	INVOKE ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
<p>例题 4：编写一程序，将字单元 VARW 中含 1 的个数(含 1 的个数是指用二进制表示时,有多少个 1)统计出来，存入 CONT 单元中。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">.STACK  4096</span><br><span class="line">ExitProcess PROTO,dwExitCode:DWORD</span><br><span class="line">.DATA</span><br><span class="line">VARW DW 1101010010001000B</span><br><span class="line">CONT DB ?</span><br><span class="line">.CODE</span><br><span class="line">main PROC</span><br><span class="line">	MOV AX VARW</span><br><span class="line">	MOV ECX 0</span><br><span class="line">LOP:</span><br><span class="line">	SHR AX,1</span><br><span class="line">	JC COUNT	;CF=1</span><br><span class="line">CONTINUE:</span><br><span class="line">	TEST AX, FFFFH;判断AX全0</span><br><span class="line">	JNZ LOP</span><br><span class="line">	JMP END0</span><br><span class="line"></span><br><span class="line">COUNT:</span><br><span class="line">	INC ECX</span><br><span class="line">	JMP CONTINUE</span><br><span class="line">END0:</span><br><span class="line">	MOV COUNT AL</span><br><span class="line">	INVOKE ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
<h3 id="子程序">子程序</h3>
<p>在前面我们通过例子，学习了一般的顺序、分支、循环结构应该如何处理，这里学习如何使用子程序。最直接的方法就是寄存器传参，直接 call，子程序和写 <code>main</code> 是一样的，但是开始需要 PUSHAD，ret 前需要 POPAD。</p>
<p>比如下面的例子就是将 0-9 中的一位数，转换成二进制。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">buffer8 DB 0 ; 存储转换后的ASCII字符</span><br><span class="line">NUM1 DB 7</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">bin8ToAscii PROC</span><br><span class="line">	PUSHAD</span><br><span class="line">    ADD AL, '0' ; 转换为ASCII字符</span><br><span class="line">    MOV buffer8, AL ; 将ASCII字符存储在缓冲区中</span><br><span class="line">	POPAD</span><br><span class="line">    RET</span><br><span class="line">bin8ToAscii ENDP</span><br><span class="line"></span><br><span class="line">main PROC</span><br><span class="line">    MOV AL, NUM1 ; 示例8位数 (范围0-9)</span><br><span class="line">    CALL bin8ToAscii ; 转换8位数</span><br><span class="line"></span><br><span class="line">    ; 在此处，buffer8包含转换后的ASCII字符</span><br><span class="line">    ; 可以在这里继续操作，例如打印输出等</span><br><span class="line"></span><br><span class="line">    INVOKE ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
<p>还可以地址传参，就是把需要的变量的地址，全部放在全局变量里，然后把全局变量地址放在 EBX，子程序再从 EBX 获取。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">NUM1 DB 7</span><br><span class="line">buffer8 DB 0 ; 存储转换后的ASCII字符</span><br><span class="line">ADR DD 0</span><br><span class="line">.code</span><br><span class="line">bin8ToAscii PROC</span><br><span class="line">	PUSHAD</span><br><span class="line">	MOV EDI,[EBX] ;取全局变量值，也就是需要用到的变量的地址</span><br><span class="line">	MOV AL,[EDI];取变量的值</span><br><span class="line">    ADD AL, '0' ; 转换为ASCII字符</span><br><span class="line">    MOV buffer8, AL ; 将ASCII字符存储在缓冲区中</span><br><span class="line">	POPAD</span><br><span class="line">    RET 4</span><br><span class="line">bin8ToAscii ENDP</span><br><span class="line"></span><br><span class="line">main PROC</span><br><span class="line">    MOV ADR, OFFSET NUM1; 示例8位数 (范围0-9)</span><br><span class="line">    LEA EBX,ADE</span><br><span class="line">    CALL bin8ToAscii ; 转换8位数</span><br><span class="line"></span><br><span class="line">    ; 在此处，buffer8包含转换后的ASCII字符</span><br><span class="line">    ; 可以在这里继续操作，例如打印输出等</span><br><span class="line"></span><br><span class="line">    INVOKE ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
<p>堆栈传参稍微复杂一些，在调用子程序之前，需要把对应的参数压栈，需要进入子程序之后，会自动加入偏移量，占一层堆栈。如果不带参数，可以这样写。<strong>注意参数压栈的顺序和自动插入的偏移量</strong>！有时候会为了恢复现场，在刚进入子程序就把寄存器压栈，ret 前再出栈，这样就重新覆盖了寄存器的值，可以保护现场，这时候也要注意堆栈变化，也要注意 PUSH POP 对应。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">NUM1 DB 7</span><br><span class="line">buffer8 DB 0 ; 存储转换后的ASCII字符</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">bin8ToAscii PROC</span><br><span class="line">	PUSH EAX</span><br><span class="line">	MOV AL,[ESP+8]</span><br><span class="line">    ADD AL, '0' ; 转换为ASCII字符</span><br><span class="line">    MOV buffer8, AL ; 将ASCII字符存储在缓冲区中</span><br><span class="line">    POP EAX</span><br><span class="line">    RET 4</span><br><span class="line">bin8ToAscii ENDP</span><br><span class="line"></span><br><span class="line">main PROC</span><br><span class="line">	MOVZX EAX,NUM1</span><br><span class="line">    PUSH EAX</span><br><span class="line">    CALL bin8ToAscii ; 转换8位数</span><br><span class="line"></span><br><span class="line">    ; 在此处，buffer8包含转换后的ASCII字符</span><br><span class="line">    ; 可以在这里继续操作，例如打印输出等</span><br><span class="line"></span><br><span class="line">    INVOKE ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
<p>可以指定保护的寄存器，这样就不用手动恢复寄存器了，寄存器之间用空格隔开。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">NUM1 DB 7</span><br><span class="line">buffer8 DB 0 ; 存储转换后的ASCII字符</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">bin8ToAscii PROC USES EAX</span><br><span class="line">	MOV AL,[ESP+8]</span><br><span class="line">    ADD AL, '0' ; 转换为ASCII字符</span><br><span class="line">    MOV buffer8, AL ; 将ASCII字符存储在缓冲区中</span><br><span class="line">    RET 4</span><br><span class="line">bin8ToAscii ENDP</span><br><span class="line"></span><br><span class="line">main PROC</span><br><span class="line">	MOVZX EAX,NUM1</span><br><span class="line">    PUSH EAX</span><br><span class="line">    CALL bin8ToAscii ; 转换8位数</span><br><span class="line"></span><br><span class="line">    ; 在此处，buffer8包含转换后的ASCII字符</span><br><span class="line">    ; 可以在这里继续操作，例如打印输出等</span><br><span class="line"></span><br><span class="line">    INVOKE ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
<p>也可以使用 INVOKE 带参数调用，这样就不要在主程序里手动 PUSH 了，也不用手动管理堆栈，这是推荐的方式。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.stack 4096</span><br><span class="line">ExitProcess PROTO, dwExitCode:DWORD</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">NUM1 DB 7</span><br><span class="line">buffer8 DB 0 ; 存储转换后的ASCII字符</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">bin8ToAscii PROC USES EAX,pa1:DB</span><br><span class="line">	MOV AL, pa1</span><br><span class="line">    ADD AL, '0' ; 转换为ASCII字符</span><br><span class="line">    MOV buffer8, AL ; 将ASCII字符存储在缓冲区中</span><br><span class="line">    RET 4</span><br><span class="line">bin8ToAscii ENDP</span><br><span class="line"></span><br><span class="line">main PROC</span><br><span class="line">	MOVZX EAX,NUM1</span><br><span class="line">    INVOKE bin8ToAscii AL; 转换8位数</span><br><span class="line"></span><br><span class="line">    ; 在此处，buffer8包含转换后的ASCII字符</span><br><span class="line">    ; 可以在这里继续操作，例如打印输出等</span><br><span class="line"></span><br><span class="line">    INVOKE ExitProcess,0</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></tbody></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz">Michael(Jiahao) Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz/cs-courses/x86-masm/">https://www.blog-blockchain.xyz/cs-courses/x86-masm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/assembly/">assembly</a></div><div class="post-share"><div class="social-share" data-image="/images/x86_assembly.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/fp/monad/" title="Haskell(三) Monad"><img class="cover" src="/images/haskell.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Haskell(三) Monad</div></div><div class="info-2"><div class="info-item-1">深入理解Haskell中的Monad概念，从理论基础到实际应用，包括Functor、Applicative和Monad的层次结构，以及错误处理和副作用管理的实践。</div></div></div></a><a class="pagination-related" href="/cs-courses/OS/" title="操作系统基础"><img class="cover" src="/images/OS.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">操作系统基础</div></div><div class="info-2"><div class="info-item-1">全面阐述操作系统核心概念，包括进程线程管理、内存管理、文件系统、死锁处理、调度算法等重要主题，适合计算机专业学生和系统开发人员学习参考。</div></div></div></a></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">Michael(Jiahao) Luo</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">95</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">55</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://x.com/jiahao_luo9"><i class="fa-brands fa-twitter"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://www.linkedin.com/in/jiahao-michael-luo-8ba5942a3" rel="external nofollow noreferrer" target="_blank" title="Linkedin"><i class="fa-brands fa-linkedin"></i></a><a class="social-icon" href="https://x.com/jiahao_luo9" rel="external nofollow noreferrer" target="_blank" title="Twitter"><i class="fa-brands fa-twitter"></i></a><a class="social-icon" href="https://github.com/learnerLj" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:luoshitou9@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">从技术到商业，从产品到设计，从生活到未来，我会在这里分享我的所思所想，欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-text">微处理器和寄存器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4"><span class="toc-text">CPU 执行指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8086-8088"><span class="toc-text">8086/8088</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">特点和工作模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%BC%95%E8%84%9A"><span class="toc-text">主要引脚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">内部结构和寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">标志寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%A0%88"><span class="toc-text">堆栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%AE%B5%E5%AF%BB%E5%9D%80"><span class="toc-text">保护模式的段寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-text">指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-text">寻址方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-text">数据传送指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MOV"><span class="toc-text">MOV</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MOVZX-MOVSX"><span class="toc-text">MOVZX/MOVSX</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="toc-text">堆栈指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="toc-text">交换指令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-%E6%8C%87%E4%BB%A4"><span class="toc-text">IO 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-text">取地址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-text">标志位操作指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-text">算术运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-text">加法指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-text">减法指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-text">乘法指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E6%8C%87%E4%BB%A4"><span class="toc-text">除法指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BCD-%E7%A0%81%E8%B0%83%E6%95%B4%E6%8C%87%E4%BB%A4"><span class="toc-text">BCD 码调整指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-text">逻辑运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-text">移位指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-text">串操作指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-text">程序控制指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-text">过程调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80"><span class="toc-text">汇编程序基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-text">数据定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%AE%9A%E4%B9%89"><span class="toc-text">标号和符号定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%8F%98%E9%87%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">表达式和变量修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">过程定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">程序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">Windows 的输入输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="toc-text">程序设计基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-text">子程序</span></a></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>Post Series</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/C-language-basis/" title="C语言基础"><img src="/images/C_Programming_Language.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言基础"></a><div class="content"><a class="title" href="/cs-courses/C-language-basis/" title="C语言基础">C语言基础</a><time datetime="2021-02-02T08:15:22.000Z" title="Created 2021-02-02 16:15:22">2021-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/modular-inverses/" title="乘法逆元"><img src="/images/cryptology.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="乘法逆元"></a><div class="content"><a class="title" href="/cs-courses/modular-inverses/" title="乘法逆元">乘法逆元</a><time datetime="2022-09-27T13:49:22.000Z" title="Created 2022-09-27 21:49:22">2022-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/cpp-cryptographic-algorithm-basis/" title="信息安全算法基础"><img src="/images/cryptology.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信息安全算法基础"></a><div class="content"><a class="title" href="/cs-courses/cpp-cryptographic-algorithm-basis/" title="信息安全算法基础">信息安全算法基础</a><time datetime="2022-12-02T08:15:22.000Z" title="Created 2022-12-02 16:15:22">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/OS/" title="操作系统基础"><img src="/images/OS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统基础"></a><div class="content"><a class="title" href="/cs-courses/OS/" title="操作系统基础">操作系统基础</a><time datetime="2023-02-13T15:06:22.000Z" title="Created 2023-02-13 23:06:22">2023-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/x86-masm/" title="x86汇编基础"><img src="/images/x86_assembly.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="x86汇编基础"></a><div class="content"><a class="title" href="/cs-courses/x86-masm/" title="x86汇编基础">x86汇编基础</a><time datetime="2023-05-11T12:48:22.000Z" title="Created 2023-05-11 20:48:22">2023-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cs-courses/information-theory/" title="信息论与编码"><img src="/images/info-theory.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信息论与编码"></a><div class="content"><a class="title" href="/cs-courses/information-theory/" title="信息论与编码">信息论与编码</a><time datetime="2023-05-29T00:15:22.000Z" title="Created 2023-05-29 08:15:22">2023-05-29</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/finance/ltcm-risk-management-case-study/" title="华尔街&quot;梦幻团队&quot;的惨痛教训：LTCM如何在4个月内损失46亿美元"><img src="https://cdn.blog-blockchain.xyz/2025/07/3aeebf60c26b2a9809d7091517c4f856.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="华尔街&quot;梦幻团队&quot;的惨痛教训：LTCM如何在4个月内损失46亿美元"></a><div class="content"><a class="title" href="/finance/ltcm-risk-management-case-study/" title="华尔街&quot;梦幻团队&quot;的惨痛教训：LTCM如何在4个月内损失46亿美元">华尔街"梦幻团队"的惨痛教训：LTCM如何在4个月内损失46亿美元</a><time datetime="2025-07-27T06:31:00.000Z" title="Created 2025-07-27 14:31:00">2025-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/finance/ftx-alameda-collapse-case-study/" title="320亿美元消失记：FTX帝国崩塌背后的人性贪婪与制度失效"><img src="https://cdn.blog-blockchain.xyz/2025/07/449fc564e4e9aa38a6eaf425abc6ef44.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="320亿美元消失记：FTX帝国崩塌背后的人性贪婪与制度失效"></a><div class="content"><a class="title" href="/finance/ftx-alameda-collapse-case-study/" title="320亿美元消失记：FTX帝国崩塌背后的人性贪婪与制度失效">320亿美元消失记：FTX帝国崩塌背后的人性贪婪与制度失效</a><time datetime="2025-07-27T06:26:20.000Z" title="Created 2025-07-27 14:26:20">2025-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/finance/binance-unified-account-risk-analysis/" title="币安统一账户保证金交易的风险分析与管理策略"><img src="https://cdn.blog-blockchain.xyz/2025/07/38b70ba52e268082e1304ae0b5545153.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="币安统一账户保证金交易的风险分析与管理策略"></a><div class="content"><a class="title" href="/finance/binance-unified-account-risk-analysis/" title="币安统一账户保证金交易的风险分析与管理策略">币安统一账户保证金交易的风险分析与管理策略</a><time datetime="2025-07-27T05:55:20.000Z" title="Created 2025-07-27 13:55:20">2025-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/finance/binance-unified-account-margin-trading-guide/" title="币安统一账户与保证金交易完整指南"><img src="https://cdn.blog-blockchain.xyz/2025/07/38b70ba52e268082e1304ae0b5545153.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="币安统一账户与保证金交易完整指南"></a><div class="content"><a class="title" href="/finance/binance-unified-account-margin-trading-guide/" title="币安统一账户与保证金交易完整指南">币安统一账户与保证金交易完整指南</a><time datetime="2025-07-27T05:26:20.000Z" title="Created 2025-07-27 13:26:20">2025-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/hexo-cache-busting-solution/" title="Hexo博客缓存问题的终极解决方案"><img src="https://cdn.blog-blockchain.xyz/2025/07/717868abde8ec43fd9ded6bb36280318.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo博客缓存问题的终极解决方案"></a><div class="content"><a class="title" href="/dev/hexo-cache-busting-solution/" title="Hexo博客缓存问题的终极解决方案">Hexo博客缓存问题的终极解决方案</a><time datetime="2025-07-23T13:40:00.000Z" title="Created 2025-07-23 21:40:00">2025-07-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2020 - 2025 By Michael(Jiahao) Luo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js?v=1753601477837"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div></div></div><script src="/bundle.js"></script><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})();
(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})();
(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '467d9506710fff22dc33',
      clientSecret: '2a3e530b895af9c94d4bbe95fe78c69317f4d76e',
      repo: 'blog-gitalk',
      owner: 'learnerLj',
      admin: ['learnerLj'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'd431e8407aa0973a7735dfbf9ac87b6a'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></body></html>