<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>区块同步 | Jiahao Luo</title><meta name="author" content="Michael(Jiahao) Luo"><meta name="copyright" content="Michael(Jiahao) Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="交易的签名理解收据receipt理解区块理解交易blockchain核心布隆过滤器原理forkId 解读oracle 原理和实现交易池分析TxList 解读MPT树区块同步geth源码学习——介绍How Geth starts its server   博主的朋友写的  看到core\blockchain.go的时候大量涉及该部分知识，故在此参考大佬博客加之自己的理解先行总结 本文仅仅是简单总结">
<meta property="og:type" content="article">
<meta property="og:title" content="区块同步">
<meta property="og:url" content="https://www.blog-blockchain.xyz/geth/block-sync/index.html">
<meta property="og:site_name" content="Jiahao Luo">
<meta property="og:description" content="交易的签名理解收据receipt理解区块理解交易blockchain核心布隆过滤器原理forkId 解读oracle 原理和实现交易池分析TxList 解读MPT树区块同步geth源码学习——介绍How Geth starts its server   博主的朋友写的  看到core\blockchain.go的时候大量涉及该部分知识，故在此参考大佬博客加之自己的理解先行总结 本文仅仅是简单总结">
<meta property="og:locale">
<meta property="og:image" content="https://www.blog-blockchain.xyz/images/geth.png">
<meta property="article:published_time" content="2022-08-25T08:30:33.000Z">
<meta property="article:modified_time" content="2024-11-15T14:30:54.923Z">
<meta property="article:author" content="Michael(Jiahao) Luo">
<meta property="article:tag" content="geth">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.blog-blockchain.xyz/images/geth.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "区块同步",
  "url": "https://www.blog-blockchain.xyz/geth/block-sync/",
  "image": "https://www.blog-blockchain.xyz/images/geth.png",
  "datePublished": "2022-08-25T08:30:33.000Z",
  "dateModified": "2024-11-15T14:30:54.923Z",
  "author": [
    {
      "@type": "Person",
      "name": "Michael(Jiahao) Luo",
      "url": "https://www.blog-blockchain.xyz/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://www.blog-blockchain.xyz/geth/block-sync/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?372b8854d18acf62880149b1e08e1901";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=QXcJQjXxTMeUwnWykFW2xw"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'QXcJQjXxTMeUwnWykFW2xw')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'QXcJQjXxTMeUwnWykFW2xw', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '区块同步',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Jiahao Luo" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jiahao Luo</span></a><a class="nav-page-title" href="/"><span class="site-name">区块同步</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">区块同步</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-08-25T08:30:33.000Z" title="Created 2022-08-25 16:30:33">2022-08-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-15T14:30:54.923Z" title="Updated 2024-11-15 22:30:54">2024-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/geth/">geth</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>47mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><blockquote>
<ol class="series-items"><li><a href="/geth/tx-signature/" title="交易的签名">交易的签名</a></li><li><a href="/geth/understand-receipt/" title="理解收据receipt">理解收据receipt</a></li><li><a href="/geth/blocks/" title="理解区块">理解区块</a></li><li><a href="/geth/understand-tx/" title="理解交易">理解交易</a></li><li><a href="/geth/blockchain-core/" title="blockchain核心">blockchain核心</a></li><li><a href="/geth/bloom-filter/" title="布隆过滤器原理">布隆过滤器原理</a></li><li><a href="/geth/forkId/" title="forkId 解读">forkId 解读</a></li><li><a href="/geth/oracle-introduction/" title="oracle 原理和实现">oracle 原理和实现</a></li><li><a href="/geth/tx-pool/" title="交易池分析">交易池分析</a></li><li><a href="/geth/txlist/" title="TxList 解读">TxList 解读</a></li><li><a href="/geth/MPT-Tree/" title="MPT树">MPT树</a></li><li><a href="/geth/block-sync/" title="区块同步">区块同步</a></li><li><a href="/geth/introduction/" title="geth源码学习——介绍">geth源码学习——介绍</a></li><li><a href="/geth/Geth-Unveiled-Ethereum-Startup/" title="How Geth starts its server">How Geth starts its server</a></li></ol>
</blockquote>
<blockquote>
<p>博主的朋友写的</p>
<ul>
<li>看到<code>core\blockchain.go</code>的时候大量涉及该部分知识，故在此参考大佬博客加之自己的理解先行总结</li>
<li>本文仅仅是简单总结了一下文件结构和重要函数功能，详细函数分析请参考<a target="_blank" rel="noopener external nofollow noreferrer" href="https://mindcarver.cn/2020/12/23/%E6%AD%BB%E7%A3%95%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdownloader%E5%90%8C%E6%AD%A5/">downloader 同步</a></li>
</ul>
</blockquote>
<h3 id="文件结构"><strong>文件结构</strong></h3>
<p><code>downloader</code> 模块的代码位于 <code>eth/downloader</code> 目录下。主要的功能代码分别是：</p>
<ul>
<li>
<p><code>downloader.go</code> ：实现了区块同步逻辑</p>
</li>
<li>
<p><code>peer.go</code> ：对区块各个阶段的组装，下面的各个<code>FetchXXX</code> 就是很依赖这个模块。</p>
</li>
<li>
<p><code>queue.go</code> ：对<code>eth/peer.go</code>的封装</p>
</li>
<li>
<p><code>statesync.go</code> ：同步<code>state</code>对象</p>
</li>
<li>
<p>注意：</p>
<ul>
<li>
<p><code>downloader</code>是一个下载器，从远程网络节点中获取 hashes 和 blocks。</p>
</li>
<li>
<p><code>fetcher</code>则收集网络其他以太坊节点发过来的同步通知，进行验证，并做出相应的处理。</p>
</li>
<li>
<p><code>peers</code>是经过验证可信任的通信节点的集合。</p>
</li>
<li>
<p><code>queue</code> represents hashes that are either need fetching or are being fetched</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queue represents hashes that are either need fetching or are being fetched</span></span><br><span class="line"><span class="keyword">type</span> queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	mode SyncMode <span class="comment">// Synchronisation mode to decide on the block parts to schedule for fetching</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Headers are &quot;special&quot;, they download in batches, supported by a skeleton chain</span></span><br><span class="line">	headerHead      common.Hash                    <span class="comment">// Hash of the last queued header to verify order</span></span><br><span class="line">	headerTaskPool  <span class="keyword">map</span>[<span class="type">uint64</span>]*types.Header       <span class="comment">// Pending header retrieval tasks, mapping starting indexes to skeleton headers</span></span><br><span class="line">	headerTaskQueue *prque.Prque                   <span class="comment">// Priority queue of the skeleton indexes to fetch the filling headers for</span></span><br><span class="line">	headerPeerMiss  <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// Set of per-peer header batches known to be unavailable</span></span><br><span class="line">	headerPendPool  <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest       <span class="comment">// Currently pending header retrieval operations</span></span><br><span class="line">	headerResults   []*types.Header                <span class="comment">// Result cache accumulating the completed headers</span></span><br><span class="line">	headerProced    <span class="type">int</span>                            <span class="comment">// Number of headers already processed from the results</span></span><br><span class="line">	headerOffset    <span class="type">uint64</span>                         <span class="comment">// Number of the first header in the result cache</span></span><br><span class="line">	headerContCh    <span class="keyword">chan</span> <span class="type">bool</span>                      <span class="comment">// Channel to notify when header download finishes</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// All data retrievals below are based on an already assembles header chain</span></span><br><span class="line">	blockTaskPool  <span class="keyword">map</span>[common.Hash]*types.Header <span class="comment">// Pending block (body) retrieval tasks, mapping hashes to headers</span></span><br><span class="line">	blockTaskQueue *prque.Prque                  <span class="comment">// Priority queue of the headers to fetch the blocks (bodies) for</span></span><br><span class="line">	blockPendPool  <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest      <span class="comment">// Currently pending block (body) retrieval operations</span></span><br><span class="line"></span><br><span class="line">	receiptTaskPool  <span class="keyword">map</span>[common.Hash]*types.Header <span class="comment">// Pending receipt retrieval tasks, mapping hashes to headers</span></span><br><span class="line">	receiptTaskQueue *prque.Prque                  <span class="comment">// Priority queue of the headers to fetch the receipts for</span></span><br><span class="line">	receiptPendPool  <span class="keyword">map</span>[<span class="type">string</span>]*fetchRequest      <span class="comment">// Currently pending receipt retrieval operations</span></span><br><span class="line"></span><br><span class="line">	resultCache *resultStore       <span class="comment">// Downloaded but not yet delivered fetch results</span></span><br><span class="line">	resultSize  common.StorageSize <span class="comment">// Approximate size of a block (exponential moving average)</span></span><br><span class="line"></span><br><span class="line">	lock   *sync.RWMutex</span><br><span class="line">	active *sync.Cond</span><br><span class="line">	closed <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	lastStatLog time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="同步模式"><strong>同步模式</strong></h3>
<p>以太坊中区块同步包含以下三种模式：</p>
<ul>
<li>
<p>full sync：</p>
<p><code>full</code> 模式会在数据库中保存所有区块数据，同步时从远程节点同步 header 和 body 数据，而 state 和 receipt 数据则是在本地计算出来的。</p>
<p>在 full 模式下，downloader 会同步区块的 header 和 body 数据组成一个区块，然后通过 blockchain 模块的 <code>BlockChain.InsertChain</code> 向数据库中插入区块。在 <code>BlockChain.InsertChain</code> 中，会逐个<strong>计算和验证</strong>每个块的 <code>state</code> 和 <code>recepit</code> 等数据，如果一切正常就将区块数据以及自己计算得到的 <code>state</code>、<code>recepit</code> 数据一起写入到数据库中。</p>
</li>
<li>
<p>fast sync：</p>
<p><code>fast</code> 模式下，<code>recepit</code> 不再由本地计算，而是和区块数据一样，直接由 <code>downloader</code> 从其它节点中同步；<code>state</code> 数据并不会全部计算和下载，而是选一个较新的区块（称之为 <code>pivot</code>）的 <code>state</code> 进行下载，以这个区块为分界，之前的区块是没有 <code>state</code> 数据的，之后的区块会像 <code>full</code> 模式下一样在本地计算 <code>state</code>。因此在 <code>fast</code> 模式下，同步的数据除了 <code>header</code> 和 body，还有 <code>receipt</code>，以及 <code>pivot</code> 区块的 <code>state</code>。</p>
<p>因此 <code>fast</code> 模式忽略了大部分 <code>state</code> 数据，并且使用网络直接同步 <code>receipt</code> 数据的方式替换了 <code>full</code> 模式下的本地计算，所以比较快。</p>
</li>
<li>
<p>light sync：从网络中同步所有区块头，不去同步区块体，也不去同步状态数据，仅在需要相应区块和状态数据时从网络上获取</p>
</li>
</ul>
<blockquote>
<p>简单总结：</p>
</blockquote>
<p>SyncMode:</p>
<ul>
<li><code>FullSync</code>:从完整区块同步整个区块链历史</li>
<li><code>FastSync</code>:快速下载 Header，仅在链头处完全同步</li>
<li><code>LightSync</code>:仅下载 Header，然后终止</li>
</ul>
<h3 id="区块下载"><strong>区块下载</strong></h3>
<p>区块下载流程示意图如下所示：</p>
<p><img src="https://lky-img.obs.cn-east-2.myhuaweicloud.com/image-20220331155831706.png" alt="image-20220331155831706"></p>
<p>首先根据 Synchronise 开始区块同步，通过 findAncestor 找到指定节点的共同祖先，并在此高度进行同步，同时开启多个 goroutine 同步不同的数据：header、receipt、body，假如同步高度为 100 的区块，必须先 header 同步成功同步完成才可以进行 body 和 receipts 的同步，而每个部分的同步大致都是由 FetchParts 来完成的，里面包含了各个 Chan 的配合，也会涉及不少的回调函数</p>
<h3 id="源码分析"><strong>源码分析</strong></h3>
<h4 id="数据结构"><strong>数据结构</strong></h4>
<p>downloader 数据结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Downloader <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">  mode <span class="type">uint32</span>         <span class="comment">// Synchronisation mode defining the strategy used (per sync cycle), use d.getMode() to get the SyncMode</span></span><br><span class="line">  mux  *event.TypeMux <span class="comment">// Event multiplexer to announce sync operation events</span></span><br><span class="line"></span><br><span class="line">  checkpoint <span class="type">uint64</span>   <span class="comment">// Checkpoint block number to enforce head against (e.g. fast sync)</span></span><br><span class="line">  genesis    <span class="type">uint64</span>   <span class="comment">// Genesis block number to limit sync to (e.g. light client CHT)</span></span><br><span class="line">  queue      *queue   <span class="comment">// Scheduler(调度程序)for selecting the hashes to download</span></span><br><span class="line">  peers      *peerSet <span class="comment">// Set of active peers from which download can proceed</span></span><br><span class="line"></span><br><span class="line">  stateDB    ethdb.Database  <span class="comment">// Database to state sync into (and deduplicate via)</span></span><br><span class="line">  stateBloom *trie.SyncBloom <span class="comment">// Bloom filter for fast trie node and contract code existence checks</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Statistics  统计信息，</span></span><br><span class="line">  syncStatsChainOrigin <span class="type">uint64</span> <span class="comment">// Origin block number where syncing started at</span></span><br><span class="line">  syncStatsChainHeight <span class="type">uint64</span> <span class="comment">// Highest block number known when syncing started</span></span><br><span class="line">  syncStatsState       stateSyncStats</span><br><span class="line">  syncStatsLock        sync.RWMutex <span class="comment">// Lock protecting the sync stats fields</span></span><br><span class="line"></span><br><span class="line">  lightchain LightChain</span><br><span class="line">  blockchain BlockChain</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Callbacks</span></span><br><span class="line">  dropPeer peerDropFn <span class="comment">// Drops a peer for misbehaving</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Status</span></span><br><span class="line">  synchroniseMock <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>, hash common.Hash)</span></span> <span class="type">error</span> <span class="comment">// Replacement for synchronise during testing</span></span><br><span class="line">  synchronising   <span class="type">int32</span></span><br><span class="line">  notified        <span class="type">int32</span></span><br><span class="line">  committed       <span class="type">int32</span></span><br><span class="line">  ancientLimit    <span class="type">uint64</span> <span class="comment">// The maximum block number which can be regarded as ancient data.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Channels 这些通道很重要</span></span><br><span class="line">  headerCh      <span class="keyword">chan</span> dataPack        <span class="comment">// Channel receiving inbound block headers  header的输入通道，从网络下载的header会被送到这个通道</span></span><br><span class="line">  bodyCh        <span class="keyword">chan</span> dataPack        <span class="comment">// Channel receiving inbound block bodies   bodies的输入通道，从网络下载的bodies会被送到这个通道</span></span><br><span class="line">  receiptCh     <span class="keyword">chan</span> dataPack        <span class="comment">// Channel receiving inbound receipts       receipts的输入通道，从网络下载的receipts会被送到这个通道</span></span><br><span class="line">  bodyWakeCh    <span class="keyword">chan</span> <span class="type">bool</span>            <span class="comment">// Channel to signal the block body fetcher of new tasks   用来传输body fetcher新任务的通道</span></span><br><span class="line">  receiptWakeCh <span class="keyword">chan</span> <span class="type">bool</span>            <span class="comment">// Channel to signal the receipt fetcher of new tasks      用来传输receipt fetcher 新任务的通道</span></span><br><span class="line">  headerProcCh  <span class="keyword">chan</span> []*types.Header <span class="comment">// Channel to feed the header processor new tasks          通道为header处理者提供新的任务</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// State sync</span></span><br><span class="line">  pivotHeader *types.Header <span class="comment">// Pivot block header to dynamically push the syncing state root</span></span><br><span class="line">  pivotLock   sync.RWMutex  <span class="comment">// Lock protecting pivot header reads from updates</span></span><br><span class="line"></span><br><span class="line">  snapSync       <span class="type">bool</span>         <span class="comment">// Whether to run state sync over the snap protocol</span></span><br><span class="line">  SnapSyncer     *snap.Syncer <span class="comment">// TODO(karalabe): make private! hack for now</span></span><br><span class="line">  stateSyncStart <span class="keyword">chan</span> *stateSync    <span class="comment">//启动新的state fetcher</span></span><br><span class="line">  trackStateReq  <span class="keyword">chan</span> *stateReq</span><br><span class="line">  stateCh        <span class="keyword">chan</span> dataPack <span class="comment">// Channel receiving inbound node state data  State的输入通道，从网络下载的State会被送到这个通道</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cancellation and termination</span></span><br><span class="line">  cancelPeer <span class="type">string</span>         <span class="comment">// Identifier of the peer currently being used as the master (cancel on drop)</span></span><br><span class="line">  cancelCh   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">// Channel to cancel mid-flight syncs</span></span><br><span class="line">  cancelLock sync.RWMutex   <span class="comment">// Lock to protect the cancel channel and peer in delivers</span></span><br><span class="line">  cancelWg   sync.WaitGroup <span class="comment">// Make sure all fetcher goroutines have exited.</span></span><br><span class="line"></span><br><span class="line">  quitCh   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// Quit channel to signal termination</span></span><br><span class="line">  quitLock sync.Mutex    <span class="comment">// Lock to prevent double closes</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Testing hooks</span></span><br><span class="line">  syncInitHook     <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">uint64</span>, <span class="type">uint64</span>)</span></span>  <span class="comment">// Method to call upon initiating a new sync run</span></span><br><span class="line">  bodyFetchHook    <span class="function"><span class="keyword">func</span><span class="params">([]*types.Header)</span></span> <span class="comment">// Method to call upon starting a block body fetch</span></span><br><span class="line">  receiptFetchHook <span class="function"><span class="keyword">func</span><span class="params">([]*types.Header)</span></span> <span class="comment">// Method to call upon starting a receipt fetch</span></span><br><span class="line">  chainInsertHook  <span class="function"><span class="keyword">func</span><span class="params">([]*fetchResult)</span></span>  <span class="comment">// Method to call upon inserting a chain of blocks (possibly in multiple invocations)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造方法"><strong>构造方法</strong></h4>
<p>New 用于初始化一个 Downloader 对象，具体代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New creates a new downloader to fetch hashes and blocks from remote peers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(checkpoint <span class="type">uint64</span>, stateDb ethdb.Database, stateBloom *trie.SyncBloom, mux *event.TypeMux, chain BlockChain, lightchain LightChain, dropPeer peerDropFn)</span></span> *Downloader &#123;</span><br><span class="line">  <span class="keyword">if</span> lightchain == <span class="literal">nil</span> &#123;</span><br><span class="line">    lightchain = chain</span><br><span class="line">  &#125;</span><br><span class="line">  dl := &amp;Downloader&#123;</span><br><span class="line">    stateDB:        stateDb,</span><br><span class="line">    stateBloom:     stateBloom,</span><br><span class="line">    mux:            mux,</span><br><span class="line">    checkpoint:     checkpoint,</span><br><span class="line">    queue:          newQueue(blockCacheMaxItems, blockCacheInitialItems),</span><br><span class="line">    peers:          newPeerSet(),</span><br><span class="line">    rttEstimate:    <span class="type">uint64</span>(rttMaxEstimate),</span><br><span class="line">    rttConfidence:  <span class="type">uint64</span>(<span class="number">1000000</span>),</span><br><span class="line">    blockchain:     chain,</span><br><span class="line">    lightchain:     lightchain,</span><br><span class="line">    dropPeer:       dropPeer,</span><br><span class="line">    headerCh:       <span class="built_in">make</span>(<span class="keyword">chan</span> dataPack, <span class="number">1</span>),</span><br><span class="line">    bodyCh:         <span class="built_in">make</span>(<span class="keyword">chan</span> dataPack, <span class="number">1</span>),</span><br><span class="line">    receiptCh:      <span class="built_in">make</span>(<span class="keyword">chan</span> dataPack, <span class="number">1</span>),</span><br><span class="line">    bodyWakeCh:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>),</span><br><span class="line">    receiptWakeCh:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>),</span><br><span class="line">    headerProcCh:   <span class="built_in">make</span>(<span class="keyword">chan</span> []*types.Header, <span class="number">1</span>),</span><br><span class="line">    quitCh:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    stateCh:        <span class="built_in">make</span>(<span class="keyword">chan</span> dataPack),</span><br><span class="line">    SnapSyncer:     snap.NewSyncer(stateDb),</span><br><span class="line">    stateSyncStart: <span class="built_in">make</span>(<span class="keyword">chan</span> *stateSync),</span><br><span class="line">    syncStatsState: stateSyncStats&#123;</span><br><span class="line">      processed: rawdb.ReadFastTrieProgress(stateDb),</span><br><span class="line">    &#125;,</span><br><span class="line">    trackStateReq: <span class="built_in">make</span>(<span class="keyword">chan</span> *stateReq),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">go</span> dl.qosTuner()        <span class="comment">//计算rttEstimate和rttConfidence</span></span><br><span class="line">  <span class="keyword">go</span> dl.stateFetcher()    <span class="comment">//启动stateFetcher的任务监听</span></span><br><span class="line">  <span class="keyword">return</span> dl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步下载"><strong>同步下载</strong></h4>
<p>区块同步始于 Synchronise 函数，在这里会直接调用 synchronise 进行同步，如果同步过程中出现错误，则删除掉 Peer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Synchronise tries to sync up our local block chain with a remote peer, both</span></span><br><span class="line"><span class="comment">// adding various sanity checks as well as wrapping it with various log entries.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> Synchronise(id <span class="type">string</span>, head common.Hash, td *big.Int, mode SyncMode) <span class="type">error</span> &#123;</span><br><span class="line">  err := d.synchronise(id, head, td, mode)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> err &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">nil</span>, errBusy, errCanceled:</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> errors.Is(err, errInvalidChain) || errors.Is(err, errBadPeer) || errors.Is(err, errTimeout) ||</span><br><span class="line">    errors.Is(err, errStallingPeer) || errors.Is(err, errUnsyncedPeer) || errors.Is(err, errEmptyHeaderSet) ||</span><br><span class="line">    errors.Is(err, errPeersUnavailable) || errors.Is(err, errTooOld) || errors.Is(err, errInvalidAncestor) &#123;</span><br><span class="line">    log.Warn(<span class="string">&quot;Synchronisation failed, dropping peer&quot;</span>, <span class="string">&quot;peer&quot;</span>, id, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">    <span class="keyword">if</span> d.dropPeer == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// The dropPeer method is nil when `--copydb` is used for a local copy.</span></span><br><span class="line">      <span class="comment">// Timeouts can occur if e.g. compaction hits at the wrong time, and can be ignored</span></span><br><span class="line">      log.Warn(<span class="string">&quot;Downloader wants to drop peer, but peerdrop-function is not set&quot;</span>, <span class="string">&quot;peer&quot;</span>, id)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//删除操作</span></span><br><span class="line">      d.dropPeer(id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  log.Warn(<span class="string">&quot;Synchronisation failed, retrying&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronise 函数实现代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronise will select the peer and use it for synchronising. If an empty string is given</span></span><br><span class="line"><span class="comment">// it will use the best peer possible and synchronize if its TD is higher than our own. If any of the</span></span><br><span class="line"><span class="comment">// checks fail an error will be returned. This method is synchronous</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> synchronise(id <span class="type">string</span>, hash common.Hash, td *big.Int, mode SyncMode) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// Mock out the synchronisation if testing</span></span><br><span class="line">  <span class="keyword">if</span> d.synchroniseMock != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> d.synchroniseMock(id, hash)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Make sure only one goroutine is ever allowed past this point at once    // 只能运行一个， 检查是否正在运行</span></span><br><span class="line">  <span class="keyword">if</span> !atomic.CompareAndSwapInt32(&amp;d.synchronising, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> errBusy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> atomic.StoreInt32(&amp;d.synchronising, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post a user notification of the sync (only once per session)   // 发布同步的用户通知（每个会话仅一次）</span></span><br><span class="line">  <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;d.notified, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">    log.Info(<span class="string">&quot;Block synchronisation started&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If we are already full syncing, but have a fast-sync bloom filter laying</span></span><br><span class="line">  <span class="comment">// around, make sure it doesn&#x27;t use memory any more. This is a special case</span></span><br><span class="line">  <span class="comment">// when the user attempts to fast sync a new empty network.</span></span><br><span class="line">  <span class="keyword">if</span> mode == FullSync &amp;&amp; d.stateBloom != <span class="literal">nil</span> &#123;</span><br><span class="line">    d.stateBloom.Close()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If snap sync was requested, create the snap scheduler and switch to fast</span></span><br><span class="line">  <span class="comment">// sync mode. Long term we could drop fast sync or merge the two together,</span></span><br><span class="line">  <span class="comment">// but until snap becomes prevalent, we should support both. TODO(karalabe).</span></span><br><span class="line">  <span class="keyword">if</span> mode == SnapSync &#123;</span><br><span class="line">    <span class="keyword">if</span> !d.snapSync &#123;</span><br><span class="line">      log.Warn(<span class="string">&quot;Enabling snapshot sync prototype&quot;</span>)</span><br><span class="line">      d.snapSync = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    mode = FastSync</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Reset the queue, peer set and wake channels to clean any internal leftover state</span></span><br><span class="line">  d.queue.Reset(blockCacheMaxItems, blockCacheInitialItems)  <span class="comment">// 重置queue的状态</span></span><br><span class="line">  d.peers.Reset()                       <span class="comment">//  重置peer的状态</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;   <span class="comment">// 清空d.bodyWakeCh, d.receiptWakeCh</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> dataPack&#123;d.headerCh, d.bodyCh, d.receiptCh&#125; &#123;   <span class="comment">//清空d.headerCh, d.bodyCh, d.receiptCh</span></span><br><span class="line">    <span class="keyword">for</span> empty := <span class="literal">false</span>; !empty; &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        empty = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> empty := <span class="literal">false</span>; !empty; &#123;    <span class="comment">// 清空headerProcCh</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-d.headerProcCh:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      empty = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Create cancel channel for aborting mid-flight and mark the master peer</span></span><br><span class="line">  d.cancelLock.Lock()</span><br><span class="line">  d.cancelCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">  d.cancelPeer = id</span><br><span class="line">  d.cancelLock.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> d.Cancel() <span class="comment">// No matter what, we can&#x27;t leave the cancel channel open</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Atomically set the requested sync mode</span></span><br><span class="line">  atomic.StoreUint32(&amp;d.mode, <span class="type">uint32</span>(mode))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Retrieve the origin peer and initiate the downloading process</span></span><br><span class="line">  p := d.peers.Peer(id)</span><br><span class="line">  <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errUnknownPeer</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d.syncWithPeer(p, hash, td)    <span class="comment">// 基于哈希链从指定的peer和head hash开始块同步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>syncWithPeer 函数代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filedir:go-ethereum-1.10.2\eth\downloader\downloader.go  L448</span></span><br><span class="line"><span class="comment">// syncWithPeer starts a block synchronization based on the hash chain from the</span></span><br><span class="line"><span class="comment">// specified peer and head hash.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> syncWithPeer(p *peerConnection, hash common.Hash, td *big.Int) (err <span class="type">error</span>) &#123;</span><br><span class="line">  d.mux.Post(StartEvent&#123;&#125;)</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// reset on error</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      d.mux.Post(FailedEvent&#123;err&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      latest := d.lightchain.CurrentHeader()</span><br><span class="line">      d.mux.Post(DoneEvent&#123;latest&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">if</span> p.version &lt; <span class="number">64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w: advertized %d &lt; required %d&quot;</span>, errTooOld, p.version, <span class="number">64</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  mode := d.getMode()</span><br><span class="line"></span><br><span class="line">  log.Debug(<span class="string">&quot;Synchronising with the network&quot;</span>, <span class="string">&quot;peer&quot;</span>, p.id, <span class="string">&quot;eth&quot;</span>, p.version, <span class="string">&quot;head&quot;</span>, hash, <span class="string">&quot;td&quot;</span>, td, <span class="string">&quot;mode&quot;</span>, mode)</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123;</span><br><span class="line">    log.Debug(<span class="string">&quot;Synchronisation terminated&quot;</span>, <span class="string">&quot;elapsed&quot;</span>, common.PrettyDuration(time.Since(start)))</span><br><span class="line">  &#125;(time.Now())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Look up the sync boundaries: the common ancestor and the target block</span></span><br><span class="line">  latest, pivot, err := d.fetchHead(p)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> mode == FastSync &amp;&amp; pivot == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// If no pivot block was returned, the head is below the min full block</span></span><br><span class="line">    <span class="comment">// threshold (i.e. new chian). In that case we won&#x27;t really fast sync</span></span><br><span class="line">    <span class="comment">// anyway, but still need a valid pivot block to avoid some code hitting</span></span><br><span class="line">    <span class="comment">// nil panics on an access.</span></span><br><span class="line">    pivot = d.blockchain.CurrentBlock().Header()</span><br><span class="line">  &#125;</span><br><span class="line">  height := latest.Number.Uint64()</span><br><span class="line"></span><br><span class="line">  origin, err := d.findAncestor(p, latest)  <span class="comment">// 通过findAncestor来获取共同祖先，以便找到一个开始同步的点</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  d.syncStatsLock.Lock()</span><br><span class="line">  <span class="keyword">if</span> d.syncStatsChainHeight &lt;= origin || d.syncStatsChainOrigin &gt; origin &#123;</span><br><span class="line">    d.syncStatsChainOrigin = origin</span><br><span class="line">  &#125;</span><br><span class="line">  d.syncStatsChainHeight = height</span><br><span class="line">  d.syncStatsLock.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure our origin point is below any fast sync pivot point</span></span><br><span class="line">  <span class="keyword">if</span> mode == FastSync &#123;</span><br><span class="line">    <span class="keyword">if</span> height &lt;= <span class="type">uint64</span>(fsMinFullBlocks) &#123;      <span class="comment">// 如果对端节点的height小于64，则共同祖先更新为0</span></span><br><span class="line">      origin = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                   <span class="comment">// 否则更新pivot为对端节点height-64</span></span><br><span class="line">      pivotNumber := pivot.Number.Uint64()</span><br><span class="line">      <span class="keyword">if</span> pivotNumber &lt;= origin &#123;             <span class="comment">// 如果pivot小于共同祖先，则更新共同祖先为pivot的前一个</span></span><br><span class="line">        origin = pivotNumber - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Write out the pivot into the database so a rollback beyond it will</span></span><br><span class="line">      <span class="comment">// reenable fast sync</span></span><br><span class="line">      rawdb.WriteLastPivotNumber(d.stateDB, pivotNumber)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  d.committed = <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> mode == FastSync &amp;&amp; pivot.Number.Uint64() != <span class="number">0</span> &#123;</span><br><span class="line">    d.committed = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> mode == FastSync &#123;</span><br><span class="line">    <span class="comment">// Set the ancient data limitation.</span></span><br><span class="line">    <span class="comment">// If we are running fast sync, all block data older than ancientLimit will be</span></span><br><span class="line">    <span class="comment">// written to the ancient store. More recent data will be written to the active</span></span><br><span class="line">    <span class="comment">// database and will wait for the freezer to migrate.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If there is a checkpoint available, then calculate the ancientLimit through</span></span><br><span class="line">    <span class="comment">// that. Otherwise calculate the ancient limit through the advertised height</span></span><br><span class="line">    <span class="comment">// of the remote peer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The reason for picking checkpoint first is that a malicious peer can give us</span></span><br><span class="line">    <span class="comment">// a fake (very high) height, forcing the ancient limit to also be very high.</span></span><br><span class="line">    <span class="comment">// The peer would start to feed us valid blocks until head, resulting in all of</span></span><br><span class="line">    <span class="comment">// the blocks might be written into the ancient store. A following mini-reorg</span></span><br><span class="line">    <span class="comment">// could cause issues.</span></span><br><span class="line">    <span class="keyword">if</span> d.checkpoint != <span class="number">0</span> &amp;&amp; d.checkpoint &gt; fullMaxForkAncestry+<span class="number">1</span> &#123;</span><br><span class="line">      d.ancientLimit = d.checkpoint</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> height &gt; fullMaxForkAncestry+<span class="number">1</span> &#123;</span><br><span class="line">      d.ancientLimit = height - fullMaxForkAncestry - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      d.ancientLimit = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    frozen, _ := d.stateDB.Ancients() <span class="comment">// Ignore the error here since light client can also hit here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a part of blockchain data has already been written into active store,</span></span><br><span class="line">    <span class="comment">// disable the ancient style insertion explicitly.</span></span><br><span class="line">    <span class="keyword">if</span> origin &gt;= frozen &amp;&amp; frozen != <span class="number">0</span> &#123;</span><br><span class="line">      d.ancientLimit = <span class="number">0</span></span><br><span class="line">      log.Info(<span class="string">&quot;Disabling direct-ancient mode&quot;</span>, <span class="string">&quot;origin&quot;</span>, origin, <span class="string">&quot;ancient&quot;</span>, frozen<span class="number">-1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> d.ancientLimit &gt; <span class="number">0</span> &#123;</span><br><span class="line">      log.Debug(<span class="string">&quot;Enabling direct-ancient mode&quot;</span>, <span class="string">&quot;ancient&quot;</span>, d.ancientLimit)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Rewind the ancient store and blockchain if reorg happens.</span></span><br><span class="line">    <span class="keyword">if</span> origin+<span class="number">1</span> &lt; frozen &#123;</span><br><span class="line">      <span class="keyword">if</span> err := d.lightchain.SetHead(origin + <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Initiate the sync using a concurrent header and content retrieval algorithm</span></span><br><span class="line">  d.queue.Prepare(origin+<span class="number">1</span>, mode) <span class="comment">// 更新queue的值从共同祖先+1开始，即从共同祖先开始sync区块</span></span><br><span class="line">  <span class="keyword">if</span> d.syncInitHook != <span class="literal">nil</span> &#123;</span><br><span class="line">    d.syncInitHook(origin, height)</span><br><span class="line">  &#125;</span><br><span class="line">  fetchers := []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> d.fetchHeaders(p, origin+<span class="number">1</span>) &#125;, <span class="comment">// Headers are always retrieved</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> d.fetchBodies(origin + <span class="number">1</span>) &#125;,   <span class="comment">// Bodies are retrieved during normal and fast sync</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> d.fetchReceipts(origin + <span class="number">1</span>) &#125;, <span class="comment">// Receipts are retrieved during fast sync</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> d.processHeaders(origin+<span class="number">1</span>, td) &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> mode == FastSync &#123;        <span class="comment">//根据模式的不同，增加新的处理逻辑</span></span><br><span class="line">    d.pivotLock.Lock()</span><br><span class="line">    d.pivotHeader = pivot</span><br><span class="line">    d.pivotLock.Unlock()</span><br><span class="line"></span><br><span class="line">    fetchers = <span class="built_in">append</span>(fetchers, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> d.processFastSyncContent() &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> mode == FullSync &#123;</span><br><span class="line">    fetchers = <span class="built_in">append</span>(fetchers, d.processFullSyncContent)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d.spawnSync(fetchers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spawnSync 会给每个 fetcher 启动一个 goroutine, 然后阻塞的检查 fetcher 是否出错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spawnSync runs d.process and all given fetcher functions to completion in</span></span><br><span class="line"><span class="comment">// separate goroutines, returning the first error that appears.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> spawnSync(fetchers []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span>) <span class="type">error</span> &#123;</span><br><span class="line">  errc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="built_in">len</span>(fetchers))</span><br><span class="line">  d.cancelWg.Add(<span class="built_in">len</span>(fetchers))</span><br><span class="line">  <span class="keyword">for</span> _, fn := <span class="keyword">range</span> fetchers &#123;</span><br><span class="line">    fn := fn</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">defer</span> d.cancelWg.Done(); errc &lt;- fn() &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Wait for the first error, then terminate the others.</span></span><br><span class="line">  <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(fetchers); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(fetchers)<span class="number">-1</span> &#123;</span><br><span class="line">      <span class="comment">// Close the queue when all fetchers have exited.</span></span><br><span class="line">      <span class="comment">// This will cause the block processor to end when</span></span><br><span class="line">      <span class="comment">// it has processed the queue.</span></span><br><span class="line">      d.queue.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = &lt;-errc; err != <span class="literal">nil</span> &amp;&amp; err != errCanceled &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  d.queue.Close()</span><br><span class="line">  d.Cancel()</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步-State"><strong>同步 State</strong></h4>
<p>state 即世界状态，其保存着所有账户的余额等信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filedir: go-ethereum-1.10.2\eth\downloader\statesync.go</span></span><br><span class="line"><span class="comment">// stateFetcher manages the active state sync and accepts requests</span></span><br><span class="line"><span class="comment">// on its behalf.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> stateFetcher() &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s := &lt;-d.stateSyncStart:</span><br><span class="line">      <span class="keyword">for</span> next := s; next != <span class="literal">nil</span>; &#123;</span><br><span class="line">        next = d.runStateSync(next)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> &lt;-d.stateCh:</span><br><span class="line">      <span class="comment">// Ignore state responses while no sync is running.</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-d.quitCh:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runStateSync 函数执行状态同步，直到它完成或请求切换到另一个根哈希：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runStateSync runs a state synchronisation until it completes or another root</span></span><br><span class="line"><span class="comment">// hash is requested to be switched over to.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> runStateSync(s *stateSync) *stateSync &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    active   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*stateReq) <span class="comment">// Currently in-flight requests</span></span><br><span class="line">    finished []*stateReq                  <span class="comment">// Completed or failed requests</span></span><br><span class="line">    timeout  = <span class="built_in">make</span>(<span class="keyword">chan</span> *stateReq)       <span class="comment">// Timed out active requests</span></span><br><span class="line">  )</span><br><span class="line">  log.Trace(<span class="string">&quot;State sync starting&quot;</span>, <span class="string">&quot;root&quot;</span>, s.root)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Cancel active request timers on exit. Also set peers to idle so they&#x27;re</span></span><br><span class="line">    <span class="comment">// available for the next sync.</span></span><br><span class="line">    <span class="keyword">for</span> _, req := <span class="keyword">range</span> active &#123;</span><br><span class="line">      req.timer.Stop()</span><br><span class="line">      req.peer.SetNodeDataIdle(<span class="type">int</span>(req.nItems), time.Now())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">go</span> s.run()</span><br><span class="line">  <span class="keyword">defer</span> s.Cancel()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Listen for peer departure events to cancel assigned tasks</span></span><br><span class="line">  peerDrop := <span class="built_in">make</span>(<span class="keyword">chan</span> *peerConnection, <span class="number">1024</span>)</span><br><span class="line">  peerSub := s.d.peers.SubscribePeerDrops(peerDrop)</span><br><span class="line">  <span class="keyword">defer</span> peerSub.Unsubscribe()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// Enable sending of the first buffered element if there is one.</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">      deliverReq   *stateReq</span><br><span class="line">      deliverReqCh <span class="keyword">chan</span> *stateReq</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(finished) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      deliverReq = finished[<span class="number">0</span>]</span><br><span class="line">      deliverReqCh = s.deliver</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// The stateSync lifecycle:</span></span><br><span class="line">    <span class="keyword">case</span> next := &lt;-d.stateSyncStart:</span><br><span class="line">      d.spindownStateSync(active, finished, timeout, peerDrop)</span><br><span class="line">      <span class="keyword">return</span> next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> &lt;-s.done:</span><br><span class="line">      d.spindownStateSync(active, finished, timeout, peerDrop)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send the next finished request to the current sync:</span></span><br><span class="line">    <span class="keyword">case</span> deliverReqCh &lt;- deliverReq:</span><br><span class="line">      <span class="comment">// Shift out the first request, but also set the emptied slot to nil for GC</span></span><br><span class="line">      <span class="built_in">copy</span>(finished, finished[<span class="number">1</span>:])</span><br><span class="line">      finished[<span class="built_in">len</span>(finished)<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line">      finished = finished[:<span class="built_in">len</span>(finished)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle incoming state packs:</span></span><br><span class="line">    <span class="keyword">case</span> pack := &lt;-d.stateCh:</span><br><span class="line">      <span class="comment">// Discard any data not requested (or previously timed out)</span></span><br><span class="line">      req := active[pack.PeerId()]</span><br><span class="line">      <span class="keyword">if</span> req == <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Debug(<span class="string">&quot;Unrequested node data&quot;</span>, <span class="string">&quot;peer&quot;</span>, pack.PeerId(), <span class="string">&quot;len&quot;</span>, pack.Items())</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Finalize the request and queue up for processing</span></span><br><span class="line">      req.timer.Stop()</span><br><span class="line">      req.response = pack.(*statePack).states</span><br><span class="line">      req.delivered = time.Now()</span><br><span class="line"></span><br><span class="line">      finished = <span class="built_in">append</span>(finished, req)</span><br><span class="line">      <span class="built_in">delete</span>(active, pack.PeerId())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle dropped peer connections:</span></span><br><span class="line">    <span class="keyword">case</span> p := &lt;-peerDrop:</span><br><span class="line">      <span class="comment">// Skip if no request is currently pending</span></span><br><span class="line">      req := active[p.id]</span><br><span class="line">      <span class="keyword">if</span> req == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Finalize the request and queue up for processing</span></span><br><span class="line">      req.timer.Stop()</span><br><span class="line">      req.dropped = <span class="literal">true</span></span><br><span class="line">      req.delivered = time.Now()</span><br><span class="line"></span><br><span class="line">      finished = <span class="built_in">append</span>(finished, req)</span><br><span class="line">      <span class="built_in">delete</span>(active, p.id)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle timed-out requests:</span></span><br><span class="line">    <span class="keyword">case</span> req := &lt;-timeout:</span><br><span class="line">      <span class="comment">// If the peer is already requesting something else, ignore the stale timeout.</span></span><br><span class="line">      <span class="comment">// This can happen when the timeout and the delivery happens simultaneously,</span></span><br><span class="line">      <span class="comment">// causing both pathways to trigger.</span></span><br><span class="line">      <span class="keyword">if</span> active[req.peer.id] != req &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      req.delivered = time.Now()</span><br><span class="line">      <span class="comment">// Move the timed out data back into the download queue</span></span><br><span class="line">      finished = <span class="built_in">append</span>(finished, req)</span><br><span class="line">      <span class="built_in">delete</span>(active, req.peer.id)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Track outgoing state requests:</span></span><br><span class="line">    <span class="keyword">case</span> req := &lt;-d.trackStateReq:</span><br><span class="line">      <span class="comment">// If an active request already exists for this peer, we have a problem. In</span></span><br><span class="line">      <span class="comment">// theory the trie node schedule must never assign two requests to the same</span></span><br><span class="line">      <span class="comment">// peer. In practice however, a peer might receive a request, disconnect and</span></span><br><span class="line">      <span class="comment">// immediately reconnect before the previous times out. In this case the first</span></span><br><span class="line">      <span class="comment">// request is never honored, alas we must not silently overwrite it, as that</span></span><br><span class="line">      <span class="comment">// causes valid requests to go missing and sync to get stuck.</span></span><br><span class="line">      <span class="keyword">if</span> old := active[req.peer.id]; old != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Warn(<span class="string">&quot;Busy peer assigned new state fetch&quot;</span>, <span class="string">&quot;peer&quot;</span>, old.peer.id)</span><br><span class="line">        <span class="comment">// Move the previous request to the finished set</span></span><br><span class="line">        old.timer.Stop()</span><br><span class="line">        old.dropped = <span class="literal">true</span></span><br><span class="line">        old.delivered = time.Now()</span><br><span class="line">        finished = <span class="built_in">append</span>(finished, old)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Start a timer to notify the sync loop if the peer stalled.</span></span><br><span class="line">      req.timer = time.AfterFunc(req.timeout, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        timeout &lt;- req</span><br><span class="line">      &#125;)</span><br><span class="line">      active[req.peer.id] = req</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步-Head"><strong>同步 Head</strong></h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchHead retrieves the head header and prior pivot block (if available) from a remote peer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> fetchHead(p *peerConnection) (head *types.Header, pivot *types.Header, err <span class="type">error</span>) &#123;</span><br><span class="line">  p.log.Debug(<span class="string">&quot;Retrieving remote chain head&quot;</span>)</span><br><span class="line">  <span class="comment">//获取mode值</span></span><br><span class="line">  mode := d.getMode()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Request the advertised remote head block and wait for the response</span></span><br><span class="line">  latest, _ := p.peer.Head()</span><br><span class="line">  fetch := <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> mode == FastSync &#123;</span><br><span class="line">    fetch = <span class="number">2</span> <span class="comment">// head + pivot headers</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">go</span> p.peer.RequestHeadersByHash(latest, fetch, fsMinFullBlocks<span class="number">-1</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  ttl := d.requestTTL()</span><br><span class="line">  timeout := time.After(ttl)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errCanceled</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> packet := &lt;-d.headerCh:</span><br><span class="line">      <span class="comment">// Discard anything not from the origin peer</span></span><br><span class="line">      <span class="keyword">if</span> packet.PeerId() != p.id &#123;</span><br><span class="line">        log.Debug(<span class="string">&quot;Received headers from incorrect peer&quot;</span>, <span class="string">&quot;peer&quot;</span>, packet.PeerId())</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Make sure the peer gave us at least one and at most the requested headers</span></span><br><span class="line">      headers := packet.(*headerPack).headers</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> || <span class="built_in">len</span>(headers) &gt; fetch &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%w: returned headers %d != requested %d&quot;</span>, errBadPeer, <span class="built_in">len</span>(headers), fetch)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The first header needs to be the head, validate against the checkpoint</span></span><br><span class="line">      <span class="comment">// and request. If only 1 header was returned, make sure there&#x27;s no pivot</span></span><br><span class="line">      <span class="comment">// or there was not one requested.</span></span><br><span class="line">      head := headers[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">if</span> (mode == FastSync || mode == LightSync) &amp;&amp; head.Number.Uint64() &lt; d.checkpoint &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%w: remote head %d below checkpoint %d&quot;</span>, errUnsyncedPeer, head.Number, d.checkpoint)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> mode == FastSync &amp;&amp; head.Number.Uint64() &gt; <span class="type">uint64</span>(fsMinFullBlocks) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%w: no pivot included along head header&quot;</span>, errBadPeer)</span><br><span class="line">        &#125;</span><br><span class="line">        p.log.Debug(<span class="string">&quot;Remote head identified, no pivot&quot;</span>, <span class="string">&quot;number&quot;</span>, head.Number, <span class="string">&quot;hash&quot;</span>, head.Hash())</span><br><span class="line">        <span class="keyword">return</span> head, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// At this point we have 2 headers in total and the first is the</span></span><br><span class="line">      <span class="comment">// validated head of the chian. Check the pivot number and return,</span></span><br><span class="line">      pivot := headers[<span class="number">1</span>]</span><br><span class="line">      <span class="keyword">if</span> pivot.Number.Uint64() != head.Number.Uint64()-<span class="type">uint64</span>(fsMinFullBlocks) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%w: remote pivot %d != requested %d&quot;</span>, errInvalidChain, pivot.Number, head.Number.Uint64()-<span class="type">uint64</span>(fsMinFullBlocks))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> head, pivot, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">      p.log.Debug(<span class="string">&quot;Waiting for head header timed out&quot;</span>, <span class="string">&quot;elapsed&quot;</span>, ttl)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errTimeout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> &lt;-d.bodyCh:</span><br><span class="line">    <span class="keyword">case</span> &lt;-d.receiptCh:</span><br><span class="line">      <span class="comment">// Out of bounds delivery, ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理-Head"><strong>处理 Head</strong></h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processHeaders takes batches of retrieved headers from an input channel and</span></span><br><span class="line"><span class="comment">// keeps processing and scheduling them into the header chain and downloader&#x27;s</span></span><br><span class="line"><span class="comment">// queue until the stream ends or a failure occurs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> processHeaders(origin <span class="type">uint64</span>, td *big.Int) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// Keep a count of uncertain headers to roll back</span></span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    rollback    <span class="type">uint64</span> <span class="comment">// Zero means no rollback (fine as you can&#x27;t unroll the genesis)</span></span><br><span class="line">    rollbackErr <span class="type">error</span></span><br><span class="line">    mode        = d.getMode()</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> rollback &gt; <span class="number">0</span> &#123;</span><br><span class="line">      lastHeader, lastFastBlock, lastBlock := d.lightchain.CurrentHeader().Number, common.Big0, common.Big0</span><br><span class="line">      <span class="keyword">if</span> mode != LightSync &#123;</span><br><span class="line">        lastFastBlock = d.blockchain.CurrentFastBlock().Number()</span><br><span class="line">        lastBlock = d.blockchain.CurrentBlock().Number()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> err := d.lightchain.SetHead(rollback - <span class="number">1</span>); err != <span class="literal">nil</span> &#123; <span class="comment">// -1 to target the parent of the first uncertain block</span></span><br><span class="line">        <span class="comment">// We&#x27;re already unwinding the stack, only print the error to make it more visible</span></span><br><span class="line">        log.Error(<span class="string">&quot;Failed to roll back chain segment&quot;</span>, <span class="string">&quot;head&quot;</span>, rollback<span class="number">-1</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      curFastBlock, curBlock := common.Big0, common.Big0</span><br><span class="line">      <span class="keyword">if</span> mode != LightSync &#123;</span><br><span class="line">        curFastBlock = d.blockchain.CurrentFastBlock().Number()</span><br><span class="line">        curBlock = d.blockchain.CurrentBlock().Number()</span><br><span class="line">      &#125;</span><br><span class="line">      log.Warn(<span class="string">&quot;Rolled back chain segment&quot;</span>,</span><br><span class="line">        <span class="string">&quot;header&quot;</span>, fmt.Sprintf(<span class="string">&quot;%d-&gt;%d&quot;</span>, lastHeader, d.lightchain.CurrentHeader().Number),</span><br><span class="line">        <span class="string">&quot;fast&quot;</span>, fmt.Sprintf(<span class="string">&quot;%d-&gt;%d&quot;</span>, lastFastBlock, curFastBlock),</span><br><span class="line">        <span class="string">&quot;block&quot;</span>, fmt.Sprintf(<span class="string">&quot;%d-&gt;%d&quot;</span>, lastBlock, curBlock), <span class="string">&quot;reason&quot;</span>, rollbackErr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">// Wait for batches of headers to process</span></span><br><span class="line">  gotHeaders := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">      rollbackErr = errCanceled</span><br><span class="line">      <span class="keyword">return</span> errCanceled</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> headers := &lt;-d.headerProcCh:</span><br><span class="line">      <span class="comment">// Terminate header processing if we synced up</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Notify everyone that headers are fully processed</span></span><br><span class="line">        <span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">          <span class="keyword">select</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> ch &lt;- <span class="literal">false</span>:</span><br><span class="line">          <span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If no headers were retrieved at all, the peer violated its TD promise that it had a</span></span><br><span class="line">        <span class="comment">// better chain compared to ours. The only exception is if its promised blocks were</span></span><br><span class="line">        <span class="comment">// already imported by other means (e.g. fetcher):</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// R &lt;remote peer&gt;, L &lt;local node&gt;: Both at block 10</span></span><br><span class="line">        <span class="comment">// R: Mine block 11, and propagate it to L</span></span><br><span class="line">        <span class="comment">// L: Queue block 11 for import</span></span><br><span class="line">        <span class="comment">// L: Notice that R&#x27;s head and TD increased compared to ours, start sync</span></span><br><span class="line">        <span class="comment">// L: Import of block 11 finishes</span></span><br><span class="line">        <span class="comment">// L: Sync begins, and finds common ancestor at 11</span></span><br><span class="line">        <span class="comment">// L: Request new headers up from 11 (R&#x27;s TD was higher, it must have something)</span></span><br><span class="line">        <span class="comment">// R: Nothing to give</span></span><br><span class="line">        <span class="keyword">if</span> mode != LightSync &#123;</span><br><span class="line">          head := d.blockchain.CurrentBlock()</span><br><span class="line">          <span class="keyword">if</span> !gotHeaders &amp;&amp; td.Cmp(d.blockchain.GetTd(head.Hash(), head.NumberU64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errStallingPeer</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If fast or light syncing, ensure promised headers are indeed delivered. This is</span></span><br><span class="line">        <span class="comment">// needed to detect scenarios where an attacker feeds a bad pivot and then bails out</span></span><br><span class="line">        <span class="comment">// of delivering the post-pivot blocks that would flag the invalid content.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This check cannot be executed &quot;as is&quot; for full imports, since blocks may still be</span></span><br><span class="line">        <span class="comment">// queued for processing when the header download completes. However, as long as the</span></span><br><span class="line">        <span class="comment">// peer gave us something useful, we&#x27;re already happy/progressed (above check).</span></span><br><span class="line">        <span class="keyword">if</span> mode == FastSync || mode == LightSync &#123;</span><br><span class="line">          head := d.lightchain.CurrentHeader()</span><br><span class="line">          <span class="keyword">if</span> td.Cmp(d.lightchain.GetTd(head.Hash(), head.Number.Uint64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errStallingPeer</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Disable any rollback and return</span></span><br><span class="line">        rollback = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Otherwise split the chunk of headers into batches and process them</span></span><br><span class="line">      gotHeaders = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">for</span> <span class="built_in">len</span>(headers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Terminate if something failed in between processing chunks</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">          rollbackErr = errCanceled</span><br><span class="line">          <span class="keyword">return</span> errCanceled</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Select the next chunk of headers to import</span></span><br><span class="line">        limit := maxHeadersProcess</span><br><span class="line">        <span class="keyword">if</span> limit &gt; <span class="built_in">len</span>(headers) &#123;</span><br><span class="line">          limit = <span class="built_in">len</span>(headers)</span><br><span class="line">        &#125;</span><br><span class="line">        chunk := headers[:limit]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In case of header only syncing, validate the chunk immediately</span></span><br><span class="line">        <span class="keyword">if</span> mode == FastSync || mode == LightSync &#123;</span><br><span class="line">          <span class="comment">// If we&#x27;re importing pure headers, verify based on their recentness</span></span><br><span class="line">          <span class="keyword">var</span> pivot <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">          d.pivotLock.RLock()</span><br><span class="line">          <span class="keyword">if</span> d.pivotHeader != <span class="literal">nil</span> &#123;</span><br><span class="line">            pivot = d.pivotHeader.Number.Uint64()</span><br><span class="line">          &#125;</span><br><span class="line">          d.pivotLock.RUnlock()</span><br><span class="line"></span><br><span class="line">          frequency := fsHeaderCheckFrequency</span><br><span class="line">          <span class="keyword">if</span> chunk[<span class="built_in">len</span>(chunk)<span class="number">-1</span>].Number.Uint64()+<span class="type">uint64</span>(fsHeaderForceVerify) &gt; pivot &#123;</span><br><span class="line">            frequency = <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> n, err := d.lightchain.InsertHeaderChain(chunk, frequency); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            rollbackErr = err</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If some headers were inserted, track them as uncertain</span></span><br><span class="line">            <span class="keyword">if</span> (mode == FastSync || frequency &gt; <span class="number">1</span>) &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; rollback == <span class="number">0</span> &#123;</span><br><span class="line">              rollback = chunk[<span class="number">0</span>].Number.Uint64()</span><br><span class="line">            &#125;</span><br><span class="line">            log.Warn(<span class="string">&quot;Invalid header encountered&quot;</span>, <span class="string">&quot;number&quot;</span>, chunk[n].Number, <span class="string">&quot;hash&quot;</span>, chunk[n].Hash(), <span class="string">&quot;parent&quot;</span>, chunk[n].ParentHash, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w: %v&quot;</span>, errInvalidChain, err)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// All verifications passed, track all headers within the alloted limits</span></span><br><span class="line">          <span class="keyword">if</span> mode == FastSync &#123;</span><br><span class="line">            head := chunk[<span class="built_in">len</span>(chunk)<span class="number">-1</span>].Number.Uint64()</span><br><span class="line">            <span class="keyword">if</span> head-rollback &gt; <span class="type">uint64</span>(fsHeaderSafetyNet) &#123;</span><br><span class="line">              rollback = head - <span class="type">uint64</span>(fsHeaderSafetyNet)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              rollback = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Unless we&#x27;re doing light chains, schedule the headers for associated content retrieval</span></span><br><span class="line">        <span class="keyword">if</span> mode == FullSync || mode == FastSync &#123;</span><br><span class="line">          <span class="comment">// If we&#x27;ve reached the allowed number of pending headers, stall a bit</span></span><br><span class="line">          <span class="keyword">for</span> d.queue.PendingBlocks() &gt;= maxQueuedHeaders || d.queue.PendingReceipts() &gt;= maxQueuedHeaders &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">              rollbackErr = errCanceled</span><br><span class="line">              <span class="keyword">return</span> errCanceled</span><br><span class="line">            <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Otherwise insert the headers for content retrieval</span></span><br><span class="line">          inserts := d.queue.Schedule(chunk, origin)</span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">len</span>(inserts) != <span class="built_in">len</span>(chunk) &#123;</span><br><span class="line">            rollbackErr = fmt.Errorf(<span class="string">&quot;stale headers: len inserts %v len(chunk) %v&quot;</span>, <span class="built_in">len</span>(inserts), <span class="built_in">len</span>(chunk))</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w: stale headers&quot;</span>, errBadPeer)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        headers = headers[limit:]</span><br><span class="line">        origin += <span class="type">uint64</span>(limit)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Update the highest block number we know if a higher one is found.</span></span><br><span class="line">      d.syncStatsLock.Lock()</span><br><span class="line">      <span class="keyword">if</span> d.syncStatsChainHeight &lt; origin &#123;</span><br><span class="line">        d.syncStatsChainHeight = origin - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      d.syncStatsLock.Unlock()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Signal the content downloaders of the availablility of new tasks</span></span><br><span class="line">      <span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">chan</span> <span class="type">bool</span>&#123;d.bodyWakeCh, d.receiptWakeCh&#125; &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ch &lt;- <span class="literal">true</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步-Body"><strong>同步 Body</strong></h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchBodies iteratively downloads the scheduled block bodies, taking any</span></span><br><span class="line"><span class="comment">// available peers, reserving a chunk of blocks for each, waiting for delivery</span></span><br><span class="line"><span class="comment">// and also periodically checking for timeouts.</span></span><br><span class="line"><span class="title function_">func</span> (d *<span class="title class_">Downloader</span>) <span class="title function_">fetchBodies</span>(<span class="keyword">from</span> uint64) error &#123;</span><br><span class="line">  log.<span class="title class_">Debug</span>(<span class="string">&quot;Downloading block bodies&quot;</span>, <span class="string">&quot;origin&quot;</span>, <span class="keyword">from</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">var</span> (</span><br><span class="line">    deliver = <span class="title function_">func</span>(packet dataPack) (int, error) &#123;</span><br><span class="line">      pack := packet.(*bodyPack)</span><br><span class="line">      <span class="keyword">return</span> d.<span class="property">queue</span>.<span class="title class_">DeliverBodies</span>(pack.<span class="property">peerID</span>, pack.<span class="property">transactions</span>, pack.<span class="property">uncles</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    expire   = <span class="title function_">func</span>() map[string]int &#123; <span class="keyword">return</span> d.<span class="property">queue</span>.<span class="title class_">ExpireBodies</span>(d.<span class="title function_">requestTTL</span>()) &#125;</span><br><span class="line">    fetch    = <span class="title function_">func</span>(p *peerConnection, req *fetchRequest) error &#123; <span class="keyword">return</span> p.<span class="title class_">FetchBodies</span>(req) &#125;</span><br><span class="line">    capacity = <span class="title function_">func</span>(p *peerConnection) int &#123; <span class="keyword">return</span> p.<span class="title class_">BlockCapacity</span>(d.<span class="title function_">requestRTT</span>()) &#125;</span><br><span class="line">    setIdle  = <span class="title function_">func</span>(<span class="params">p *peerConnection, accepted int, deliveryTime time.Time</span>) &#123; p.<span class="title class_">SetBodiesIdle</span>(accepted, deliveryTime) &#125;</span><br><span class="line">  )</span><br><span class="line">  err := d.<span class="title function_">fetchParts</span>(d.<span class="property">bodyCh</span>, deliver, d.<span class="property">bodyWakeCh</span>, expire,</span><br><span class="line">    d.<span class="property">queue</span>.<span class="property">PendingBlocks</span>, d.<span class="property">queue</span>.<span class="property">InFlightBlocks</span>, d.<span class="property">queue</span>.<span class="property">ReserveBodies</span>,</span><br><span class="line">    d.<span class="property">bodyFetchHook</span>, fetch, d.<span class="property">queue</span>.<span class="property">CancelBodies</span>, capacity, d.<span class="property">peers</span>.<span class="property">BodyIdlePeers</span>, setIdle, <span class="string">&quot;bodies&quot;</span>)</span><br><span class="line"></span><br><span class="line">  log.<span class="title class_">Debug</span>(<span class="string">&quot;Block body download terminated&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DeliverBodies injects a new batch of block bodies received from a remote node.</span></span><br><span class="line"><span class="title function_">func</span> (d *<span class="title class_">Downloader</span>) <span class="title class_">DeliverBodies</span>(id string, transactions [][]*types.<span class="property">Transaction</span>, uncles [][]*types.<span class="property">Header</span>) error &#123;</span><br><span class="line">  <span class="keyword">return</span> d.<span class="title function_">deliver</span>(d.<span class="property">bodyCh</span>, &amp;bodyPack&#123;id, transactions, uncles&#125;, bodyInMeter, bodyDropMeter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// deliver injects a new batch of data received from a remote node.</span></span><br><span class="line"><span class="title function_">func</span> (d *<span class="title class_">Downloader</span>) <span class="title function_">deliver</span>(destCh chan dataPack, packet dataPack, inMeter, dropMeter metrics.<span class="property">Meter</span>) (err error) &#123;</span><br><span class="line">  <span class="comment">// Update the delivery metrics for both good and failed deliveries</span></span><br><span class="line">  inMeter.<span class="title class_">Mark</span>(<span class="title function_">int64</span>(packet.<span class="title class_">Items</span>()))</span><br><span class="line">  defer <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      dropMeter.<span class="title class_">Mark</span>(<span class="title function_">int64</span>(packet.<span class="title class_">Items</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">// Deliver or abort if the sync is canceled while queuing</span></span><br><span class="line">  d.<span class="property">cancelLock</span>.<span class="title class_">RLock</span>()</span><br><span class="line">  cancel := d.<span class="property">cancelCh</span></span><br><span class="line">  d.<span class="property">cancelLock</span>.<span class="title class_">RUnlock</span>()</span><br><span class="line">  <span class="keyword">if</span> cancel == nil &#123;</span><br><span class="line">    <span class="keyword">return</span> errNoSyncActive</span><br><span class="line">  &#125;</span><br><span class="line">  select &#123;</span><br><span class="line">  <span class="keyword">case</span> destCh &lt;- <span class="attr">packet</span>:</span><br><span class="line">    <span class="keyword">return</span> nil</span><br><span class="line">  <span class="keyword">case</span> &lt;-cancel:</span><br><span class="line">    return errNoSyncActive</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func (d *Downloader) fetchParts(deliveryCh chan dataPack, deliver func(dataPack) (int, error), wakeCh chan bool,</span><br><span class="line">  expire func() map[string]int, pending func() int, inFlight func() bool, reserve func(*peerConnection, int) (*fetchRequest, bool, bool),</span><br><span class="line">  fetchHook func([]*types.Header), fetch func(*peerConnection, *fetchRequest) error, cancel func(*fetchRequest), capacity func(*peerConnection) int,</span><br><span class="line">  idle func() ([]*peerConnection, int), setIdle func(*peerConnection, int, time.Time), kind string) error &#123;</span><br><span class="line"></span><br><span class="line">  // Create a ticker to detect expired retrieval tasks</span><br><span class="line">  ticker := time.NewTicker(100 * time.Millisecond)</span><br><span class="line">  defer ticker.Stop()</span><br><span class="line"></span><br><span class="line">  update := make(chan struct&#123;&#125;, 1)</span><br><span class="line"></span><br><span class="line">  // Prepare the queue and fetch block parts until the block header fetcher&#x27;s done</span><br><span class="line">  finished := false</span><br><span class="line">  for &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-d.cancelCh:</span><br><span class="line">      return errCanceled</span><br><span class="line"></span><br><span class="line">    case packet := &lt;-deliveryCh:</span><br><span class="line">      deliveryTime := time.Now()</span><br><span class="line">      // If the peer was previously banned and failed to deliver its pack</span><br><span class="line">      // in a reasonable time frame, ignore its message.</span><br><span class="line">      if peer := d.peers.Peer(packet.PeerId()); peer != nil &#123;</span><br><span class="line">        // Deliver the received chunk of data and check chain validity</span><br><span class="line">        accepted, err := deliver(packet)</span><br><span class="line">        if errors.Is(err, errInvalidChain) &#123;</span><br><span class="line">          return err</span><br><span class="line">        &#125;</span><br><span class="line">        // Unless a peer delivered something completely else than requested (usually</span><br><span class="line">        // caused by a timed out request which came through in the end), set it to</span><br><span class="line">        // idle. If the delivery&#x27;s stale, the peer should have already been idled.</span><br><span class="line">        if !errors.Is(err, errStaleDelivery) &#123;</span><br><span class="line">          setIdle(peer, accepted, deliveryTime)</span><br><span class="line">        &#125;</span><br><span class="line">        // Issue a log to the user to see what&#x27;s going on</span><br><span class="line">        switch &#123;</span><br><span class="line">        case err == nil &amp;&amp; packet.Items() == 0:</span><br><span class="line">          peer.log.Trace(&quot;Requested data not delivered&quot;, &quot;type&quot;, kind)</span><br><span class="line">        case err == nil:</span><br><span class="line">          peer.log.Trace(&quot;Delivered new batch of data&quot;, &quot;type&quot;, kind, &quot;count&quot;, packet.Stats())</span><br><span class="line">        default:</span><br><span class="line">          peer.log.Debug(&quot;Failed to deliver retrieved data&quot;, &quot;type&quot;, kind, &quot;err&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Blocks assembled, try to update the progress</span><br><span class="line">      select &#123;</span><br><span class="line">      case update &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">      default:</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    case cont := &lt;-wakeCh:</span><br><span class="line">      // The header fetcher sent a continuation flag, check if it&#x27;s done</span><br><span class="line">      if !cont &#123;</span><br><span class="line">        finished = true</span><br><span class="line">      &#125;</span><br><span class="line">      // Headers arrive, try to update the progress</span><br><span class="line">      select &#123;</span><br><span class="line">      case update &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">      default:</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    case &lt;-ticker.C:</span><br><span class="line">      // Sanity check update the progress</span><br><span class="line">      select &#123;</span><br><span class="line">      case update &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">      default:</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    case &lt;-update:</span><br><span class="line">      // Short circuit if we lost all our peers</span><br><span class="line">      if d.peers.Len() == 0 &#123;</span><br><span class="line">        return errNoPeers</span><br><span class="line">      &#125;</span><br><span class="line">      // Check for fetch request timeouts and demote the responsible peers</span><br><span class="line">      for pid, fails := range expire() &#123;</span><br><span class="line">        if peer := d.peers.Peer(pid); peer != nil &#123;</span><br><span class="line">          // If a lot of retrieval elements expired, we might have overestimated the remote peer or perhaps</span><br><span class="line">          // ourselves. Only reset to minimal throughput but don&#x27;t drop just yet. If even the minimal times</span><br><span class="line">          // out that sync wise we need to get rid of the peer.</span><br><span class="line">          //</span><br><span class="line">          // The reason the minimum threshold is 2 is because the downloader tries to estimate the bandwidth</span><br><span class="line">          // and latency of a peer separately, which requires pushing the measures capacity a bit and seeing</span><br><span class="line">          // how response times reacts, to it always requests one more than the minimum (i.e. min 2).</span><br><span class="line">          if fails &gt; 2 &#123;</span><br><span class="line">            peer.log.Trace(&quot;Data delivery timed out&quot;, &quot;type&quot;, kind)</span><br><span class="line">            setIdle(peer, 0, time.Now())</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            peer.log.Debug(&quot;Stalling delivery, dropping&quot;, &quot;type&quot;, kind)</span><br><span class="line"></span><br><span class="line">            if d.dropPeer == nil &#123;</span><br><span class="line">              // The dropPeer method is nil when `--copydb` is used for a local copy.</span><br><span class="line">              // Timeouts can occur if e.g. compaction hits at the wrong time, and can be ignored</span><br><span class="line">              peer.log.Warn(&quot;Downloader wants to drop peer, but peerdrop-function is not set&quot;, &quot;peer&quot;, pid)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              d.dropPeer(pid)</span><br><span class="line"></span><br><span class="line">              // If this peer was the master peer, abort sync immediately</span><br><span class="line">              d.cancelLock.RLock()</span><br><span class="line">              master := pid == d.cancelPeer</span><br><span class="line">              d.cancelLock.RUnlock()</span><br><span class="line"></span><br><span class="line">              if master &#123;</span><br><span class="line">                d.cancel()</span><br><span class="line">                return errTimeout</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // If there&#x27;s nothing more to fetch, wait or terminate</span><br><span class="line">      if pending() == 0 &#123;</span><br><span class="line">        if !inFlight() &amp;&amp; finished &#123;</span><br><span class="line">          log.Debug(&quot;Data fetching completed&quot;, &quot;type&quot;, kind)</span><br><span class="line">          return nil</span><br><span class="line">        &#125;</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">      // Send a download request to all idle peers, until throttled</span><br><span class="line">      progressed, throttled, running := false, false, inFlight()</span><br><span class="line">      idles, total := idle()</span><br><span class="line">      pendCount := pending()</span><br><span class="line">      for _, peer := range idles &#123;</span><br><span class="line">        // Short circuit if throttling activated</span><br><span class="line">        if throttled &#123;</span><br><span class="line">          break</span><br><span class="line">        &#125;</span><br><span class="line">        // Short circuit if there is no more available task.</span><br><span class="line">        if pendCount = pending(); pendCount == 0 &#123;</span><br><span class="line">          break</span><br><span class="line">        &#125;</span><br><span class="line">        // Reserve a chunk of fetches for a peer. A nil can mean either that</span><br><span class="line">        // no more headers are available, or that the peer is known not to</span><br><span class="line">        // have them.</span><br><span class="line">        request, progress, throttle := reserve(peer, capacity(peer))</span><br><span class="line">        if progress &#123;</span><br><span class="line">          progressed = true</span><br><span class="line">        &#125;</span><br><span class="line">        if throttle &#123;</span><br><span class="line">          throttled = true</span><br><span class="line">          throttleCounter.Inc(1)</span><br><span class="line">        &#125;</span><br><span class="line">        if request == nil &#123;</span><br><span class="line">          continue</span><br><span class="line">        &#125;</span><br><span class="line">        if request.From &gt; 0 &#123;</span><br><span class="line">          peer.log.Trace(&quot;Requesting new batch of data&quot;, &quot;type&quot;, kind, &quot;from&quot;, request.From)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          peer.log.Trace(&quot;Requesting new batch of data&quot;, &quot;type&quot;, kind, &quot;count&quot;, len(request.Headers), &quot;from&quot;, request.Headers[0].Number)</span><br><span class="line">        &#125;</span><br><span class="line">        // Fetch the chunk and make sure any errors return the hashes to the queue</span><br><span class="line">        if fetchHook != nil &#123;</span><br><span class="line">          fetchHook(request.Headers)</span><br><span class="line">        &#125;</span><br><span class="line">        if err := fetch(peer, request); err != nil &#123;</span><br><span class="line">          // Although we could try and make an attempt to fix this, this error really</span><br><span class="line">          // means that we&#x27;ve double allocated a fetch task to a peer. If that is the</span><br><span class="line">          // case, the internal state of the downloader and the queue is very wrong so</span><br><span class="line">          // better hard crash and note the error instead of silently accumulating into</span><br><span class="line">          // a much bigger issue.</span><br><span class="line">          panic(fmt.Sprintf(&quot;%v: %s fetch assignment failed&quot;, peer, kind))</span><br><span class="line">        &#125;</span><br><span class="line">        running = true</span><br><span class="line">      &#125;</span><br><span class="line">      // Make sure that we have peers available for fetching. If all peers have been tried</span><br><span class="line">      // and all failed throw an error</span><br><span class="line">      if !progressed &amp;&amp; !throttled &amp;&amp; !running &amp;&amp; len(idles) == total &amp;&amp; pendCount &gt; 0 &#123;</span><br><span class="line">        return errPeersUnavailable</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步收据"><strong>同步收据</strong></h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchReceipts iteratively downloads the scheduled block receipts, taking any</span></span><br><span class="line"><span class="comment">// available peers, reserving a chunk of receipts for each, waiting for delivery</span></span><br><span class="line"><span class="comment">// and also periodically checking for timeouts.</span></span><br><span class="line"><span class="title function_">func</span> (d *<span class="title class_">Downloader</span>) <span class="title function_">fetchReceipts</span>(<span class="keyword">from</span> uint64) error &#123;</span><br><span class="line">  log.<span class="title class_">Debug</span>(<span class="string">&quot;Downloading transaction receipts&quot;</span>, <span class="string">&quot;origin&quot;</span>, <span class="keyword">from</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">var</span> (</span><br><span class="line">    deliver = <span class="title function_">func</span>(packet dataPack) (int, error) &#123;</span><br><span class="line">      pack := packet.(*receiptPack)</span><br><span class="line">      <span class="keyword">return</span> d.<span class="property">queue</span>.<span class="title class_">DeliverReceipts</span>(pack.<span class="property">peerID</span>, pack.<span class="property">receipts</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    expire   = <span class="title function_">func</span>() map[string]int &#123; <span class="keyword">return</span> d.<span class="property">queue</span>.<span class="title class_">ExpireReceipts</span>(d.<span class="title function_">requestTTL</span>()) &#125;</span><br><span class="line">    fetch    = <span class="title function_">func</span>(p *peerConnection, req *fetchRequest) error &#123; <span class="keyword">return</span> p.<span class="title class_">FetchReceipts</span>(req) &#125;</span><br><span class="line">    capacity = <span class="title function_">func</span>(p *peerConnection) int &#123; <span class="keyword">return</span> p.<span class="title class_">ReceiptCapacity</span>(d.<span class="title function_">requestRTT</span>()) &#125;</span><br><span class="line">    setIdle  = <span class="title function_">func</span>(<span class="params">p *peerConnection, accepted int, deliveryTime time.Time</span>) &#123;</span><br><span class="line">      p.<span class="title class_">SetReceiptsIdle</span>(accepted, deliveryTime)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  err := d.<span class="title function_">fetchParts</span>(d.<span class="property">receiptCh</span>, deliver, d.<span class="property">receiptWakeCh</span>, expire,</span><br><span class="line">    d.<span class="property">queue</span>.<span class="property">PendingReceipts</span>, d.<span class="property">queue</span>.<span class="property">InFlightReceipts</span>, d.<span class="property">queue</span>.<span class="property">ReserveReceipts</span>,</span><br><span class="line">    d.<span class="property">receiptFetchHook</span>, fetch, d.<span class="property">queue</span>.<span class="property">CancelReceipts</span>, capacity, d.<span class="property">peers</span>.<span class="property">ReceiptIdlePeers</span>, setIdle, <span class="string">&quot;receipts&quot;</span>)</span><br><span class="line"></span><br><span class="line">  log.<span class="title class_">Debug</span>(<span class="string">&quot;Transaction receipt download terminated&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DeliverReceipts injects a new batch of receipts received from a remote node.</span></span><br><span class="line"><span class="title function_">func</span> (d *<span class="title class_">Downloader</span>) <span class="title class_">DeliverReceipts</span>(id string, receipts [][]*types.<span class="property">Receipt</span>) error &#123;</span><br><span class="line">  <span class="keyword">return</span> d.<span class="title function_">deliver</span>(d.<span class="property">receiptCh</span>, &amp;receiptPack&#123;id, receipts&#125;, receiptInMeter, receiptDropMeter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// deliver injects a new batch of data received from a remote node.</span></span><br><span class="line"><span class="title function_">func</span> (d *<span class="title class_">Downloader</span>) <span class="title function_">deliver</span>(destCh chan dataPack, packet dataPack, inMeter, dropMeter metrics.<span class="property">Meter</span>) (err error) &#123;</span><br><span class="line">  <span class="comment">// Update the delivery metrics for both good and failed deliveries</span></span><br><span class="line">  inMeter.<span class="title class_">Mark</span>(<span class="title function_">int64</span>(packet.<span class="title class_">Items</span>()))</span><br><span class="line">  defer <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      dropMeter.<span class="title class_">Mark</span>(<span class="title function_">int64</span>(packet.<span class="title class_">Items</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">// Deliver or abort if the sync is canceled while queuing</span></span><br><span class="line">  d.<span class="property">cancelLock</span>.<span class="title class_">RLock</span>()</span><br><span class="line">  cancel := d.<span class="property">cancelCh</span></span><br><span class="line">  d.<span class="property">cancelLock</span>.<span class="title class_">RUnlock</span>()</span><br><span class="line">  <span class="keyword">if</span> cancel == nil &#123;</span><br><span class="line">    <span class="keyword">return</span> errNoSyncActive</span><br><span class="line">  &#125;</span><br><span class="line">  select &#123;</span><br><span class="line">  <span class="keyword">case</span> destCh &lt;- <span class="attr">packet</span>:</span><br><span class="line">    <span class="keyword">return</span> nil</span><br><span class="line">  <span class="keyword">case</span> <span class="language-xml">&lt;-cancel:</span></span><br><span class="line"><span class="language-xml">    return errNoSyncActive</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>Content</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processFullSyncContent takes fetch results from the queue and imports them into the chain.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> processFullSyncContent() <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    results := d.queue.Results(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(results) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> d.chainInsertHook != <span class="literal">nil</span> &#123;</span><br><span class="line">      d.chainInsertHook(results)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := d.importBlockResults(results); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// processFastSyncContent takes fetch results from the queue and writes them to the</span></span><br><span class="line"><span class="comment">// database. It also controls the synchronisation of state nodes of the pivot block.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Downloader)</span></span> processFastSyncContent() <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// Start syncing state of the reported head block. This should get us most of</span></span><br><span class="line">  <span class="comment">// the state of the pivot block.</span></span><br><span class="line">  d.pivotLock.RLock()</span><br><span class="line">  sync := d.syncState(d.pivotHeader.Root)</span><br><span class="line">  d.pivotLock.RUnlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// The `sync` object is replaced every time the pivot moves. We need to</span></span><br><span class="line">    <span class="comment">// defer close the very last active one, hence the lazy evaluation vs.</span></span><br><span class="line">    <span class="comment">// calling defer sync.Cancel() !!!</span></span><br><span class="line">    sync.Cancel()</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  closeOnErr := <span class="function"><span class="keyword">func</span><span class="params">(s *stateSync)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := s.Wait(); err != <span class="literal">nil</span> &amp;&amp; err != errCancelStateFetch &amp;&amp; err != errCanceled &amp;&amp; err != snap.ErrCancelled &#123;</span><br><span class="line">      d.queue.Close() <span class="comment">// wake up Results</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">go</span> closeOnErr(sync)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// To cater for moving pivot points, track the pivot block and subsequently</span></span><br><span class="line">  <span class="comment">// accumulated download results separately.</span></span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    oldPivot *fetchResult   <span class="comment">// Locked in pivot block, might change eventually</span></span><br><span class="line">    oldTail  []*fetchResult <span class="comment">// Downloaded content after the pivot</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// Wait for the next batch of downloaded data to be available, and if the pivot</span></span><br><span class="line">    <span class="comment">// block became stale, move the goalpost</span></span><br><span class="line">    results := d.queue.Results(oldPivot == <span class="literal">nil</span>) <span class="comment">// Block if we&#x27;re not monitoring pivot staleness</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(results) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// If pivot sync is done, stop</span></span><br><span class="line">      <span class="keyword">if</span> oldPivot == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.Cancel()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If sync failed, stop</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-d.cancelCh:</span><br><span class="line">        sync.Cancel()</span><br><span class="line">        <span class="keyword">return</span> errCanceled</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> d.chainInsertHook != <span class="literal">nil</span> &#123;</span><br><span class="line">      d.chainInsertHook(results)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If we haven&#x27;t downloaded the pivot block yet, check pivot staleness</span></span><br><span class="line">    <span class="comment">// notifications from the header downloader</span></span><br><span class="line">    d.pivotLock.RLock()</span><br><span class="line">    pivot := d.pivotHeader</span><br><span class="line">    d.pivotLock.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> oldPivot == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> pivot.Root != sync.root &#123;</span><br><span class="line">        sync.Cancel()</span><br><span class="line">        sync = d.syncState(pivot.Root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> closeOnErr(sync)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      results = <span class="built_in">append</span>(<span class="built_in">append</span>([]*fetchResult&#123;oldPivot&#125;, oldTail...), results...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Split around the pivot block and process the two sides via fast/full sync</span></span><br><span class="line">    <span class="keyword">if</span> atomic.LoadInt32(&amp;d.committed) == <span class="number">0</span> &#123;</span><br><span class="line">      latest := results[<span class="built_in">len</span>(results)<span class="number">-1</span>].Header</span><br><span class="line">      <span class="comment">// If the height is above the pivot block by 2 sets, it means the pivot</span></span><br><span class="line">      <span class="comment">// become stale in the network and it was garbage collected, move to a</span></span><br><span class="line">      <span class="comment">// new pivot.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Note, we have `reorgProtHeaderDelay` number of blocks withheld, Those</span></span><br><span class="line">      <span class="comment">// need to be taken into account, otherwise we&#x27;re detecting the pivot move</span></span><br><span class="line">      <span class="comment">// late and will drop peers due to unavailable state!!!</span></span><br><span class="line">      <span class="keyword">if</span> height := latest.Number.Uint64(); height &gt;= pivot.Number.Uint64()+<span class="number">2</span>*<span class="type">uint64</span>(fsMinFullBlocks)-<span class="type">uint64</span>(reorgProtHeaderDelay) &#123;</span><br><span class="line">        log.Warn(<span class="string">&quot;Pivot became stale, moving&quot;</span>, <span class="string">&quot;old&quot;</span>, pivot.Number.Uint64(), <span class="string">&quot;new&quot;</span>, height-<span class="type">uint64</span>(fsMinFullBlocks)+<span class="type">uint64</span>(reorgProtHeaderDelay))</span><br><span class="line">        pivot = results[<span class="built_in">len</span>(results)<span class="number">-1</span>-fsMinFullBlocks+reorgProtHeaderDelay].Header <span class="comment">// must exist as lower old pivot is uncommitted</span></span><br><span class="line"></span><br><span class="line">        d.pivotLock.Lock()</span><br><span class="line">        d.pivotHeader = pivot</span><br><span class="line">        d.pivotLock.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out the pivot into the database so a rollback beyond it will</span></span><br><span class="line">        <span class="comment">// reenable fast sync</span></span><br><span class="line">        rawdb.WriteLastPivotNumber(d.stateDB, pivot.Number.Uint64())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    P, beforeP, afterP := splitAroundPivot(pivot.Number.Uint64(), results)</span><br><span class="line">    <span class="keyword">if</span> err := d.commitFastSyncData(beforeP, sync); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> P != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// If new pivot block found, cancel old state retrieval and restart</span></span><br><span class="line">      <span class="keyword">if</span> oldPivot != P &#123;</span><br><span class="line">        sync.Cancel()</span><br><span class="line">        sync = d.syncState(P.Header.Root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> closeOnErr(sync)</span><br><span class="line">        oldPivot = P</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Wait for completion, occasionally checking for pivot staleness</span></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-sync.done:</span><br><span class="line">        <span class="keyword">if</span> sync.err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> sync.err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := d.commitPivotBlock(P); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        oldPivot = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">        oldTail = afterP</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fast sync done, pivot commit done, full import</span></span><br><span class="line">    <span class="keyword">if</span> err := d.importBlockResults(afterP); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小问题</p>
</blockquote>
<p><strong>问题：</strong> <em>light</em> 节点与 <em>full</em> 节点是如何交互的？<br>
<strong>解答：</strong> 首先，light 节点会维护多个与 full 节点的 p2p 连接。然后，当 light 节点需要与 full 节点交互时，会将需要发送的请求放到一个请求队列中。light 节点会启动一个 goroutine 不断从请求队列里获取请求，然后从 p2p 节点列表里选一个当前最好用的节点，将请求发出去。请求得到的结果会发到本地数据库和缓存里。</p>
<p>作者：Ashton<br>
链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/b31c208acaaa">https://www.jianshu.com/p/b31c208acaaa</a><br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<blockquote>
<p>转载于<a target="_blank" rel="noopener external nofollow noreferrer" href="https://cloud.tencent.com/developer/article/1850727">以太坊区块同步 </a></p>
</blockquote>
<h2 id="参考链接"><strong>参考链接</strong></h2>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/427fbc3a25f9">https://www.jianshu.com/p/427fbc3a25f9</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/pulong0748/article/details/111574388">https://blog.csdn.net/pulong0748/article/details/111574388</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz">Michael(Jiahao) Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz/geth/block-sync/">https://www.blog-blockchain.xyz/geth/block-sync/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/geth/">geth</a></div><div class="post-share"><div class="social-share" data-image="/images/geth.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/fp/FP-haskell-1/" title="Haskell(一)入门"><img class="cover" src="/images/haskell.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Haskell(一)入门</div></div><div class="info-2"><div class="info-item-1"> Haskell(一)入门Haskell(二)函数式编程Haskell(三) MonadHaskell(四)总结和工具链Haskell(五) 总结和展望Haskell(六) Project Euler 练习1-26  前言 这个系列主要介绍典型的函数式程序设计语言（Functional programming languages，FP）和逻辑式程序设计语言（Logic programming languages，LP），将会分别以 Haskell 和 datalog（主要是 souffle）作为例子，简单的入门和理解。 理解典型的 FP 对于深入学习程序设计语言挺好处的。我们先从 haskell 开始 参考资料：  haskell 官网 Haskell 趣学指南，英文原版也很不错。 快速查阅库文档 最推荐的查阅手册，能够直接点击 Quick Jump 搜索关键词，这也是我最常用的文档 官方 WiKi如果有不懂的术语，那么很推荐先在 wiki 上查找。 可以参考的入门课程 资源汇总 交流学习群、交流学习群...</div></div></div></a><a class="pagination-related" href="/geth/MPT-Tree/" title="MPT树"><img class="cover" src="/images/geth.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">MPT树</div></div><div class="info-2"><div class="info-item-1"> 交易的签名理解收据receipt理解区块理解交易blockchain核心布隆过滤器原理forkId 解读oracle 原理和实现交易池分析TxList 解读MPT树区块同步geth源码学习——介绍How Geth starts its server   由于MPT 树不属于core部分所以有些地方并没有详细的解读，仅供参考。 由于该部分网上的解读都差异不大，故该文章大部分是进行整合，并且加上个人阅读源码的一些看法，所有图片都已经上传到个人仓库。 感谢前辈的精湛分析！   前缀树 Trie 前缀树（又称字典树），通常来说，一个前缀树是用来存储字符串的。前缀树的每一个节点代表一个字符串（前缀）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的原始字符串，以及通往该子节点路径上所有的字符组成的。如下图所示：  Trie 的结点看上去是这样子的：  [ [Ia, Ib, … I*], value]  其中 [Ia, Ib, ... I*] 在本文中我们将其称为结点的 索引数组 ，它以 key...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/geth/MPT-Tree/" title="MPT树"><img class="cover" src="/images/geth.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="info-item-2">MPT树</div></div><div class="info-2"><div class="info-item-1"> 交易的签名理解收据receipt理解区块理解交易blockchain核心布隆过滤器原理forkId 解读oracle 原理和实现交易池分析TxList 解读MPT树区块同步geth源码学习——介绍How Geth starts its server   由于MPT 树不属于core部分所以有些地方并没有详细的解读，仅供参考。 由于该部分网上的解读都差异不大，故该文章大部分是进行整合，并且加上个人阅读源码的一些看法，所有图片都已经上传到个人仓库。 感谢前辈的精湛分析！   前缀树 Trie 前缀树（又称字典树），通常来说，一个前缀树是用来存储字符串的。前缀树的每一个节点代表一个字符串（前缀）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的原始字符串，以及通往该子节点路径上所有的字符组成的。如下图所示：  Trie 的结点看上去是这样子的：  [ [Ia, Ib, … I*], value]  其中 [Ia, Ib, ... I*] 在本文中我们将其称为结点的 索引数组 ，它以 key...</div></div></div></a><a class="pagination-related" href="/geth/Geth-Unveiled-Ethereum-Startup/" title="How Geth starts its server"><img class="cover" src="/images/geth.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-13</div><div class="info-item-2">How Geth starts its server</div></div><div class="info-2"><div class="info-item-1"> 交易的签名理解收据receipt理解区块理解交易blockchain核心布隆过滤器原理forkId 解读oracle 原理和实现交易池分析TxList 解读MPT树区块同步geth源码学习——介绍How Geth starts its server  When starting up, the Geth client begins by parsing the command line parameters. This process kicks off with the geth function: func geth(ctx *cli.Context) error  at cmd/geth/main.go:326 where the geth prepares the metric if enabled. Subsequently, the makeFullNode function takes over. It reads the provided configuration file or command line flags. As a result, it...</div></div></div></a><a class="pagination-related" href="/geth/blockchain-core/" title="blockchain核心"><img class="cover" src="/images/geth.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="info-item-2">blockchain核心</div></div><div class="info-2"><div class="info-item-1"> 交易的签名理解收据receipt理解区块理解交易blockchain核心布隆过滤器原理forkId 解读oracle 原理和实现交易池分析TxList 解读MPT树区块同步geth源码学习——介绍How Geth starts its server   参考： 以太坊 blockchain 源码分析 - mindcarver - 博客园 (cnblogs.com)   主要部分转载：以太坊 blockchain 源码分析  blockchain 关键元素  db：持久化到底层数据储存，即 leveldb（注意不是 MySQL）（源码core/rawdb）；(参考文章：)Leveldb 基本介绍和使用指南 - 知乎 (zhihu.com) 以及对应的百科 [LevelDB_百度百科 (baidu.com)](https://baike.baidu.com/item/LevelDB/6416354#:~:text= Leveldb 是一个 google 实现的非常高效的 kv 数据库，目前的版本 1.2 能够支持 billion 级别的数据量了。...</div></div></div></a><a class="pagination-related" href="/geth/blocks/" title="理解区块"><img class="cover" src="/images/geth.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="info-item-2">理解区块</div></div><div class="info-2"><div class="info-item-1"> 交易的签名理解收据receipt理解区块理解交易blockchain核心布隆过滤器原理forkId 解读oracle 原理和实现交易池分析TxList 解读MPT树区块同步geth源码学习——介绍How Geth starts its server  结构定义 区块  首先我们需要明白区块的结构。 123456789101112131415161718192021// Block represents an entire block in the Ethereum blockchain.type Block struct &#123;   header       *Header      //区块头   uncles       []*Header    //引用的叔块   transactions Transactions //交易   // caches   hash atomic.Value //区块哈希   size atomic.Value //区块大小   // Td is used by package core to store the total...</div></div></div></a><a class="pagination-related" href="/geth/bloom-filter/" title="布隆过滤器原理"><img class="cover" src="/images/geth.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="info-item-2">布隆过滤器原理</div></div><div class="info-2"><div class="info-item-1"> 交易的签名理解收据receipt理解区块理解交易blockchain核心布隆过滤器原理forkId 解读oracle 原理和实现交易池分析TxList 解读MPT树区块同步geth源码学习——介绍How Geth starts its server  介绍  布隆过滤器（英语：Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。  可见，它解决的核心问题是 检索一个元素是否在一个集合中。原理大致如下： 当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个二进制数组中的 K 个位置，把这些位置的值设置为 1。检索时，我们只要观察这些对应的位置的值是不是都是 1 就（大约）知道集合中有没有检索的元素：如果这 K 个位置中有任何一个 0，则被检索元素一定不在集合中；如果都是...</div></div></div></a><a class="pagination-related" href="/geth/forkId/" title="forkId 解读"><img class="cover" src="/images/geth.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="info-item-2">forkId 解读</div></div><div class="info-2"><div class="info-item-1"> 交易的签名理解收据receipt理解区块理解交易blockchain核心布隆过滤器原理forkId 解读oracle 原理和实现交易池分析TxList 解读MPT树区块同步geth源码学习——介绍How Geth starts its server  EIP-2124 因为 core/forkId 包是 EIP-2124 的实现，因此我们先了解 EIP-2124 的内容。 目的  记住以太坊是向后兼容！  以太坊节点之前寻找其他节点的方式是：随机的选择可以连接的节点，再去判断节点是否对自己有用。但是其他的节点可能是主网节点、测试网节点、私网节点、共识机制不一致的节点，这样“盲目”的寻找会浪费资源。 于是这个提案希望在连接前，其他节点可以发送自己的链配置，实现精确连接到有用节点。这个传递的信息在提案中被称作 fork identifier，它实现如下功能：  如果两个节点在不同的网络上，他们不应该考虑连接。 如果硬分叉通过，升级的节点应该拒绝未升级的节点。 如果两条链有相同的创世区块配置和链配置，但没有分叉（ETH /...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Michael(Jiahao) Luo</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/LearnerLj"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://www.linkedin.com/in/jiahao-michael-luo-8ba5942a3" rel="external nofollow noreferrer" target="_blank" title="Linkedin"><i class="fa-brands fa-linkedin"></i></a><a class="social-icon" href="https://x.com/jiahao_luo9" rel="external nofollow noreferrer" target="_blank" title="Twitter"><i class="fa-brands fa-twitter"></i></a><a class="social-icon" href="https://github.com/learnerLj" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:luoshitou9@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">从技术到商业，从产品到设计，从生活到未来，我会在这里分享我的所思所想，欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">同步模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E4%B8%8B%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">区块下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8B%E8%BD%BD"><span class="toc-number">4.3.</span> <span class="toc-text">同步下载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-State"><span class="toc-number">4.4.</span> <span class="toc-text">同步 State</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-Head"><span class="toc-number">4.5.</span> <span class="toc-text">同步 Head</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86-Head"><span class="toc-number">4.6.</span> <span class="toc-text">处理 Head</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-Body"><span class="toc-number">4.7.</span> <span class="toc-text">同步 Body</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%94%B6%E6%8D%AE"><span class="toc-number">4.8.</span> <span class="toc-text">同步收据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number"></span> <span class="toc-text">参考链接</span></a></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>Post Series</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/geth/tx-signature/" title="交易的签名"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="交易的签名"></a><div class="content"><a class="title" href="/geth/tx-signature/" title="交易的签名">交易的签名</a><time datetime="2022-08-24T17:30:33.000Z" title="Created 2022-08-25 01:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/understand-receipt/" title="理解收据receipt"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="理解收据receipt"></a><div class="content"><a class="title" href="/geth/understand-receipt/" title="理解收据receipt">理解收据receipt</a><time datetime="2022-08-24T21:30:33.000Z" title="Created 2022-08-25 05:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/blocks/" title="理解区块"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="理解区块"></a><div class="content"><a class="title" href="/geth/blocks/" title="理解区块">理解区块</a><time datetime="2022-08-25T00:30:33.000Z" title="Created 2022-08-25 08:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/understand-tx/" title="理解交易"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="理解交易"></a><div class="content"><a class="title" href="/geth/understand-tx/" title="理解交易">理解交易</a><time datetime="2022-08-25T01:30:33.000Z" title="Created 2022-08-25 09:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/blockchain-core/" title="blockchain核心"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="blockchain核心"></a><div class="content"><a class="title" href="/geth/blockchain-core/" title="blockchain核心">blockchain核心</a><time datetime="2022-08-25T02:30:33.000Z" title="Created 2022-08-25 10:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/bloom-filter/" title="布隆过滤器原理"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="布隆过滤器原理"></a><div class="content"><a class="title" href="/geth/bloom-filter/" title="布隆过滤器原理">布隆过滤器原理</a><time datetime="2022-08-25T03:30:33.000Z" title="Created 2022-08-25 11:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/forkId/" title="forkId 解读"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="forkId 解读"></a><div class="content"><a class="title" href="/geth/forkId/" title="forkId 解读">forkId 解读</a><time datetime="2022-08-25T03:30:33.000Z" title="Created 2022-08-25 11:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/oracle-introduction/" title="oracle 原理和实现"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="oracle 原理和实现"></a><div class="content"><a class="title" href="/geth/oracle-introduction/" title="oracle 原理和实现">oracle 原理和实现</a><time datetime="2022-08-25T03:30:33.000Z" title="Created 2022-08-25 11:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/tx-pool/" title="交易池分析"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="交易池分析"></a><div class="content"><a class="title" href="/geth/tx-pool/" title="交易池分析">交易池分析</a><time datetime="2022-08-25T03:30:33.000Z" title="Created 2022-08-25 11:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/txlist/" title="TxList 解读"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TxList 解读"></a><div class="content"><a class="title" href="/geth/txlist/" title="TxList 解读">TxList 解读</a><time datetime="2022-08-25T03:30:33.000Z" title="Created 2022-08-25 11:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/MPT-Tree/" title="MPT树"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MPT树"></a><div class="content"><a class="title" href="/geth/MPT-Tree/" title="MPT树">MPT树</a><time datetime="2022-08-25T04:30:33.000Z" title="Created 2022-08-25 12:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/block-sync/" title="区块同步"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="区块同步"></a><div class="content"><a class="title" href="/geth/block-sync/" title="区块同步">区块同步</a><time datetime="2022-08-25T08:30:33.000Z" title="Created 2022-08-25 16:30:33">2022-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/introduction/" title="geth源码学习——介绍"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="geth源码学习——介绍"></a><div class="content"><a class="title" href="/geth/introduction/" title="geth源码学习——介绍">geth源码学习——介绍</a><time datetime="2022-09-28T08:30:33.000Z" title="Created 2022-09-28 16:30:33">2022-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/geth/Geth-Unveiled-Ethereum-Startup/" title="How Geth starts its server"><img src="/images/geth.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="How Geth starts its server"></a><div class="content"><a class="title" href="/geth/Geth-Unveiled-Ethereum-Startup/" title="How Geth starts its server">How Geth starts its server</a><time datetime="2023-09-13T15:02:10.000Z" title="Created 2023-09-13 23:02:10">2023-09-13</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/dev/study-mini-redis/" title="深入学习Rust异步编程：mini-redis项目解析"><img src="https://cdn.blog-blockchain.xyz/2025/03/7a1eb877711a4e78b90307ccefde92f4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入学习Rust异步编程：mini-redis项目解析"/></a><div class="content"><a class="title" href="/dev/study-mini-redis/" title="深入学习Rust异步编程：mini-redis项目解析">深入学习Rust异步编程：mini-redis项目解析</a><time datetime="2025-03-22T20:33:20.000Z" title="Created 2025-03-23 04:33:20">2025-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/value-of-software-engineering/" title="程序员的价值在哪里"><img src="https://cdn.blog-blockchain.xyz/2025/03/743b33dee5c8b2089f9483cdf2067b25.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序员的价值在哪里"/></a><div class="content"><a class="title" href="/dev/value-of-software-engineering/" title="程序员的价值在哪里">程序员的价值在哪里</a><time datetime="2025-03-09T18:01:20.000Z" title="Created 2025-03-10 02:01:20">2025-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/career/crypto-beyond-alpha-and-manipulation/" title="从 Alpha 到坐庄：不充分市场中的暴富"><img src="https://cdn.blog-blockchain.xyz/2025/02/7c227b9f1d763dfd7bb44bc6f10b35b6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从 Alpha 到坐庄：不充分市场中的暴富"/></a><div class="content"><a class="title" href="/career/crypto-beyond-alpha-and-manipulation/" title="从 Alpha 到坐庄：不充分市场中的暴富">从 Alpha 到坐庄：不充分市场中的暴富</a><time datetime="2025-02-26T03:11:20.000Z" title="Created 2025-02-26 11:11:20">2025-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/audit/blockchain-client-security/" title="公链安全开发指南和审计checklist"><img src="https://cdn.blog-blockchain.xyz/2025/01/c037c1551777613437e750a0fdd9489c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="公链安全开发指南和审计checklist"/></a><div class="content"><a class="title" href="/audit/blockchain-client-security/" title="公链安全开发指南和审计checklist">公链安全开发指南和审计checklist</a><time datetime="2025-01-21T09:03:53.000Z" title="Created 2025-01-21 17:03:53">2025-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/fast-draw/" title="Mermaid 快速绘制流程图"><img src="https://cdn.blog-blockchain.xyz/2025/01/2eff9a38e755999f214c5a96c036591d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mermaid 快速绘制流程图"/></a><div class="content"><a class="title" href="/dev/fast-draw/" title="Mermaid 快速绘制流程图">Mermaid 快速绘制流程图</a><time datetime="2025-01-11T15:19:20.000Z" title="Created 2025-01-11 23:19:20">2025-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Michael(Jiahao) Luo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.3.5"></script><script src="/js/main.js?v=5.3.5"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '467d9506710fff22dc33',
      clientSecret: '2a3e530b895af9c94d4bbe95fe78c69317f4d76e',
      repo: 'blog-gitalk',
      owner: 'learnerLj',
      admin: ['learnerLj'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '8126ce05b38008a7c3f3fb91438d576a'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.3.5"></script></div></div></body></html>