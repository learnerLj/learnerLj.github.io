<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>（二）状态变量的赋值 | Jiahao Luo</title><meta name="author" content="Michael(Jiahao) Luo"><meta name="copyright" content="Michael(Jiahao) Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="（一）初步认识EVM字节码（二）状态变量的赋值（三）函数调用  状态变量的字节码 对于最简单的情况，我们观察它部署时的情况 123456&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0pragma solidity &gt;&#x3D;0.7.0 &lt;0.9.0;contract Empty&#123;    uint a;&#125; EVM 汇编如下 123456789101">
<meta property="og:type" content="article">
<meta property="og:title" content="（二）状态变量的赋值">
<meta property="og:url" content="https://www.blog-blockchain.xyz/evm/state-variable/index.html">
<meta property="og:site_name" content="Jiahao Luo">
<meta property="og:description" content="（一）初步认识EVM字节码（二）状态变量的赋值（三）函数调用  状态变量的字节码 对于最简单的情况，我们观察它部署时的情况 123456&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0pragma solidity &gt;&#x3D;0.7.0 &lt;0.9.0;contract Empty&#123;    uint a;&#125; EVM 汇编如下 123456789101">
<meta property="og:locale">
<meta property="og:image" content="https://www.blog-blockchain.xyz/images/evm-bytecode.png">
<meta property="article:published_time" content="2022-08-24T11:29:33.000Z">
<meta property="article:modified_time" content="2024-11-18T09:49:18.042Z">
<meta property="article:author" content="Michael(Jiahao) Luo">
<meta property="article:tag" content="evm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.blog-blockchain.xyz/images/evm-bytecode.png"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://www.blog-blockchain.xyz/evm/state-variable/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=5.2.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?372b8854d18acf62880149b1e08e1901";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=QXcJQjXxTMeUwnWykFW2xw"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'QXcJQjXxTMeUwnWykFW2xw')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'QXcJQjXxTMeUwnWykFW2xw', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '（二）状态变量的赋值',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Jiahao Luo" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/site-avator.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jiahao Luo</span></a><a class="nav-page-title" href="/"><span class="site-name">（二）状态变量的赋值</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">（二）状态变量的赋值</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-08-24T11:29:33.000Z" title="Created 2022-08-24 19:29:33">2022-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-18T09:49:18.042Z" title="Updated 2024-11-18 17:49:18">2024-11-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/evm/">evm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>39mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><blockquote>
<ol class="series-items"><li><a href="/evm/evm-basic-bytecode/" title="（一）初步认识EVM字节码">（一）初步认识EVM字节码</a></li><li><a href="/evm/state-variable/" title="（二）状态变量的赋值">（二）状态变量的赋值</a></li><li><a href="/evm/function-call/" title="（三）函数调用">（三）函数调用</a></li></ol>
</blockquote>
<h1>状态变量的字节码</h1>
<p>对于最简单的情况，我们观察它部署时的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line">contract Empty&#123;</span><br><span class="line">    uint a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EVM 汇编如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">======= Empty.sol:Empty =======</span><br><span class="line">EVM assembly:</span><br><span class="line">    /* &quot;Empty.sol&quot;:69:95  contract Empty&#123;... */</span><br><span class="line">  mstore(0x40, 0x80)</span><br><span class="line">  callvalue</span><br><span class="line">  dup1</span><br><span class="line">  iszero</span><br><span class="line">  tag_1</span><br><span class="line">  jumpi</span><br><span class="line">  0x00</span><br><span class="line">  dup1</span><br><span class="line">  revert</span><br><span class="line">tag_1:</span><br><span class="line">  pop</span><br><span class="line">  dataSize(sub_0)</span><br><span class="line">  dup1</span><br><span class="line">  dataOffset(sub_0)</span><br><span class="line">  0x00</span><br><span class="line">  codecopy</span><br><span class="line">  0x00</span><br><span class="line">  return</span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">sub_0: assembly &#123;</span><br><span class="line">        /* &quot;Empty.sol&quot;:69:95  contract Empty&#123;... */</span><br><span class="line">      mstore(0x40, 0x80)</span><br><span class="line">      0x00</span><br><span class="line">      dup1</span><br><span class="line">      revert</span><br><span class="line"></span><br><span class="line">    auxdata: 0xa2646970667358221220d1d81e685eb83003c8d41cb6d5eccdc8b72a166840e80f7c1683a982795b1dec64736f6c634300080a0033</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储布局如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;storage&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;astId&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;contract&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Empty.sol:Empty&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;slot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t_uint256&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;t_uint256&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;inplace&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uint256&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;numberOfBytes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>对比前面无状态变量的情况，我们发现指令几乎一致，只有辅助数据 <code>auxdata</code> 有差别。这就引出了一个重要的观点：<strong>EVM 只担任执行指令并更改状态的角色，如何操作 (指令) 都是由 solc 决定。对于 EVM 来讲，每个合约账户的 storage 是初始全为 0 的 2^256 个 32 字节的 slot。这并不像内存是按需分配，需要内存扩展。</strong></p>
<h2 id="静态类型">静态类型</h2>
<p>静态类型可以简单的理解为 <code>int</code> <code>uint</code> 之类的常规变量。</p>
<h3 id="普通变量">普通变量</h3>
<p>看简单的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract StaticVariable &#123;</span><br><span class="line">    uint a;//256位</span><br><span class="line">    uint128 b;//占128位</span><br><span class="line">    bytes8 c;//占64位</span><br><span class="line">    int64 d;//占64位</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        a=2314;</span><br><span class="line">        b= 7;</span><br><span class="line">        c=&quot;1011&quot;;</span><br><span class="line">        d= 15;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">======= staticVariable.sol:StaticVariable =======</span><br><span class="line">EVM assembly:</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:70:270  contract StaticVariable &#123;... */</span><br><span class="line">  mstore(0x40, 0x80)</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:185:268  constructor()&#123;... */</span><br><span class="line">  callvalue</span><br><span class="line">  dup1</span><br><span class="line">  iszero</span><br><span class="line">  tag_1</span><br><span class="line">  jumpi</span><br><span class="line">  0x00</span><br><span class="line">  dup1</span><br><span class="line">  revert</span><br><span class="line">tag_1:</span><br><span class="line">  pop</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:210:214  2314 */</span><br><span class="line">  0x090a</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:208:209  a */</span><br><span class="line">  0x00</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:208:214  a=2314 */</span><br><span class="line">  dup2</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  pop</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:227:228  7 */</span><br><span class="line">  0x07</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:224:225  b */</span><br><span class="line">  0x01</span><br><span class="line">  0x00</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:224:228  b= 7 */</span><br><span class="line">  0x0100</span><br><span class="line">  exp</span><br><span class="line">  dup2</span><br><span class="line">  sload</span><br><span class="line">  dup2</span><br><span class="line">  0xffffffffffffffffffffffffffffffff</span><br><span class="line">  mul</span><br><span class="line">  not</span><br><span class="line">  and</span><br><span class="line">  swap1</span><br><span class="line">  dup4</span><br><span class="line">  0xffffffffffffffffffffffffffffffff</span><br><span class="line">  and</span><br><span class="line">  mul</span><br><span class="line">  or</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  pop</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:238:246  c=&quot;1011&quot; */</span><br><span class="line">  0x3130313100000000000000000000000000000000000000000000000000000000</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:238:239  c */</span><br><span class="line">  0x01</span><br><span class="line">  0x10</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:238:246  c=&quot;1011&quot; */</span><br><span class="line">  0x0100</span><br><span class="line">  exp</span><br><span class="line">  dup2</span><br><span class="line">  sload</span><br><span class="line">  dup2</span><br><span class="line">  0xffffffffffffffff</span><br><span class="line">  mul</span><br><span class="line">  not</span><br><span class="line">  and</span><br><span class="line">  swap1</span><br><span class="line">  dup4</span><br><span class="line">  0xc0</span><br><span class="line">  shr</span><br><span class="line">  mul</span><br><span class="line">  or</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  pop</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:259:261  15 */</span><br><span class="line">  0x0f</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:256:257  d */</span><br><span class="line">  0x01</span><br><span class="line">  0x18</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:256:261  d= 15 */</span><br><span class="line">  0x0100</span><br><span class="line">  exp</span><br><span class="line">  dup2</span><br><span class="line">  sload</span><br><span class="line">  dup2</span><br><span class="line">  0xffffffffffffffff</span><br><span class="line">  mul</span><br><span class="line">  not</span><br><span class="line">  and</span><br><span class="line">  swap1</span><br><span class="line">  dup4</span><br><span class="line">  0x07</span><br><span class="line">  signextend</span><br><span class="line">  0xffffffffffffffff</span><br><span class="line">  and</span><br><span class="line">  mul</span><br><span class="line">  or</span><br><span class="line">  swap1</span><br><span class="line">  sstore</span><br><span class="line">  pop</span><br><span class="line">    /* &quot;staticVariable.sol&quot;:70:270  contract StaticVariable &#123;... */</span><br><span class="line">  dataSize(sub_0)</span><br><span class="line">  dup1</span><br><span class="line">  dataOffset(sub_0)</span><br><span class="line">  0x00</span><br><span class="line">  codecopy</span><br><span class="line">  0x00</span><br><span class="line">  return</span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">sub_0: assembly &#123;</span><br><span class="line">        /* &quot;staticVariable.sol&quot;:70:270  contract StaticVariable &#123;... */</span><br><span class="line">      mstore(0x40, 0x80)</span><br><span class="line">      0x00</span><br><span class="line">      dup1</span><br><span class="line">      revert</span><br><span class="line"></span><br><span class="line">    auxdata: 0xa26469706673582212207eb20293ec4fc5cc1b2fe0cc5fc4691d8c1b048202104c5ca6afa58f9012116f64736f6c634300080a0033</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键看 <code>tag1</code> 中初始化的过程。<code>sstore</code> 的时候栈如下</p>
<p>[ “0x0000000000000000000000000000000000000000000000000000000000000000”, “0x000000000000000000000000000000000000000000000000000000000000090a”, “0x000000000000000000000000000000000000000000000000000000000000090a” ]</p>
<p>发现将在 00 的位置给 <code>a</code> 赋值 <code>0x90a</code>，这是非常直接的操作，建议读者单步调试观察。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 数值压栈</span><br><span class="line">2. 存储位置压栈</span><br><span class="line">3. 复制数值到栈顶</span><br><span class="line">4. 将栈顶数值与存储位置互换</span><br><span class="line">5. sstore</span><br></pre></td></tr></table></figure>
<p>但是由于 <code>b</code> 不够 256 位，不能占满一个 slot，因此就需要进行相对复杂的位操作。</p>
<ol>
<li>
<p>PUSH1 07，数值压栈。</p>
</li>
<li>
<p><code>PUSH1 01, PUSH1 00, PUSH2 0100, EXP</code>，01 是 slot 的序号，0 表示移位几个字节，因为这是 slot 1 的第一个变量，所以为 0。<code>0x0100</code> 表示一个字节，与随后的操作码 <code>EXP</code>，计算指数，得到最终的偏移量。</p>
</li>
<li>
<p>DUP2, SLOAD 复制 slot 的序号，取出里面的内容。</p>
</li>
<li>
<p><code>DUP2, PUSH16 ffffffffffffffffffffffffffffffff, MUL, NOT</code> 复制偏移量，然后与掩码相乘，然后取反得到最终的掩码。</p>
</li>
<li>
<p><code>AND</code> slot 1 的序列和掩码取与，得到左半部分 128 位的内容。</p>
</li>
<li>
<p><code>SWAP1, DUP4, PUSH16 ffffffffffffffffffffffffffffffff, AND, MUL</code> 将偏移量置于栈顶，然后将赋值的数据复制到栈顶，接着和掩码按位取与，最后乘上偏移量，实现了右边 128 位的赋值。</p>
</li>
<li>
<p><code>OR</code> 与左边 128 位按位取或，实现了对 slot 1 的处理。</p>
</li>
<li>
<p><code>SWAP1, SSTORE</code> 将 slot 序号交换到栈顶，写入 slot 1.</p>
<p>具体过程请见<strong>附录 II a</strong> .</p>
</li>
</ol>
<p>对于变量 <code>c</code>，注意到它是在 <code>slot1</code>，偏移 16 个字节。参考 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.soliditylang.org/en/latest/types.html#string-literals-and-types">solidity doc</a> 可以知道 bytes 默认是使用 ASCII 编码存储的，<code>0</code> 表示为 <code>0x30</code>, <code>1</code> 表示为 <code>0x31</code> 因此 <code>1011</code> 在存储中表示为 <code>0x3130313100000000</code>.</p>
<ol>
<li><code>PUSH 3130313100000000000000000000000000000000000000000000000000000000</code>，说明对于 <code>bytes1</code> 到 <code>bytes32</code> 都是直接先从高位开始传入字符。</li>
<li><code>PUSH1 01 PUSH1 10 PUSH2 0100 EXP</code>，<code>01</code> 用于后续加载 <code>slot1</code> 的内容。然后偏移量为 <code>0x10</code> 字节。</li>
<li>后面和上一个变量类似，掩码操作，取出对应位置的 8 个字节。</li>
<li>将 <code>3130313100000000000000000000000000000000000000000000000000000000</code> 右移 <code>oxc0</code> 位，也就是 24 个字节，这样就恰好是我们需要的 8 个字节。</li>
<li>将我们需要的 8 个字节按照它存储的布局，依靠第 2 步确定的偏移量，偏移 <code>0x10</code> 字节。</li>
<li><code>OR</code> 之后 <code>SSTORE</code> 存储。</li>
</ol>
<p>变量 <code>d</code> 的操作很类似，值得一提的是 <code>SIGNEXTEND</code> 这个操作码。符号扩展有两个参数，第一个参数是数值的字节数减一，第二个参数是栈内数值。这样说可能有些模糊，读者可以阅读它的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.evm.codes/#0b">操作码说明</a>。</p>
<p>最后的存储布局如下,故意加空格是为了突出不同的变量。可以看到变量的存储是从左边开始的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">key:</span><br><span class="line">0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">value:</span><br><span class="line">0x000000000000000000000000000000000000000000000000000000000000090a</span><br><span class="line"></span><br><span class="line">key:</span><br><span class="line">0x0000000000000000000000000000000000000000000000000000000000000001</span><br><span class="line">value:</span><br><span class="line">0x000000000000000f  3130313100000000  00000000000000000000000000000007</span><br></pre></td></tr></table></figure>
<p>最后，观察逆向后的伪代码会更加清晰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line">        storage[0x00] = 0x090a;</span><br><span class="line">        storage[0x01] = (storage[0x01] &amp; ~0xffffffffffffffffffffffffffffffff) | (0xffffffffffffffffffffffffffffffff &amp; 0x07);</span><br><span class="line">        storage[0x01] = (storage[0x01] &amp; ~(0xffffffffffffffff * 0x0100 ** 0x10)) | (0x3130313100000000000000000000000000000000000000000000000000000000 &gt;&gt; 0xc0) * 0x0100 ** 0x10;</span><br><span class="line">        storage[0x01] = (storage[0x01] &amp; ~(0xffffffffffffffff * 0x0100 ** 0x18)) | (0xffffffffffffffff &amp; signextend(0x07, 0x0f)) * 0x0100 ** 0x18;</span><br><span class="line">        memory[0x00:0x3f] = code[0xd0:0x010f];</span><br><span class="line">        return memory[0x00:0x3f];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体">结构体</h3>
<p>结构体在汇编的视角，只是语法糖，相当于里面的变量「拆开」排布，区别在于结构体开始存储的 slot 和最后结束存储的 slot 都不能和其他变量共享。</p>
<p>可以观察下面的这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.10;</span><br><span class="line"></span><br><span class="line">contract StructTest1 &#123;</span><br><span class="line">    struct Member &#123;</span><br><span class="line">        address userAddr;//20字节</span><br><span class="line">        uint balance;//32字节</span><br><span class="line">        bool vip;//1字节</span><br><span class="line">    &#125;</span><br><span class="line">    Member customer;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        customer.userAddr=msg.sender;</span><br><span class="line">        customer.balance = 100;</span><br><span class="line">        customer.vip=false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从下面的逆向代码，也可以看出来上面提到的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line"></span><br><span class="line">        storage[0x00] = msg.sender | (storage[0x00] &amp; ~0xffffffffffffffffffffffffffffffffffffffff);</span><br><span class="line">        storage[0x01] = 0x64;</span><br><span class="line">        storage[0x02] = (storage[0x02] &amp; ~0xff) | 0x00;</span><br><span class="line">        memory[0x00:0x3f] = code[0x88:0xc7];</span><br><span class="line">        return memory[0x00:0x3f];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组">数组</h3>
<h4 id="元素赋值">元素赋值</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Array &#123;</span><br><span class="line">    uint[9] a;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        a[0]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是最简单的例子，下面是逆向后的伪代码。<code>var0</code> 保存需要赋予的值，然后 <code>var1</code> 是数组开始的 slot 的位置，<code>var2</code> 是数组的索引，<code>0x09</code> 是数组长度。然后由于 <code>uint</code> 类型刚好占满 256 位，所以寻址比较简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line"></span><br><span class="line">        var0 = 0x01;</span><br><span class="line">        var var1 = 0x00;</span><br><span class="line">        var var2 = var1;</span><br><span class="line"></span><br><span class="line">        if (var2 &lt; 0x09) &#123;</span><br><span class="line">            storage[var2 + var1] = var0;</span><br><span class="line">            memory[0x00:0x3f] = code[0x68:0xa7];</span><br><span class="line">            return memory[0x00:0x3f];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var var3 = 0x22;</span><br><span class="line">            memory[0x00:0x20] = 0x4e487b7100000000000000000000000000000000000000000000000000000000;</span><br><span class="line">            memory[0x04:0x24] = 0x32;</span><br><span class="line">            revert(memory[0x00:0x24]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看复杂一点儿的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Array &#123;</span><br><span class="line">    uint[9] a;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        a[0]=1;</span><br><span class="line">        a[1]=2;</span><br><span class="line">        a[6]=1234;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆向伪代码如下，我直接在下面用注释解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line"></span><br><span class="line">        var0 = 0x01;//将赋值1</span><br><span class="line">        var var1 = 0x00;//数组从slot0开始</span><br><span class="line">        var var2 = var1;//数组的索引</span><br><span class="line"></span><br><span class="line">        if (var2 &lt; 0x09) &#123;//一般都会符合这个，因为编译器会检查</span><br><span class="line">            storage[var2 + var1] = var0;//赋值a[0]=1</span><br><span class="line">            var0 = 0x02;//以下内容完全类似</span><br><span class="line">            var1 = 0x00;</span><br><span class="line">            var2 = 0x01;</span><br><span class="line"></span><br><span class="line">            if (var2 &lt; 0x09) &#123;</span><br><span class="line">                storage[var2 + var1] = var0;</span><br><span class="line">                var0 = 0x04d2;</span><br><span class="line">                var1 = 0x00;</span><br><span class="line">                var2 = 0x06;//注意数组索引变成6</span><br><span class="line"></span><br><span class="line">                if (var2 &lt; 0x09) &#123;</span><br><span class="line">                    storage[var2 + var1] = var0;</span><br><span class="line">                    memory[0x00:0x3f] = code[0x9b:0xda];</span><br><span class="line">                    return memory[0x00:0x3f];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    var var3 = 0x55;</span><br><span class="line"></span><br><span class="line">                label_005F:</span><br><span class="line">                    memory[0x00:0x20] = 0x4e487b7100000000000000000000000000000000000000000000000000000000;</span><br><span class="line">                    memory[0x04:0x24] = 0x32;</span><br><span class="line">                    revert(memory[0x00:0x24]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                var3 = 0x3b;</span><br><span class="line">                goto label_005F;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var3 = 0x22;</span><br><span class="line">            goto label_005F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字面量赋值">字面量赋值</h4>
<p>我们继续观察字面量的赋值特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract Array &#123;</span><br><span class="line">    uint[9] a;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        a=[1,2,3,4,5];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字面量的处理实际上较为复杂，我们慢慢分析，依然主要看注释。下面先补充一些分析：</p>
<ul>
<li>字面量所需的空间在编译时是不确定的，因此赋值时必然需要内存辅助，则会涉及到内存指针（分配的内存大小）、内存拓展。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line"></span><br><span class="line">        var temp0 = memory[0x40:0x60];</span><br><span class="line">        memory[0x40:0x60] = temp0 + 0xa0;//内存拓展 0xa0 字节</span><br><span class="line">        memory[temp0:temp0 + 0x20] = 0xff &amp; 0x01;//0x20字节连续存放数组的字面量，通过掩码取值。虽然这里掩码看上去是多余的，但是对于复杂情况则很有用。</span><br><span class="line">        var temp1 = temp0 + 0x20;</span><br><span class="line">        memory[temp1:temp1 + 0x20] = 0xff &amp; 0x02;</span><br><span class="line">        var temp2 = temp1 + 0x20;</span><br><span class="line">        memory[temp2:temp2 + 0x20] = 0xff &amp; 0x03;</span><br><span class="line">        var temp3 = temp2 + 0x20;</span><br><span class="line">        memory[temp3:temp3 + 0x20] = 0xff &amp; 0x04;</span><br><span class="line">        memory[temp3 + 0x20:temp3 + 0x20 + 0x20] = 0xff &amp; 0x05;</span><br><span class="line">        var0 = 0x59;</span><br><span class="line">        var var1 = 0x00;//数组开始的slot位置</span><br><span class="line">        var var2 = temp0;//内存中开始写入数据的位置</span><br><span class="line">        var var3 = 0x05;//字面量的元素个数</span><br><span class="line">        var0 = func_005E(var1, var2, var3);//（数组开始slot位置,内存开始位置,元素个数）开始把内存中的值写入存储</span><br><span class="line">        memory[0x00:0x3f] = code[0xc7:0x0106];</span><br><span class="line">        return memory[0x00:0x3f];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_005E(var arg0, var arg1, var arg2) returns (var r0) &#123;</span><br><span class="line">        var var0 = arg0;//0x00</span><br><span class="line">        var temp0 = arg1;//0x80</span><br><span class="line">        arg1 = var0 + 0x09;//数组结束slot位置</span><br><span class="line">        var var1 = temp0;//0x80</span><br><span class="line"></span><br><span class="line">        if (!arg2) &#123;//需要写入的元素个数为0，即字面量为空，我们不讨论异常情况</span><br><span class="line">        label_008F://这是结束的语句块，</span><br><span class="line">            var temp1 = arg1;</span><br><span class="line">            arg1 = 0x9a;</span><br><span class="line">            var0 = var0;//数组开始的slot位置</span><br><span class="line">            arg2 = temp1;//数组结束的slot位置</span><br><span class="line">            arg1 = func_009E(arg2, var0);</span><br><span class="line">            return arg0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var temp2 = arg2;//元素个数</span><br><span class="line">            var temp3 = var1;//0x80内存开始位置</span><br><span class="line">            arg2 = temp3;//内存开始位置</span><br><span class="line">            var1 = arg2 + temp2 * 0x20;//计算内存结束位置</span><br><span class="line"></span><br><span class="line">            if (var1 &lt;= arg2) &#123;//这是为了防止溢出，编译器的异常处理</span><br><span class="line">            label_008E:</span><br><span class="line">                goto label_008F;</span><br><span class="line">            &#125; else &#123;//下面是正常情况</span><br><span class="line">            label_0078:</span><br><span class="line">                var temp4 = arg2;//内存开始位置</span><br><span class="line">                var temp5 = var0;//数据存储起始位置</span><br><span class="line">                storage[temp5] = memory[temp4:temp4 + 0x20] &amp; 0xff;</span><br><span class="line">                arg2 = temp4 + 0x20;//内存开始位置向后32字节</span><br><span class="line">                var0 = temp5 + 0x01;//存储中的数组索引+1</span><br><span class="line">                var1 = var1;</span><br><span class="line"></span><br><span class="line">                if (var1 &lt;= arg2) &#123; goto label_008E; &#125;//内存读取位置到达结束位置，跳转到结束的语句块</span><br><span class="line">                else &#123; goto label_0078; &#125;//重复执行，直到所有的值都写入了</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_009E(var arg0, var arg1) returns (var r0) &#123;//（结束的存储位置，开始存储位置）</span><br><span class="line">        if (arg0 &lt;= arg1) &#123;//通过递增，开始位置已经到达结束位置，可以结束</span><br><span class="line">        label_00B5:</span><br><span class="line">            return arg0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        label_00A7:</span><br><span class="line">            var temp0 = arg1;</span><br><span class="line">            storage[temp0] = 0x00;//这里可能是为了回滚，需要把数据置为默认值</span><br><span class="line">            arg1 = temp0 + 0x01;</span><br><span class="line"></span><br><span class="line">            if (arg0 &lt;= arg1) &#123; goto label_00B5; &#125;//结束</span><br><span class="line">            else &#123; goto label_00A7; &#125;//如果还没结束就自增</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="变量需要-compact-的情况">变量需要 compact 的情况</h4>
<p>关于 compact 是什么，请见 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#layout-of-state-variables-in-storage">Layout of State Variables in Storage</a>，这里不赘述，而且本文默认读者已经有这些基础。</p>
<p>首先，我们可以猜想，它和上面恰好占满 slot 的情况的差别在于，它需要使用掩码取数，而且 <code>int24</code> 类型的赋值需要符号扩展。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.10;</span><br><span class="line"></span><br><span class="line">contract Array &#123;</span><br><span class="line">    int24[9] a;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        a[3]=11;</span><br><span class="line">        a=[int24(1),2,3,4,5];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们仍然观察逆向后的伪代码，它比字节码多了一层抽象，适合初学者分析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;//初始内存数据开始位置</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line"></span><br><span class="line">        var0 = 0x0b;//赋值的数11</span><br><span class="line">        var var1 = 0x00;//数组开始的slot</span><br><span class="line">        var var2 = 0x03;//索引为3</span><br><span class="line"></span><br><span class="line">        if (var2 &lt; 0x09) &#123;</span><br><span class="line">            var temp0 = var2;//复制索引</span><br><span class="line">            var temp1 = temp0 / 0x0a + var1;//计算 slot 位置，一个 slot 最多容纳 0x0a 个元素</span><br><span class="line">            var temp2 = 0x0100 ** (temp0 % 0x0a * 0x03);//temp0 % 0x0a表示这个slot容纳的元素个数，0x03表示一个元素的字节数，这样计算出了偏移量</span><br><span class="line">            storage[temp1] = (signextend(0x02, var0) &amp; 0xffffff) * temp2 | (~(temp2 * 0xffffff) &amp; storage[temp1]);//对赋值的数 2 进行符号扩展，然后通过掩码取数，再根据temp2移位，接着异或，保存slot原来的内容。具体来说，原来slot会通过移位后的掩码，将需要更新的部分置为0。</span><br><span class="line">            var temp3 = memory[0x40:0x60];//获取分配的内存大小</span><br><span class="line">            memory[0x40:0x60] = temp3 + 0xa0;//内存拓展0xa0字节</span><br><span class="line">            //下面可以发现，memory 是不会进行 compact 的，虽然每个元素占用3个字节，但是实际上内存中分配是32字节</span><br><span class="line">            memory[temp3:temp3 + 0x20] = signextend(0x02, signextend(0x02, 0x01));//这里符号扩展两次，实际上是因为源码中为了确定数组字面量的类型，进行了强制类型转化，需要符号扩展，然后赋值之前也自动符号扩展。</span><br><span class="line">            var temp4 = temp3 + 0x20;</span><br><span class="line">            memory[temp4:temp4 + 0x20] = signextend(0x02, 0x02);</span><br><span class="line">            var temp5 = temp4 + 0x20;</span><br><span class="line">            memory[temp5:temp5 + 0x20] = signextend(0x02, 0x03);</span><br><span class="line">            var temp6 = temp5 + 0x20;</span><br><span class="line">            memory[temp6:temp6 + 0x20] = signextend(0x02, 0x04);</span><br><span class="line">            memory[temp6 + 0x20:temp6 + 0x20 + 0x20] = signextend(0x02, 0x05);</span><br><span class="line">            //现在准备将内存中的数据写入存储</span><br><span class="line">            var0 = 0x009f;//这个辅助的数据没有用到，可能是默认值。</span><br><span class="line">            var1 = 0x00;</span><br><span class="line">            var var3 = 0x05;</span><br><span class="line">            var2 = temp3;</span><br><span class="line">            var0 = func_00A5(var1, var2, var3);//（初始slot位置，数组内存开始位置，需要赋值的元素个数）</span><br><span class="line">            memory[0x00:0x3f] = code[0x01a1:0x01e0];</span><br><span class="line">            return memory[0x00:0x3f];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var3 = 0x0027;</span><br><span class="line">            memory[0x00:0x20] = 0x4e487b7100000000000000000000000000000000000000000000000000000000;</span><br><span class="line">            memory[0x04:0x24] = 0x32;</span><br><span class="line">            revert(memory[0x00:0x24]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_00A5(var arg0, var arg1, var arg2) returns (var r0) &#123;</span><br><span class="line">        //和之前的类似，计算写入位置</span><br><span class="line">        var var0 = arg0;//数组开始slot位置</span><br><span class="line">        var temp0 = arg1;</span><br><span class="line">        arg1 = var0 + (0x09 + 0x09) / 0x0a;//一个slot最多0xa个int24变量。1</span><br><span class="line">        var var1 = temp0;</span><br><span class="line"></span><br><span class="line">        if (!arg2) &#123;//需要赋值的元素个数为0，这是异常情况</span><br><span class="line">        label_0136:</span><br><span class="line">            var temp1 = arg1;//1</span><br><span class="line">            arg1 = 0x0143;</span><br><span class="line">            var0 = var0;//0</span><br><span class="line">            arg2 = temp1;//1</span><br><span class="line">            arg1 = func_0147(arg2, var0);</span><br><span class="line">            return arg0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var temp2 = arg2;//5</span><br><span class="line">            var temp3 = var1;//内存开始位置</span><br><span class="line">            arg2 = temp3;</span><br><span class="line">            var1 = arg2 + temp2 * 0x20;//计算内存结束位置</span><br><span class="line">            var var2 = 0x00;//slot内的偏移字节数</span><br><span class="line"></span><br><span class="line">            if (var1 &lt;= arg2) &#123;//内存结束位置小于内存开始位置，异常处理，可能与回滚有关，笔者暂时不熟悉</span><br><span class="line">            label_0105:</span><br><span class="line"></span><br><span class="line">                if (!var2) &#123; goto label_0136; &#125;//赋值结束时执行</span><br><span class="line"></span><br><span class="line">                var temp4 = var0;//数组存储开始位置</span><br><span class="line">                var temp5 = var2;//偏移量</span><br><span class="line">                storage[temp4] = ~(0x0100 ** temp5 * 0xffffff) &amp; storage[temp4];//取出第一个元素</span><br><span class="line">                var temp6 = temp5 + 0x03;//偏移量增加 3 字节</span><br><span class="line">                var temp7 = (temp6 + 0x02) / 0x20;//判断slot位置增量。因为int24之多占满30个字节，slot里有两个字节是闲置且无法使用的。</span><br><span class="line">                var0 = temp7 + temp4;//重新计算数组下一次赋值的slot的位置</span><br><span class="line">                var2 = 0x01 - temp7 * temp6;//注意，slot的位置必然小于1，因为1是我们传入的数组结束的位置。</span><br><span class="line">                goto label_0105;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            label_00C9:</span><br><span class="line">                var temp8 = arg2;//内存开始位置</span><br><span class="line">                var temp9 = var0;//数组开始的slot位置</span><br><span class="line">                var temp10 = var2;//slot内的偏移字节数</span><br><span class="line">                var temp11 = 0x0100 ** temp10;//偏移量</span><br><span class="line">                storage[temp9] = (signextend(0x02, memory[temp8:temp8 + 0x20]) &amp; 0xffffff) * temp11 | (~(temp11 * 0xffffff) &amp; storage[temp9]);//内存中的值符号扩展后移位，实现复制</span><br><span class="line">                arg2 = temp8 + 0x20;//内存偏移量增加32字节</span><br><span class="line">                var temp12 = temp10 + 0x03;//slot偏移量增加3字节</span><br><span class="line">                var temp13 = (temp12 + 0x02) / 0x20;//重新计算下一个需要赋值的元素的slot位置增量</span><br><span class="line">                var0 = temp13 + temp9;//下一个需要赋值的元素的slot位置</span><br><span class="line">                var2 = 0x01 - temp13 * temp12;//判断结束时相关</span><br><span class="line"></span><br><span class="line">                if (var1 &lt;= arg2) &#123; goto label_0105; &#125;//根据内存读取位置判断是否结束赋值</span><br><span class="line">                else &#123; goto label_00C9; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_0147(var arg0, var arg1) returns (var r0) &#123;</span><br><span class="line">        if (arg0 &lt;= arg1) &#123;//结束的slot位置小于等于开始的slot位置</span><br><span class="line">        label_0160:</span><br><span class="line">            return arg0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        label_0151:</span><br><span class="line">            var temp0 = arg1;//开始的slot位置</span><br><span class="line">            storage[temp0] = 0x00;</span><br><span class="line">            arg1 = temp0 + 0x01;//开始的slot位置递增</span><br><span class="line"></span><br><span class="line">            if (arg0 &lt;= arg1) &#123; goto label_0160; &#125;</span><br><span class="line">            else &#123; goto label_0151; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读者阅读以上内容时，可能会感觉比较困难。实际上，笔者部分内容也没有弄的很清楚，例如逆向后的代码有许多异常处理、回滚、甚至 try/catch 的逻辑，这些都需要后面慢慢积累。</p>
<p>下面是 JEB 的逆向结果，可见抽象程度更高，通过 JUMPI 判断循环做的很好，但是粒度不够细，类型推断很武断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">contract DecompiledContract &#123;</span><br><span class="line">    unsigned char[3] g0_9;</span><br><span class="line"></span><br><span class="line">    function start() &#123;</span><br><span class="line">        uint256 v0, v1;</span><br><span class="line"></span><br><span class="line">        *0x40 = 0x80;</span><br><span class="line">        if(msg.value != 0x0) &#123;</span><br><span class="line">            revert(0x0, 0x0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v3 = storage[0x0];</span><br><span class="line">        v0 = signextend(0x2, 0xB);</span><br><span class="line">        g0_9 = v0 &amp; 0xffffff;</span><br><span class="line">        uint256 v2 = *0x40;</span><br><span class="line">        *0x40 = v2 + 0xA0;</span><br><span class="line">        v1 = signextend(0x2, 0x1);</span><br><span class="line">        v1 = signextend(0x2, v1);</span><br><span class="line">        *(uint256*)v2 = v1;</span><br><span class="line">        v1 = signextend(0x2, 0x2);</span><br><span class="line">        *(int256*)(v2 + 0x20) = v1;</span><br><span class="line">        v1 = signextend(0x2, 0x3);</span><br><span class="line">        *(int256*)(v2 + 0x40) = v1;</span><br><span class="line">        v1 = signextend(0x2, 0x4);</span><br><span class="line">        *(int256*)(v2 + 0x60) = v1;</span><br><span class="line">        v1 = signextend(0x2, 0x5);</span><br><span class="line">        *(int256*)(v2 + 0x80) = v1;</span><br><span class="line">        sub_A5(0x5, v2, 0x0);//(赋值的元素个数、内存开始位置、slot的位置)</span><br><span class="line">        codecopy(0x0, 0x1A1, 0x3F);</span><br><span class="line">        return(0x0, 0x3F);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sub_A5(uint256 param0, uint256 param1, uint256 param2) private returns (uint256) &#123;</span><br><span class="line">        uint256 v0, v1, v2, v3 = param0, v4 = param1;</span><br><span class="line"></span><br><span class="line">        param1 = v3 + 0x1;</span><br><span class="line">        if(param2 != 0x0) &#123;</span><br><span class="line">            uint256 v5 = v4;</span><br><span class="line">            v4 = param2;</span><br><span class="line">            param2 = v5;</span><br><span class="line">            v4 = v4 * 0x20 + param2;</span><br><span class="line">            uint256 i;</span><br><span class="line">            for(i = 0x0; param2 &lt; v4; i *= 0x1 - (i + 0x2) / 0x20) &#123;</span><br><span class="line">                v0 = storage[v3];</span><br><span class="line">                v1 = signextend(0x2, *(uint256*)param2);</span><br><span class="line">                storage[v3] = ((v1 &amp; 0xffffff) * 0x100 ** i) | (~(0x100 ** i * 0xffffff) &amp; v0);</span><br><span class="line">                param2 += 0x20;</span><br><span class="line">                i += 0x3;</span><br><span class="line">                v3 += (i + 0x2) / 0x20;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i != 0x0) &#123;</span><br><span class="line">                v2 = storage[v3];</span><br><span class="line">                storage[v3] = ~(0x100 ** i * 0xffffff) &amp; v2;</span><br><span class="line">                i += 0x3;</span><br><span class="line">                v3 += (i + 0x2) / 0x20;</span><br><span class="line">                i *= 0x1 - (i + 0x2) / 0x20;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sub_147(v3, param1);</span><br><span class="line">        return param0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sub_147(uint256 param0, uint256 param1) private returns (uint256) &#123;</span><br><span class="line">        while(param0 &gt; param1) &#123;</span><br><span class="line">            storage[param1] = 0x0;</span><br><span class="line">            ++param1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return param0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在 <code>label_00C9</code> 实际赋值的后面，<code>var2 = 0x01 - temp13 * temp12;</code> 语义比较奇怪，为什么是 <code>[结束位置的slot]-[slot增量]*[偏移量]</code> 呢？我们通过控制变量的办法进行对比分析。首先，我猜想是结束的位置的判断，改变结束的 slot 的位置。</p>
<ul>
<li>
<p>在数组前增加一个 slot</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">label_00CE:</span><br><span class="line">var temp7 = arg2;</span><br><span class="line">var temp8 = var0;</span><br><span class="line">var temp9 = var2;</span><br><span class="line">var temp10 = 0x0100 ** temp9;</span><br><span class="line">storage[temp8] = (signextend(0x02, memory[temp7:temp7 + 0x20]) &amp; 0xffffff) * temp10 | (~(temp10 * 0xffffff) &amp; storage[temp8]);</span><br><span class="line">arg2 = temp7 + 0x20;</span><br><span class="line">var temp11 = temp9 + 0x03;</span><br><span class="line">var temp12 = (temp11 + 0x02) / 0x20;</span><br><span class="line">var0 = temp12 + temp8;</span><br><span class="line">var2 = 0x01 - temp12 * temp11;</span><br><span class="line"></span><br><span class="line">if (var1 &lt;= arg2) &#123; goto label_010A; &#125;</span><br><span class="line">else &#123; goto label_00CE; &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现还是 <code>0x01</code>，<code>var2 = 0x01 - temp12 * temp11</code></p>
</li>
<li>
<p>增加变量，使得 slot 需要两个 slot 才能存储。我测试了数组长度分别位 11 和 21，发现语句仍然类似。</p>
</li>
</ul>
<p>因此可以得到初步结论，<code>var2 = 0x01 - temp12 * temp11</code> 是用于异常处理，和 <code>int24</code> 类型相关，用于跨 slot 时设置新的偏移量。也可能是用于清理某些垃圾数据，这和编译器的设计，漏洞处理相关，因此不深入探讨。</p>
<h4 id="字节码和逆向小结">字节码和逆向小结</h4>
<ol>
<li>直接分析字节码是相当困难的，因为人脑需要抽象，足够的抽象层次才能有效地进行逻辑分析。</li>
<li>借助辅助工具，如 Remix IDE 单步调试、逆向工具，可以辅助分析。尤其是逆向工具，可以简化一步一步跟踪堆栈的工作，直接关注计算、比较、赋值、跳转等核心逻辑。</li>
<li>JEB 逆向工具虽然抽象程度更高，但是准确度较低。而更细粒度的在线的逆向工具，可能更适合一些。</li>
<li>异常处理也是比较困难的部分，需要大量的经验和编译器基础，才会较为轻松。</li>
<li>字节码相关的博客较少，因为太过于深入、理论，往往需要查阅相关论文。</li>
<li>读者可以通过前面的深入探究的过程，总结学习的方法。</li>
</ol>
<h2 id="动态类型">动态类型</h2>
<p>动态类型是值不定长的类型，例如 <code>bytes</code>, <code>int[]</code> 等等，我们通过简单的例子来说明。</p>
<h3 id="bytes">bytes</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract SimpleDynamicVariable &#123;</span><br><span class="line">    bytes a;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        a=&quot;abc&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先观察操作码，可以得到如下分析。</p>
<ol>
<li>
<p>注意<strong>内存是按照字节编址，大端序</strong>。例如每一行是从右往左数，0x0 这一行左边的 <code>00</code> 是第 10 个字节。</p>
<img src="https://cdn.blog-blockchain.xyz/202205051603682.png" alt="image-20220505160326607" style="zoom:50%;" />
<p>它主要用于存储数组等较大的临时存储的数据。最开始默认的内存是 <code>0x80</code> 字节，因为之前的空间有特殊的用途，然后拓展了 <code>0x40</code> 字节，内存指针位置这是给 <code>bytes</code> 预分配的内存，作者猜测这是 <code>bytes</code> 默认的初次拓展的内存大小，后文会继续深入。</p>
</li>
<li>
<p><code>abc</code> 字符串按照 ASCII 编码，然后存入内存中。之所以存入内存，是因为 <code>bytes</code> 类型可能占用超过 32 字节，无法一次性通过栈操作。值得提出来的是，Remix IDE 内存视图中许多的问号，表示无法通过 ASCII 可视字符表示的值。这样能够直观的看到内存的内容。</p>
</li>
</ol>
<img src="https://cdn.blog-blockchain.xyz/202205051032100.png" alt="image-20220505103217897" style="zoom:50%;" />
<ol start="3">
<li>变量 <code>a</code> 实际上相当于含有 3 个元素的 <code>byte1[]</code> 类型，因此在第 29 步中 <code>PUSH1 03</code>，这样得到动态数组数据存储的位置。在某些地方通过哈希值寻找存储位置的方式，会叫做<strong>哈希指针</strong>，但是这和一般意义的指针是完全不一样的。</li>
<li>设置内存偏移为<code>0x80+0x20</code>，因为 <code>bytes</code> 长度用 32 字节存储。这里长度为 3，<code>0xa0</code> 后暂时存储 <code>byets</code> 的数据 <code>6162630000000000000000000000000000000000000000000000000000000000</code></li>
</ol>
<img src="https://cdn.blog-blockchain.xyz/202205051612929.png" alt="image-20220505161236847" style="zoom: 50%;" />
<p>我们再次回顾内存布局，<code>0x0-0x3f</code> 是哈希函数的暂存空间，<code>0x40-0x5f</code> 表示分配的内存大小，<code>0x60-0x80</code> 是动态数组的默认值，<code>0x80-0x9f</code> 是字节数组 <code>a</code> 的长度，<code>0xa0-0xbf</code> 是字节数组 <code>a</code> 的值。</p>
<ol start="5">
<li>内存偏移量为 <code>0x80</code>，载入 32 字节的数组长度到栈顶，将要计算哈希。</li>
</ol>
<p>由于操作码太多了，我们直接分析下面逆向后的伪代码。</p>
<p>需要注意：如果 <code>bytes</code> 数据不超过 31 字节，那么在变量所在的 slot 中，高 31 字节用于存放数据，最低的字节存放 <code>数组占用字节长度*2</code>。如果数据超过 31 字节，那么数据和变量要分开存储，变量所在的 slot 存放 <code>数组占用字节长度*2+1</code>，数据存放在序号为 <code>keecak(变量所在slot序号)</code> 的 slot 中。<code>string</code> 也满足这样的规律。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line"></span><br><span class="line">        var temp0 = memory[0x40:0x60];</span><br><span class="line">        memory[0x40:0x60] = temp0 + 0x40;//内存拓展40个字节</span><br><span class="line">        memory[temp0:temp0 + 0x20] = 0x03;//元素个数</span><br><span class="line">        memory[temp0 + 0x20:temp0 + 0x20 + 0x20] = 0x6162630000000000000000000000000000000000000000000000000000000000;//61 62 63 对应着 abc 的ASCII编码，而且bytes本质上是bytes1的数组</span><br><span class="line">        var0 = 0x005c;</span><br><span class="line">        var var1 = 0x00;//数组开始的slot位置</span><br><span class="line">        var var3 = memory[temp0:temp0 + 0x20];//取出元素个数</span><br><span class="line">        var var2 = temp0 + 0x20;//内存中数组开始的位置</span><br><span class="line">        var0 = func_0062(var1, var2, var3);</span><br><span class="line">        memory[0x00:0x3f] = code[0x0174:0x01b3];</span><br><span class="line">        return memory[0x00:0x3f];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_0062(var arg0, var arg1, var arg2) returns (var r0) &#123;//（slot起始位置，内存起始位置，元素个数）</span><br><span class="line">        var var0 = arg0;</span><br><span class="line">        var var1 = 0x006e;//默认的byte的元素个数为0x6e</span><br><span class="line">        var var2 = storage[var0];//取出slot中的数，</span><br><span class="line">        var1 = func_0134(var2);//返回原来这个slot中的元素个数</span><br><span class="line">        memory[0x00:0x20] = var0;//需要哈希的数据，这里是slot的位置 .0</span><br><span class="line">        var0 = keccak256(memory[0x00:0x20]);//哈希后的数据位置</span><br><span class="line">        var temp0 = var0 + (var1 + 0x1f) / 0x20;//计算结束的slot位置</span><br><span class="line">        var1 = arg1;//内存起始位置</span><br><span class="line">        arg1 = temp0;//结束的slot位置</span><br><span class="line"></span><br><span class="line">        if (!arg2) &#123;//元素个数为0，那么默认空值</span><br><span class="line">            storage[arg0] = 0x00;</span><br><span class="line">            goto label_00D7;</span><br><span class="line">        &#125; else if (0x1f &lt; arg2) &#123;//元素个数不为0，但是多于0x1f个，也就是说一个slot装不下</span><br><span class="line">            var temp1 = arg2;</span><br><span class="line">            storage[arg0] = temp1 + temp1 + 0x01;//slot存储 2*length+1，因为数组元素8位，所以数组占用的字节长度就是数组长度</span><br><span class="line"></span><br><span class="line">            if (!temp1) &#123;//数组长度为0</span><br><span class="line">            label_00D7:</span><br><span class="line">                var temp2 = arg1;//结束的slot位置</span><br><span class="line">                arg1 = 0x00e4;</span><br><span class="line">                var0 = var0;//数组数据开始的slot序号</span><br><span class="line">                arg2 = temp2;//结束的slot序号</span><br><span class="line">                arg1 = func_00E8(arg2, var0);//（结束的slot序号，数组数据开始的slot序号），这里应该是为了回滚，或者说是重置为默认值delete</span><br><span class="line">                return arg0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                var temp3 = arg2;//需要赋值的元素个数</span><br><span class="line">                var temp4 = var1;//内存开始位置</span><br><span class="line">                arg2 = temp4;//内存开始位置</span><br><span class="line">                var1 = arg2 + temp3;//内存结束位置，因为元素个数也等于字节长度</span><br><span class="line"></span><br><span class="line">                if (var1 &lt;= arg2) &#123;//</span><br><span class="line">                label_00D6:</span><br><span class="line">                    goto label_00D7;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                label_00C4:</span><br><span class="line">                    var temp5 = arg2;//内存开始位置</span><br><span class="line">                    var temp6 = var0;//slot序号</span><br><span class="line">                    storage[temp6] = memory[temp5:temp5 + 0x20];</span><br><span class="line">                    arg2 = temp5 + 0x20;//内存位置更新</span><br><span class="line">                    var0 = temp6 + 0x01;//slot序号+1</span><br><span class="line">                    var1 = var1;</span><br><span class="line"></span><br><span class="line">                    if (var1 &lt;= arg2) &#123; goto label_00D6; &#125;</span><br><span class="line">                    else &#123; goto label_00C4; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;//一个slot可以装下</span><br><span class="line">            var temp7 = arg2;//元素个数</span><br><span class="line">            //(memory[var1:var1 + 0x20] &amp; ~0xff)取的是高位，然后最低的一个字节存放 数组长度*2</span><br><span class="line">            storage[arg0] = temp7 + temp7 | (memory[var1:var1 + 0x20] &amp; ~0xff);</span><br><span class="line">            goto label_00D7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_00E8(var arg0, var arg1) returns (var r0) &#123;//用于在计算哈希后确定的slot位置处，进行写入</span><br><span class="line">        if (arg0 &lt;= arg1) &#123;//如果结束的slot序号小于等于开始的序号，这是出口</span><br><span class="line">        label_0101:</span><br><span class="line">            return arg0;</span><br><span class="line">        &#125; else &#123;//这是一般的入口</span><br><span class="line">        label_00F2:</span><br><span class="line">            var temp0 = arg1;//开始的位置</span><br><span class="line">            storage[temp0] = 0x00;</span><br><span class="line">            arg1 = temp0 + 0x01;//开始的位置+1</span><br><span class="line"></span><br><span class="line">            if (arg0 &lt;= arg1) &#123; goto label_0101; &#125;</span><br><span class="line">            else &#123; goto label_00F2; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_0134(var arg0) returns (var r0) &#123;//（slot0 的数据，256位）用于判断 bytes 的存储方式</span><br><span class="line">        var temp0 = arg0;</span><br><span class="line">        var var0 = temp0 / 0x02;//相当于右移 1 位</span><br><span class="line">        var var1 = temp0 &amp; 0x01;//取最低位</span><br><span class="line">        //注意，更具规则，如果数据和变量分开存储，那么是2*length+1，那么最低位一定是1。否则，数据一定小于 32 字节</span><br><span class="line">        if (!var1) &#123;//如果最低为为0，数据小于32字节</span><br><span class="line">            var temp1 = var0 &amp; 0x7f;//继续取出右移后的低七位，它们表示字节长度</span><br><span class="line">            var0 = temp1;//字节长度</span><br><span class="line">            //如果数组小于32字节，那么元素个数一定小于0x20，那么var1为 0</span><br><span class="line">            if (var1 != (var0 &lt; 0x20)) &#123; goto label_0160; &#125;</span><br><span class="line">            else &#123; goto label_0158; &#125;//异常处理</span><br><span class="line">        &#125; else if (var1 != (var0 &lt; 0x20)) &#123;//如果数据超过 31 字节，那么标志位和情况匹配，也是合法</span><br><span class="line">        label_0160:</span><br><span class="line">            return var0;//返回数组的字节长度</span><br><span class="line">        &#125; else &#123;//异常处理</span><br><span class="line">        label_0158:</span><br><span class="line">            var var2 = 0x015f;</span><br><span class="line">            memory[0x00:0x20] = 0x4e487b7100000000000000000000000000000000000000000000000000000000;</span><br><span class="line">            memory[0x04:0x24] = 0x22;//非法slot编码，panic(0x22)</span><br><span class="line">            revert(memory[0x00:0x24]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面详细分析了动态类型的存储方式，赋值方式。我们可以明白为什么 <code>bytes</code> 和 <code>string</code> 类型，超过 31 字节时，变量所在 slot 存放的时 <code>2*length+1</code>，而小于等于 31 字节时是 <code>2*length</code>，因为需要根据最低位区分这两种情况。超过 31 字节时，变量不会进行 compact，这可能是出于 gas 消耗的考虑，因为需要进行的操作可能非常多。如果开启编译器优化，那么就有可能会根据设定的运行次数，进行计算资源和存储资源的取舍。</p>
<p>下面不妨看看 JEB 逆向后的伪代码，可能抽象程度更高，帮助读者巩固逻辑。注意，它类型推断是不准确的，uint256 只是说明变量占 256 位。其次 *0x40 表示的是内存偏移 0x40 字节后的 32 字节的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">contract DecompiledContract &#123;</span><br><span class="line">    function start() &#123;</span><br><span class="line">        *0x40 = 0x80;</span><br><span class="line">        if(msg.value != 0x0) &#123;</span><br><span class="line">            revert(0x0, 0x0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 v0 = *0x40;</span><br><span class="line">        *0x40 = v0 + 0x40;</span><br><span class="line">        *(uint256*)v0 = 0x3;</span><br><span class="line">        *(int256*)(v0 + 0x20) = 0x6162630000000000000000000000000000000000000000000000000000000000;</span><br><span class="line">        sub_62(*(uint256*)v0, v0 + 0x20, 0x0);</span><br><span class="line">        codecopy(0x0, 0x174, 0x3F);</span><br><span class="line">        return(0x0, 0x3F);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sub_62(uint256 param0, uint256 param1, uint256 param2) private returns (uint256) &#123;</span><br><span class="line">        uint256 v0;</span><br><span class="line"></span><br><span class="line">        v0 = storage[param0];</span><br><span class="line">        uint256 v1 = sub_134(v0);</span><br><span class="line">        *0x0 = param0;</span><br><span class="line">        v0 = keccak256(0x0, 0x20);</span><br><span class="line">        uint256 v2 = v0;</span><br><span class="line">        v0 = param1;</span><br><span class="line">        param1 = (v1 + 0x1F) / 0x20 + v2;</span><br><span class="line">        if(!param2) &#123;</span><br><span class="line">            storage[param0] = 0x0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(param2 &lt;= 0x1F) &#123;</span><br><span class="line">            storage[param0] = (param2 * 0x2) | (*(uint256*)v0 &amp; 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            storage[param0] = param2 * 0x2 + 0x1;</span><br><span class="line">            if(param2 != 0x0) &#123;</span><br><span class="line">                uint256 v3 = v0;</span><br><span class="line">                v0 = param2;</span><br><span class="line">                param2 = v3;</span><br><span class="line">                v0 += param2;</span><br><span class="line">                while(param2 &lt; v0) &#123;</span><br><span class="line">                    storage[v2] = *(uint256*)param2;</span><br><span class="line">                    param2 += 0x20;</span><br><span class="line">                    ++v2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sub_E8(v2, param1);</span><br><span class="line">        return param0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sub_E8(uint256 param0, uint256 param1) private returns (uint256) &#123;</span><br><span class="line">        while(param0 &gt; param1) &#123;</span><br><span class="line">            storage[param1] = 0x0;</span><br><span class="line">            ++param1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return param0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sub_134(uint256 param0) private pure returns (uint256) &#123;</span><br><span class="line">        uint256 result = param0 / 0x2;</span><br><span class="line"></span><br><span class="line">        if(!(param0 &amp; 0x1)) &#123;</span><br><span class="line">            result &amp;= 0x7F;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if((param0 &amp; 0x1) != (uint256)(result &lt; 0x20)) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *0x0 = 0x4E487B7100000000000000000000000000000000000000000000000000000000;</span><br><span class="line">        *0x4 = 0x22;</span><br><span class="line">        revert(0x0, 0x24);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读者可能发现问题，我们只观察了不超过 31 字节的 bytes 的情况。如果是超过 31 字节的话，<code>bytes</code> 赋值是先从 memory 中 32 字节为单位加载，内存中的值一定是 tight packing 的。</p>
<h3 id="string">string</h3>
<p>string 和 bytes 非常类似，我们只改变上面代码中变量 a 的类型为 string，也来观察它的字节码逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line"></span><br><span class="line">        var temp0 = memory[0x40:0x60];</span><br><span class="line">        memory[0x40:0x60] = temp0 + 0x40;</span><br><span class="line">        memory[temp0:temp0 + 0x20] = 0x03;</span><br><span class="line">        memory[temp0 + 0x20:temp0 + 0x20 + 0x20] = 0x6162630000000000000000000000000000000000000000000000000000000000;</span><br><span class="line">        var0 = 0x005c;</span><br><span class="line">        var var1 = 0x00;</span><br><span class="line">        var var3 = memory[temp0:temp0 + 0x20];</span><br><span class="line">        var var2 = temp0 + 0x20;</span><br><span class="line">        var0 = func_0062(var1, var2, var3);</span><br><span class="line">        memory[0x00:0x3f] = code[0x0174:0x01b3];</span><br><span class="line">        return memory[0x00:0x3f];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_0062(var arg0, var arg1, var arg2) returns (var r0) &#123;</span><br><span class="line">        var var0 = arg0;</span><br><span class="line">        var var1 = 0x006e;</span><br><span class="line">        var var2 = storage[var0];</span><br><span class="line">        var1 = func_0134(var2);</span><br><span class="line">        memory[0x00:0x20] = var0;</span><br><span class="line">        var0 = keccak256(memory[0x00:0x20]);</span><br><span class="line">        var temp0 = arg1;</span><br><span class="line">        arg1 = var0 + (var1 + 0x1f) / 0x20;</span><br><span class="line">        var1 = temp0;</span><br><span class="line"></span><br><span class="line">        if (!arg2) &#123;</span><br><span class="line">            storage[arg0] = 0x00;</span><br><span class="line">            goto label_00D7;</span><br><span class="line">        &#125; else if (0x1f &lt; arg2) &#123;</span><br><span class="line">            var temp1 = arg2;</span><br><span class="line">            storage[arg0] = temp1 + temp1 + 0x01;</span><br><span class="line"></span><br><span class="line">            if (!temp1) &#123;</span><br><span class="line">            label_00D7:</span><br><span class="line">                var temp2 = arg1;</span><br><span class="line">                arg1 = 0x00e4;</span><br><span class="line">                var0 = var0;</span><br><span class="line">                arg2 = temp2;</span><br><span class="line">                arg1 = func_00E8(arg2, var0);</span><br><span class="line">                return arg0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                var temp3 = arg2;</span><br><span class="line">                var temp4 = var1;</span><br><span class="line">                arg2 = temp4;</span><br><span class="line">                var1 = arg2 + temp3;</span><br><span class="line"></span><br><span class="line">                if (var1 &lt;= arg2) &#123;</span><br><span class="line">                label_00D6:</span><br><span class="line">                    goto label_00D7;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                label_00C4:</span><br><span class="line">                    var temp5 = arg2;</span><br><span class="line">                    var temp6 = var0;</span><br><span class="line">                    storage[temp6] = memory[temp5:temp5 + 0x20];</span><br><span class="line">                    arg2 = temp5 + 0x20;</span><br><span class="line">                    var1 = var1;</span><br><span class="line">                    var0 = temp6 + 0x01;</span><br><span class="line"></span><br><span class="line">                    if (var1 &lt;= arg2) &#123; goto label_00D6; &#125;</span><br><span class="line">                    else &#123; goto label_00C4; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var temp7 = arg2;</span><br><span class="line">            storage[arg0] = temp7 + temp7 | (memory[var1:var1 + 0x20] &amp; ~0xff);</span><br><span class="line">            goto label_00D7;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_00E8(var arg0, var arg1) returns (var r0) &#123;</span><br><span class="line">        if (arg0 &lt;= arg1) &#123;</span><br><span class="line">        label_0101:</span><br><span class="line">            return arg0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        label_00F2:</span><br><span class="line">            var temp0 = arg1;</span><br><span class="line">            storage[temp0] = 0x00;</span><br><span class="line">            arg1 = temp0 + 0x01;</span><br><span class="line"></span><br><span class="line">            if (arg0 &lt;= arg1) &#123; goto label_0101; &#125;</span><br><span class="line">            else &#123; goto label_00F2; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_0134(var arg0) returns (var r0) &#123;</span><br><span class="line">        var temp0 = arg0;</span><br><span class="line">        var var0 = temp0 / 0x02;</span><br><span class="line">        var var1 = temp0 &amp; 0x01;</span><br><span class="line"></span><br><span class="line">        if (!var1) &#123;</span><br><span class="line">            var temp1 = var0 &amp; 0x7f;</span><br><span class="line">            var0 = temp1;</span><br><span class="line"></span><br><span class="line">            if (var1 != (var0 &lt; 0x20)) &#123; goto label_0160; &#125;</span><br><span class="line">            else &#123; goto label_0158; &#125;</span><br><span class="line">        &#125; else if (var1 != (var0 &lt; 0x20)) &#123;</span><br><span class="line">        label_0160:</span><br><span class="line">            return var0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        label_0158:</span><br><span class="line">            var var2 = 0x015f;</span><br><span class="line">            memory[0x00:0x20] = 0x4e487b7100000000000000000000000000000000000000000000000000000000;</span><br><span class="line">            memory[0x04:0x24] = 0x22;</span><br><span class="line">            revert(memory[0x00:0x24]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几乎是完全类似的。string 和 bytes 只是最后再前端的表现形式不一样。</p>
<h3 id="动态数组">动态数组</h3>
<p>读者应当能够理解下面 solidity doc 中的存储布局介绍。</p>
<blockquote>
<p>Assume the storage location of the mapping or array ends up being a slot <code>p</code> after applying <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#storage-inplace-encoding">the storage layout rules</a>. For dynamic arrays, this slot stores the number of elements in the array (byte arrays and strings are an exception, see <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#bytes-and-string">below</a>).</p>
</blockquote>
<blockquote>
<p>Array data is located starting at <code>keccak256(p)</code> and it is laid out in the same way as statically-sized array data would: One element after the other, potentially sharing storage slots if the elements are not longer than 16 bytes. Dynamic arrays of dynamic arrays apply this rule recursively. The location of element <code>x[i][j]</code>, where the type of <code>x</code> is <code>uint24[][]</code>, is computed as follows (again, assuming <code>x</code> itself is stored at slot <code>p</code>): The slot is <code>keccak256(keccak256(p) + i) + floor(j / floor(256 / 24))</code> and the element can be obtained from the slot data <code>v</code> using <code>(v &gt;&gt; ((j % floor(256 / 24)) * 24)) &amp; type(uint24).max</code>.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract DynamicVariable &#123;</span><br><span class="line">    int[] b;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        b=[int(1),2,3];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆向后的伪代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line"></span><br><span class="line">        var temp0 = memory[0x40:0x60];//0x80</span><br><span class="line">        memory[0x40:0x60] = temp0 + 0x60;//内存拓展0x60字节</span><br><span class="line">        memory[temp0:temp0 + 0x20] = 0x01;//0x80-0x9f写入1</span><br><span class="line">        var temp1 = temp0 + 0x20;</span><br><span class="line">        memory[temp1:temp1 + 0x20] = 0x02;</span><br><span class="line">        memory[temp1 + 0x20:temp1 + 0x20 + 0x20] = 0x03;</span><br><span class="line">        var0 = 0x3c;</span><br><span class="line">        var var1 = 0x00;//slot初始位置</span><br><span class="line">        var var2 = temp0;//内存初始位置</span><br><span class="line">        var var3 = 0x03;//赋值的元素个数</span><br><span class="line">        var0 = func_0041(var1, var2, var3);</span><br><span class="line">        memory[0x00:0x3f] = code[0xb1:0xf0];</span><br><span class="line">        return memory[0x00:0x3f];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_0041(var arg0, var arg1, var arg2) returns (var r0) &#123;//（slot起始位置、内存起始位置、需赋值的元素个数）</span><br><span class="line">        var temp0 = arg0;//slot起始位置</span><br><span class="line">        var temp1 = storage[temp0];//取出slot的值</span><br><span class="line">        var temp2 = arg2;//需要赋值的元素个数</span><br><span class="line">        storage[temp0] = temp2;//这个位置存放数组长度</span><br><span class="line">        memory[0x00:0x20] = temp0;//临时存放需要哈希的数</span><br><span class="line">        var var0 = keccak256(memory[0x00:0x20]);//计算哈希</span><br><span class="line">        var var1 = arg1;//内存起始位置</span><br><span class="line">        arg1 = var0 + temp1;//原来slot的值为0，这里用加法，可能是考虑到原来数组已经有值了，然后继续赋值的情况</span><br><span class="line"></span><br><span class="line">        if (!temp2) &#123;//出口，需要赋值的元素个数为0</span><br><span class="line">        label_007A:</span><br><span class="line">            var temp3 = arg1;//slot开始位置</span><br><span class="line">            arg1 = 0x85;</span><br><span class="line">            var0 = var0;//slot结束位置</span><br><span class="line">            arg2 = temp3;//slot开始位置</span><br><span class="line">            arg1 = func_0089(arg2, var0);</span><br><span class="line">            return arg0;</span><br><span class="line">        &#125; else &#123;//正常入口</span><br><span class="line">            var temp4 = arg2;//需要赋值的元素个数</span><br><span class="line">            var temp5 = var1;//内存起始位置</span><br><span class="line">            arg2 = temp5;//内存起始位置</span><br><span class="line">            var1 = arg2 + temp4 * 0x20;//内存结束位置</span><br><span class="line"></span><br><span class="line">            if (var1 &lt;= arg2) &#123;//循环出口，内存结束位置小于等于内存开始位置</span><br><span class="line">            label_0079:</span><br><span class="line">                goto label_007A;//结束赋值</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            label_0068:</span><br><span class="line">                var temp6 = arg2;//内存起始位置</span><br><span class="line">                var temp7 = var0;//slot起始位置</span><br><span class="line">                storage[temp7] = memory[temp6:temp6 + 0x20];//赋值，注意不会 tight compact</span><br><span class="line">                arg2 = temp6 + 0x20;//更新内存位置</span><br><span class="line">                var0 = temp7 + 0x01;//更新slot起始位置</span><br><span class="line">                var1 = var1;</span><br><span class="line"></span><br><span class="line">                if (var1 &lt;= arg2) &#123; goto label_0079; &#125;</span><br><span class="line">                else &#123; goto label_0068; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_0089(var arg0, var arg1) returns (var r0) &#123;</span><br><span class="line">        if (arg0 &lt;= arg1) &#123;//开始位置小于等于结束位置</span><br><span class="line">        label_00A0:</span><br><span class="line">            return arg0;</span><br><span class="line">        &#125; else &#123;//异常处理</span><br><span class="line">        label_0092:</span><br><span class="line">            var temp0 = arg1;</span><br><span class="line">            storage[temp0] = 0x00;</span><br><span class="line">            arg1 = temp0 + 0x01;</span><br><span class="line"></span><br><span class="line">            if (arg0 &lt;= arg1) &#123; goto label_00A0; &#125;</span><br><span class="line">            else &#123; goto label_0092; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多维数组的情况是按照以上规则，递归定义的。例如 <code>uint[][]</code> 可以看作 <code>uint[]</code> 作为元素的动态数组，然后元素 <code>uint[]</code> 的规则和上面的一致，以此类推。</p>
<h3 id="mapping">mapping</h3>
<p>首先 mapping 的存储布局如下：</p>
<blockquote>
<p>For mappings, the slot stays empty, but it is still needed to ensure that even if there are two mappings next to each other, their content ends up at different storage locations.</p>
</blockquote>
<blockquote>
<p>The value corresponding to a mapping key <code>k</code> is located at <code>keccak256(h(k) . p)</code> where <code>.</code> is concatenation and <code>h</code> is a function that is applied to the key depending on its type:</p>
<ul>
<li>for value types, <code>h</code> pads the value to 32 bytes in the same way as when storing the value in memory.</li>
<li>for strings and byte arrays, <code>h(k)</code> is just the unpadded data.</li>
</ul>
<p>If the mapping value is a non-value type, the computed slot marks the start of the data. If the value is of struct type, for example, you have to add an offset corresponding to the struct member to reach the member.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract DynamicVariable &#123;</span><br><span class="line">    mapping(uint=&gt;uint) c;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        c[1]=5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是逆向后的伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line"></span><br><span class="line">        memory[0x00:0x20] = 0x01;</span><br><span class="line">        memory[0x20:0x40] = 0x00;</span><br><span class="line"></span><br><span class="line">        //key 是1，然后补0成32位。后面是存储变量的slot的位置00</span><br><span class="line">        storage[keccak256(memory[0x00:0x40])] = 0x05;</span><br><span class="line">        memory[0x00:0x3f] = code[0x36:0x75];</span><br><span class="line">        return memory[0x00:0x3f];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照规则，字符串类型会有所不一样，我们假设 Bob 存了 100$，那么用映射表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract DynamicVariable &#123;</span><br><span class="line">    mapping(string=&gt;uint) c;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        c[&quot;Bob&quot;] = 100;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是逆向后的伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">contract Contract &#123;</span><br><span class="line">    function main() &#123;</span><br><span class="line">        memory[0x40:0x60] = 0x80;</span><br><span class="line">        var var0 = msg.value;</span><br><span class="line"></span><br><span class="line">        if (var0) &#123; revert(memory[0x00:0x00]); &#125;</span><br><span class="line"></span><br><span class="line">        var0 = 0x64;//Value 100</span><br><span class="line">        var var1 = 0x00;//slot位置</span><br><span class="line">        var var2 = 0x1e;</span><br><span class="line">        var var3 = memory[0x40:0x60];//内存开始位置 0x80</span><br><span class="line">        var2 = func_0087(var3);//内存结束位置</span><br><span class="line">        var temp0 = var2;//内存结束位置</span><br><span class="line">        memory[temp0:temp0 + 0x20] = var1;//附加slot位置</span><br><span class="line">        var temp1 = memory[0x40:0x60];//内存开始位置</span><br><span class="line"></span><br><span class="line">        //内存开始位置开始，Bob 连同后面的 0x20 字节的slot位置计算哈希</span><br><span class="line">        storage[keccak256(memory[temp1:temp1 + (temp0 + 0x20) - temp1])] = var0;</span><br><span class="line">        memory[0x00:0x3f] = code[0xa7:0xe6];</span><br><span class="line">        return memory[0x00:0x3f];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_0034(var arg0, var arg1) returns (var r0) &#123; return arg1; &#125;</span><br><span class="line"></span><br><span class="line">    function func_003F(var arg0) &#123;</span><br><span class="line">        memory[arg0:arg0 + 0x20] = 0x426f620000000000000000000000000000000000000000000000000000000000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_0068(var arg0) returns (var r0) &#123;</span><br><span class="line">        var var0 = 0x00;//slot起始位置</span><br><span class="line">        var var1 = 0x73;</span><br><span class="line">        var var2 = 0x03;//字符长度</span><br><span class="line">        var var3 = arg0;//内存开始位置</span><br><span class="line">        var1 = func_0034(var2, var3);//内存起始位置</span><br><span class="line">        var temp0 = var1;//内存开始位置</span><br><span class="line">        arg0 = temp0;//内存开始位置</span><br><span class="line">        var1 = 0x7c;</span><br><span class="line">        var2 = arg0;//内存开始位置</span><br><span class="line">        func_003F(var2);//Bob写入内存</span><br><span class="line">        return arg0 + 0x03;//内存开始位置+3字节，也就是内存结束位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function func_0087(var arg0) returns (var r0) &#123;</span><br><span class="line">        var var0 = 0x00;</span><br><span class="line">        var var1 = 0x90;</span><br><span class="line">        var var2 = arg0;//内存开始位置</span><br><span class="line">        return func_0068(var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然看起来比较复杂，但是逻辑较为简单。主要是 string 作为映射的键是不需要填充 0 的，所以需要将 Key 写入内存，并且确定内存中 Key 的结束位置。</p>
<h3 id="小结">小结</h3>
<ul>
<li>Solidity 语言的设计的思路和字节码高度相关。例如动态类型的存储方式的定义，在底层的读写和存储方面，有它设计的道理。</li>
<li>部分默认值实际上并不需要，这说明合约字节码有优化的空间。</li>
<li>不同的类型在字节码操作中都有一定的特征，但是通过字节码推断变量类型却并不是一件容易的事情。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz">Michael(Jiahao) Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz/evm/state-variable/">https://www.blog-blockchain.xyz/evm/state-variable/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/evm/">evm</a></div><div class="post-share"><div class="social-share" data-image="/images/evm-bytecode.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/evm/evm-basic-bytecode/" title="（一）初步认识EVM字节码"><img class="cover" src="/images/evm-bytecode.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">（一）初步认识EVM字节码</div></div><div class="info-2"><div class="info-item-1"> （一）初步认识EVM字节码（二）状态变量的赋值（三）函数调用  前言 在开始之前，我们默认读者已经初步理解 EVM, 包括字节码、操作码、堆栈、内存、存储、calldata。理解 ABI，能够根据文档计算对应变量的 ABI，并且具有一定的编译基础。因此，如果阅读过程中觉得困难，请先阅读 EVM 的其他文章，如 初步理解以太坊虚拟机。 本文编译器版本采用 0.8.10，EVM 版本是 London。没有特殊说明的条件下，默认关闭编译优化。建议读者复现时采用相同的编译器和 EVM，避免不一样的结果，虽然一般而言小版本的变化区别不大。 合约创建 字节码和运行时字节码 我们首先部署一个空的合约 Empty.sol，观察合约部署的字节码。这里需要注意区分运行时代码和部署时代码，creation bytecode 在部署后被舍弃，RETURN 的运行时字节码写入区块链。 123456// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract Empty &#123;&#125; 在...</div></div></div></a><a class="pagination-related" href="/evm/function-call/" title="（三）函数调用"><img class="cover" src="/images/evm-bytecode.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">（三）函数调用</div></div><div class="info-2"><div class="info-item-1"> （一）初步认识EVM字节码（二）状态变量的赋值（三）函数调用  普通函数调用 简单赋值 注意：需要区分部署时和运行时字节码，参考下面这张图。虽然现在的字节码有小改动，但是仍然有参考意义。  所以在编译成字节码是应该使用 solc --bin-runtime FILE_NAME 12345678910111213141516// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract Storage &#123;    uint256 number;    function store(uint256 num) public &#123;        number = num;    &#125;    function retrieve() public view returns (uint256)&#123;        return number;    &#125;&#125; 我们在部署时字节码正常的流程中是看不到函数的调用流程的。虽然 solc 产生的汇编使用...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/evm/data-layout/" title="以太坊的数据组织"><img class="cover" src="/images/evm.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-23</div><div class="info-item-2">以太坊的数据组织</div></div><div class="info-2"><div class="info-item-1"> 以太坊的数据组织初步理解以太坊虚拟机EVM的设计与原理  这篇文章主要介绍以太坊的数据组织形式，构建以太坊各部分数据结构是如何组织的系统观。随后，我将会选取黄皮书中的核心设计思想，写得相对通俗易懂。各部分具体的数据结构，将会在后续的源码解读中给出。 概览 以太坊的区块由区块头和区块体构成，区块头存储元数据，通过区块哈希形成链式结构。区块体用于存储交易的集合和其他数据，大致结构如下：  Trie Tree Trie Tree 被称作字典树，或者 前缀树 (prefix Tree)，用于管理键值对类型的多叉树。字典树的 Key 不是直接保存在某一个节点，而是通过节点在树中的位置确定，类似于哈夫曼编码树。因此，可知子节点都有相同的前缀。只有叶子节点才存放 Value，从根节点到叶子节点形成的路径上的节点，按照顺序排列构成 Value 的 Key.  假如 节点 d 存储 Value，则 and 是它的 Key 总体如下：  根节点不包含字符，根节点外的所有节点都只包含一个字符。 从根节点到某个节点，路径上经过的的字符连起来，为该节点对应的 Key. 每个节点的 Key...</div></div></div></a><a class="pagination-related" href="/evm/evm-basic-bytecode/" title="（一）初步认识EVM字节码"><img class="cover" src="/images/evm-bytecode.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-24</div><div class="info-item-2">（一）初步认识EVM字节码</div></div><div class="info-2"><div class="info-item-1"> （一）初步认识EVM字节码（二）状态变量的赋值（三）函数调用  前言 在开始之前，我们默认读者已经初步理解 EVM, 包括字节码、操作码、堆栈、内存、存储、calldata。理解 ABI，能够根据文档计算对应变量的 ABI，并且具有一定的编译基础。因此，如果阅读过程中觉得困难，请先阅读 EVM 的其他文章，如 初步理解以太坊虚拟机。 本文编译器版本采用 0.8.10，EVM 版本是 London。没有特殊说明的条件下，默认关闭编译优化。建议读者复现时采用相同的编译器和 EVM，避免不一样的结果，虽然一般而言小版本的变化区别不大。 合约创建 字节码和运行时字节码 我们首先部署一个空的合约 Empty.sol，观察合约部署的字节码。这里需要注意区分运行时代码和部署时代码，creation bytecode 在部署后被舍弃，RETURN 的运行时字节码写入区块链。 123456// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract Empty &#123;&#125; 在...</div></div></div></a><a class="pagination-related" href="/evm/basic-understanding-to-evm/" title="初步理解以太坊虚拟机"><img class="cover" src="/images/evm.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-23</div><div class="info-item-2">初步理解以太坊虚拟机</div></div><div class="info-2"><div class="info-item-1"> 以太坊的数据组织初步理解以太坊虚拟机EVM的设计与原理  体系结构  存储层 一般的客户端采用 LevelDB 数据库，而 OpenEthereum 采用了 RocksDB。LevelDB 是 Key-Value 的、基于 Log-Structured Merge Tree 的非关系数据库。例如 geth 的所有区块数据都是存储在 LevelDB 中，而 LevelDB 的实现在源代码的 ethdb 包内。 数据层 以太坊的数据层主要定义了数据结构、数据模型、哈希函数、签名算法等。以太坊采用独特的数据结构保护区块头和区块体，区块头含有交易的 Merkle 根哈希值，还有账户状态的 Merkle 根哈希值、日志的 Merkle 根哈希值。以太坊中 Merkle 根哈希值是采用 Merkle Patricia Tree 计算的。哈希函数使用 keccak256，数字签名采用 ECDSA。 网络层 以太坊节点通信采用的 p2p 协议是 DEVp2p，包含了 RLPx、Discv4 等子协议。RLPx 是安全的数据传输协议，采用 ECIES(Elliptic Curve...</div></div></div></a><a class="pagination-related" href="/evm/function-call/" title="（三）函数调用"><img class="cover" src="/images/evm-bytecode.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-24</div><div class="info-item-2">（三）函数调用</div></div><div class="info-2"><div class="info-item-1"> （一）初步认识EVM字节码（二）状态变量的赋值（三）函数调用  普通函数调用 简单赋值 注意：需要区分部署时和运行时字节码，参考下面这张图。虽然现在的字节码有小改动，但是仍然有参考意义。  所以在编译成字节码是应该使用 solc --bin-runtime FILE_NAME 12345678910111213141516// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.7.0 &lt;0.9.0;contract Storage &#123;    uint256 number;    function store(uint256 num) public &#123;        number = num;    &#125;    function retrieve() public view returns (uint256)&#123;        return number;    &#125;&#125; 我们在部署时字节码正常的流程中是看不到函数的调用流程的。虽然 solc 产生的汇编使用...</div></div></div></a><a class="pagination-related" href="/evm/principle-and-disign-of-evm/" title="EVM的设计与原理"><img class="cover" src="/images/evm.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-23</div><div class="info-item-2">EVM的设计与原理</div></div><div class="info-2"><div class="info-item-1"> 以太坊的数据组织初步理解以太坊虚拟机EVM的设计与原理  前言 在阅读这篇文章之前，请您先阅读初步理解以太坊虚拟机和以太坊的数据组织，它将会介绍 EVM 的基本知识，帮助您形成基本的认识。在开始之前，假设您已经掌握了上文中的基础，我们根据黄皮书进一步地补充理论基础。由于原始的黄皮书公式过多，不易阅读，可以参考按照论文重写后的版本。其次，本文使用的图片来自其他资料，会在参考资料部分注明。 非常推荐读者观看这个视频：EVM: From Solidity to byte code, memory and storage ，这是配套的 PDF。 它梳理源码到字节码的流程，演示操作码的变化，非常棒。如果读者通过前面提到的文章以及理解 EVM 的存储空间布局的话，这个视频可以为您提供字节码编写合约的基础:smirk_cat:.请善用 Remix IDE 的单步调试功能，可以通过实操，大大加深理解。 EVM 设计原理 以太坊可以抽象的分成两部分，一部分是状态，另外一部分是用于改变状态的...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Michael(Jiahao) Luo</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/LearnerLj"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/learnerLj" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:luoshitou9@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">从技术到商业，从产品到设计，从生活到未来，我会在这里分享我的所思所想，欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">状态变量的字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">静态类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">普通变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.1.2.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">元素赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">字面量赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E9%9C%80%E8%A6%81-compact-%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">变量需要 compact 的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E5%92%8C%E9%80%86%E5%90%91%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">字节码和逆向小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">动态类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bytes"><span class="toc-number">1.2.1.</span> <span class="toc-text">bytes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">1.2.2.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">动态数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mapping"><span class="toc-number">1.2.4.</span> <span class="toc-text">mapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>Post Series</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/evm/evm-basic-bytecode/" title="（一）初步认识EVM字节码"><img src="/images/evm-bytecode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（一）初步认识EVM字节码"></a><div class="content"><a class="title" href="/evm/evm-basic-bytecode/" title="（一）初步认识EVM字节码">（一）初步认识EVM字节码</a><time datetime="2022-08-24T10:29:33.000Z" title="Created 2022-08-24 18:29:33">2022-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/evm/state-variable/" title="（二）状态变量的赋值"><img src="/images/evm-bytecode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（二）状态变量的赋值"></a><div class="content"><a class="title" href="/evm/state-variable/" title="（二）状态变量的赋值">（二）状态变量的赋值</a><time datetime="2022-08-24T11:29:33.000Z" title="Created 2022-08-24 19:29:33">2022-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/evm/function-call/" title="（三）函数调用"><img src="/images/evm-bytecode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（三）函数调用"></a><div class="content"><a class="title" href="/evm/function-call/" title="（三）函数调用">（三）函数调用</a><time datetime="2022-08-24T11:30:33.000Z" title="Created 2022-08-24 19:30:33">2022-08-24</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/career/academic/" title="科研小总结"><img src="https://cdn.blog-blockchain.xyz/2024/11/f52e2456bd75a61f46d60e3768543c7f.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="科研小总结"/></a><div class="content"><a class="title" href="/career/academic/" title="科研小总结">科研小总结</a><time datetime="2024-11-21T17:38:21.000Z" title="Created 2024-11-22 01:38:21">2024-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/rss/" title="RSS信息汇聚"><img src="https://cdn.blog-blockchain.xyz/2024/11/07780b2a37df07c6fe3a70d3fa78b077.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RSS信息汇聚"/></a><div class="content"><a class="title" href="/dev/rss/" title="RSS信息汇聚">RSS信息汇聚</a><time datetime="2024-11-19T15:43:20.000Z" title="Created 2024-11-19 23:43:20">2024-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/crypto-practice/" title="安全加密实践-GPG"><img src="https://cdn.blog-blockchain.xyz/2024/11/ecd2b676f9bf98a607c67fc697f9ed4e.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安全加密实践-GPG"/></a><div class="content"><a class="title" href="/dev/crypto-practice/" title="安全加密实践-GPG">安全加密实践-GPG</a><time datetime="2024-11-18T09:28:20.000Z" title="Created 2024-11-18 17:28:20">2024-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/backup-practice/" title="传输和备份实践"><img src="https://cdn.blog-blockchain.xyz/2024/11/e9427ec31426e24ea92ff3d40382ed08.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="传输和备份实践"/></a><div class="content"><a class="title" href="/dev/backup-practice/" title="传输和备份实践">传输和备份实践</a><time datetime="2024-11-18T09:26:20.000Z" title="Created 2024-11-18 17:26:20">2024-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/macbook/" title="macbook体验"><img src="https://cdn.blog-blockchain.xyz/2024/11/f0e20c6b389a00ecf1945b34324cfdd1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="macbook体验"/></a><div class="content"><a class="title" href="/dev/macbook/" title="macbook体验">macbook体验</a><time datetime="2024-11-16T17:33:20.000Z" title="Created 2024-11-17 01:33:20">2024-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Michael(Jiahao) Luo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.2.2"></script><script src="/js/main.js?v=5.2.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '467d9506710fff22dc33',
      clientSecret: '2a3e530b895af9c94d4bbe95fe78c69317f4d76e',
      repo: 'blog-gitalk',
      owner: 'learnerLj',
      admin: ['learnerLj'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'c24ea21da7dcbb40993b7c855c1b805d'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.2.2"></script></div></div></body></html>