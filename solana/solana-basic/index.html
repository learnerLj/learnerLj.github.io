<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Solana 合约开发基础 | Logic's Tech Blog</title><meta name="author" content="Michael L"><meta name="copyright" content="Michael L"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><meta name="description" content="本文深入解析Solana独特的账户模型与交易结构，详解智能合约开发基础知识。包括账户与程序的关系、交易执行流程、Solscan交易分析、以及链上程序核心概念(IDL、PDA、CPI、调用上下文)。通过实例讲解与ETH的区别，并提供开发常见问题解答，帮助开发者理解Solana高性能并行处理的设计理念和实用开发技巧。">
<meta property="og:type" content="article">
<meta property="og:title" content="Solana 合约开发基础">
<meta property="og:url" content="https://www.blog-blockchain.xyz/solana/solana-basic/index.html">
<meta property="og:site_name" content="Logic's Tech Blog">
<meta property="og:description" content="本文深入解析Solana独特的账户模型与交易结构，详解智能合约开发基础知识。包括账户与程序的关系、交易执行流程、Solscan交易分析、以及链上程序核心概念(IDL、PDA、CPI、调用上下文)。通过实例讲解与ETH的区别，并提供开发常见问题解答，帮助开发者理解Solana高性能并行处理的设计理念和实用开发技巧。">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.blog-blockchain.xyz/2025/05/a8ff2c0938675dd107393164903785c8.png">
<meta property="article:published_time" content="2025-05-18T14:58:33.000Z">
<meta property="article:modified_time" content="2026-02-19T16:18:01.156Z">
<meta property="article:author" content="Michael L">
<meta property="article:tag" content="solana">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.blog-blockchain.xyz/2025/05/a8ff2c0938675dd107393164903785c8.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Solana 合约开发基础",
  "url": "https://www.blog-blockchain.xyz/solana/solana-basic/",
  "image": "https://cdn.blog-blockchain.xyz/2025/05/a8ff2c0938675dd107393164903785c8.png",
  "datePublished": "2025-05-18T14:58:33.000Z",
  "dateModified": "2026-02-19T16:18:01.156Z",
  "author": [
    {
      "@type": "Person",
      "name": "Michael L",
      "url": "https://www.blog-blockchain.xyz"
    }
  ]
}</script><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://www.blog-blockchain.xyz/solana/solana-basic/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/pwa/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?372b8854d18acf62880149b1e08e1901";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=QXcJQjXxTMeUwnWykFW2xw"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'QXcJQjXxTMeUwnWykFW2xw')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'QXcJQjXxTMeUwnWykFW2xw', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Solana 合约开发基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="Logic's Tech Blog" type="application/atom+xml">
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css');loadCss('https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css');loadCss('https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css');loadCss('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css"></noscript></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">102</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">32</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Logic's Tech Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Solana 合约开发基础</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Solana 合约开发基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-05-18T14:58:33.000Z" title="Created 2025-05-18 22:58:33">2025-05-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-19T16:18:01.156Z" title="Updated 2026-02-20 00:18:01">2026-02-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/solana/">solana</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">11.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>40mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h2 id="目标">目标</h2>
<ol>
<li>
<p>了解Solana账户模型和交易的模型</p>
<ul>
<li>掌握Solana账户的四个关键字段：数据、可执行标志、余额和所有者</li>
<li>理解Solana与ETH账户模型的区别及其优势</li>
<li>了解程序账户、数据账户和PDA的概念和用途</li>
</ul>
</li>
<li>
<p>深入交易的结构，理解Solana交易底层字段</p>
<ul>
<li>掌握交易的版本类型（Legacy和Version 0）及其区别</li>
<li>了解地址查找表（ALT）的作用和使用场景</li>
<li>熟悉交易结构中的签名、消息、账户权限和指令的组成</li>
</ul>
</li>
<li>
<p>能读懂Solscan上的所有内容，包括每个字段的含义和提供的trace</p>
<ul>
<li>解析交易元数据、执行结果和日志信息</li>
<li>理解账户变化、余额变化和计算单元消耗</li>
<li>掌握内部指令的含义和调用关系</li>
</ul>
</li>
<li>
<p>能读懂Solana底层的交易执行后的trace，了解交易执行的情况</p>
<ul>
<li>理解交易确认的三个级别：单次确认、乐观确认和最终确认</li>
<li>掌握交易日志的解读方法和常见问题排查思路</li>
<li>了解交易费用计算和计算单元消耗原理</li>
</ul>
</li>
<li>
<p>了解链上程序的基本概念，包括 IDL, PDA, CPI, 当前调用上下文、PDA签名</p>
<ul>
<li>IDL：合约接口描述语言及其在客户端调用中的应用</li>
<li>PDA：程序派生地址的生成原理和安全机制</li>
<li>CPI：跨程序调用的基本原理和实现方式</li>
<li>程序调用上下文和账户权限管理</li>
<li>无私钥签名机制的实现原理</li>
</ul>
</li>
</ol>
<p>总的来说理论和实际结合，知识点都给出了实际的运行数据和程序。</p>
<h2 id="1-Solana-账户模型">1. Solana 账户模型</h2>
<blockquote>
<p><strong>初学者须知</strong>：Solana的账户模型与以太坊等区块链不同，它采用了"一切皆账户"的设计理念。在Solana上，智能合约也是账户，用户余额也是账户，数据存储也是账户。这种设计使得Solana能够实现高度的并行化处理。</p>
</blockquote>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://solana.com/docs/core/accounts#data-account">Solana Account Model | Solana</a></p>
<p>每个账户都有一个唯一地址（32 字节 Ed25519 公钥）作为标识。单个账户最多可存储 10 MB 数据，账户的数据包括以下字段：</p>
<p><img src="https://cdn.blog-blockchain.xyz/2025/05/262796a0e6a45e7202e64cf6e2d6e129.png" alt="image-20250518222233864"></p>
<ul>
<li><strong>数据（data）</strong>：一个字节数组，存储账户的状态或程序代码。</li>
<li><strong>是否可执行（executable）</strong>：布尔值，指示账户是否包含可执行程序代码。</li>
<li><strong>余额（lamports）</strong>：账户中存储的 SOL 数量，单位为 lamport（1 SOL = 10⁹ lamports）。lamport是Solana的最小货币单位，类似于以太坊的wei或比特币的聪。它以计算机科学家Leslie Lamport命名，用于支付交易费用和作为账户租金。</li>
<li><strong>所有者（owner）</strong>：账户的程序所有者，只有该程序可以修改账户数据或减少账户余额。</li>
</ul>
<blockquote>
<p><strong>所有权概念解释</strong>：在Solana中，所有权（ownership）决定了谁可以修改账户数据。只有账户的所有者（通常是一个程序）才能修改该账户的数据或减少其余额。例如，如果一个账户的所有者是Token程序，那么只有Token程序才能修改该账户中存储的代币余额。普通用户无法直接修改账户数据，必须通过调用拥有该账户的程序来间接修改。这与以太坊的模型有显著区别，在以太坊中，合约拥有自己的存储空间并直接控制其内部状态。</p>
</blockquote>
<p>我们可以设想，它和ETH的账户模型的区别在哪里，在于这个账户模型里<strong>没有字节码</strong>。那么破除了智能合约+存储空间的存储模型，一个智能合约可以有很多个存储空间。那么这有什么好处呢，以ERC20为例子，我们可以把 <code>balance[user]=amount</code> 这个值存储在每个 user 的账户里，那么改变多个user的值的时候，就能够并行化处理了。因为存储空间单独属于每个用户。</p>
<blockquote>
<p><strong>与以太坊的对比</strong>：</p>
<ul>
<li><strong>以太坊</strong>：每个合约有单一的存储空间，所有用户数据存储在同一个合约状态中</li>
<li><strong>Solana</strong>：一个程序（合约）可以控制多个数据账户，每个用户的数据可以存储在单独的账户中</li>
<li><strong>并行执行</strong>：Solana的设计使得不相关的交易可以并行处理，显著提高了吞吐量</li>
</ul>
</blockquote>
<h3 id="1-1-Native-Programs">1.1 Native Programs</h3>
<p>除了上面简单提到的智能合约程序之外，如果需要统一执行的模型，我们还需要一些辅助的程序。比如，给持有 ERC20 代币的用户分配新的空白account，这叫做初始化。再比如给智能合约加载用户的数据。这些功能的实现，就由 Native Program 完成了。因为是预先在节点客户端代码里定义的，所以叫做「原生程序」</p>
<p>Native Programs 是 Solana 的内置程序，相当于区块链运行时的一部分，为开发者提供了基础功能支持。这些程序直接嵌入 Solana 的验证器实现中，保证了运行效率和安全性。</p>
<ul>
<li><strong>系统程序（System Program）</strong>：账户管理。</li>
<li><strong>BPFLoader 程序</strong>：BPFLoader 程序是 Solana 的"程序管理器"，专门用于处理自定义智能合约的部署和升级。其主要职责包括：<strong>加载程序</strong>：将编译好的程序代码上传到链上。<strong>管理更新</strong>：允许合约开发者对程序进行升级。<strong>执行代码</strong>：验证和执行程序代码，确保安全性和一致性。</li>
<li><strong>Sysvar 账户</strong>：存储 Solana 网络状态的特殊账户，如当前区块高度或时间戳。Sysvar 账户减少了链上数据查询的复杂度，为开发者提供了高效的状态读取方式。</li>
</ul>
<h3 id="1-2-系统程序（System-Program）">1.2 系统程序（System Program）</h3>
<p>系统程序（System Program）是 Solana 的原生程序之一，负责管理和初始化账户。可以理解为是一个"账户管理员"，负责创建账户、分配空间、设置账户的所有权。比如，用户的钱包账户默认由系统程序拥有，其 SOL 余额由系统程序管理。用户通过私钥控制账户，但账户的核心行为（如交易费用支付）由系统程序负责。</p>
<ul>
<li><strong>新账户创建</strong>：只有系统程序可以创建新账户。在创建账户时，用户需要指定账户的空间大小（以字节计）和初始 SOL 余额。</li>
<li><strong>空间分配</strong>：系统程序为账户分配存储空间。一旦创建，账户的大小是固定的，不能动态扩展。</li>
<li><strong>程序所有权分配</strong>：系统程序创建账户后，可以将账户的所有权转移给其他程序（如自定义智能合约）。</li>
<li><strong>系统账户</strong>：默认情况下，所有新账户的所有者是系统程序。只有由系统程序拥有的账户可以用于支付交易费用。</li>
</ul>
<p>这里所有权比较有意思，一个程序可以对应多个数据账户，那么这个权限就需要一个字段来表示。<strong>“所有权”</strong> 是一种程序和账户之间的权限关系，owner字段就记录了拥有该账户的程序的公共密钥，定义了谁有权修改账户中的数据或操作账户的余额。</p>
<h3 id="1-3-智能合约（Programs）">1.3 智能合约（Programs）</h3>
<p>在 Solana 中，智能合约被称为 <strong>程序（Programs）</strong>，是链上的可执行代码，用于实现复杂的业务逻辑和交互流程。提到程序和数据是分离，但是程序本身又做了数据和元信息的分离，这样能够对程序进行升级。一笔升级合约的交易，先创建一个缓冲区账户，然后将新字节码从缓冲区账户移动到 <strong>可执行数据账户</strong>，同时保持 <strong>Program ID 不变</strong>。这样一次性替换而不是修改，不能修改的原因是，每个账户的数据是 <strong>预分配的、定长的，不允许动态修改大小</strong>。</p>
<p><strong>程序账户（Program Account）</strong>：程序的核心账户，存储合约的元数据（如更新权限）。其地址通常被称为 <strong>Program ID</strong>，用于标识和调用该程序。</p>
<p><strong>可执行数据账户（Executable Data Account）</strong>：存储编译后的合约字节码（可执行代码）。标记为可执行（executable = true）。</p>
<p><strong>缓冲区账户（Buffer Account）</strong>：临时账户，用于合约的部署或升级过程中存储字节码。一旦部署完成，数据会被转移到可执行数据账户，缓冲区账户会被关闭。</p>
<p><img src="https://cdn.blog-blockchain.xyz/2025/05/978e68add1bce83c344cd18535e10774.png" alt="image-20250518222255401"></p>
<p>那如何避免可执行数据账户被修改呢，程序账户中的元数据决定的。</p>
<h3 id="1-4-数据账户（Data-Accounts）">1.4 数据账户（Data Accounts）</h3>
<p>上一节的程序账户指向的Executable Data Account 和这一节的数据账户是相同的结构，关键在于字段 <strong>executable = true 或者false</strong>。可执行的数据账户里存的是BPF代码，而且还存在限制，data 大小是固定的，不能修改。但是普通数据账户是可以通过支付租金，<strong>realloc</strong> 进行扩展或缩小。</p>
<p>智能合约的"无状态性"设计，意味着它需要依赖其他账户存储链上的状态数据，这些账户被称为 <strong>数据账户（Data Accounts）</strong>。</p>
<p>创建过程：数据账户的创建由系统程序完成，开发者需要指定账户的存储空间和初始 SOL 押金（租金）。系统程序将数据账户的所有权转移给目标程序（智能合约）。智能合约通过调用初始化方法，对数据账户进行写入操作，存储特定的状态信息。</p>
<p>数据账户可以存储任意数据结构，但存储空间有限（最大 10 MB）。数据账户的数据只能由其所有者（即目标程序）修改，其他程序或用户无法直接更改。</p>
<p>下图表示所有权的关系</p>
<p><img src="https://cdn.blog-blockchain.xyz/2025/05/3874c8720d8b07abea847fb625f306a8.png" alt="image-20250518222310713"></p>
<p>根据上面账户模型，我们可以知道程序应该是如何被调用和执行的。首先程序应该花租金，通过系统程序部署在链上。然后要和程序交互，就要定义至少3个部分，第一个部分程序的逻辑，第二部部分数据账户的结构，第三部分程序读取数据账户时的结构或者上下文。</p>
<p>真实的例子，程序账户，读者应该能理解其中的字段了：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://solscan.io/account/675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8">https://solscan.io/account/675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8</a></p>
<img src="https://cdn.blog-blockchain.xyz/2025/05/9165d48db667bc9949b8743c280b8c53.png" alt="image-20250518222330746" style="zoom: 33%;">
<h2 id="2-交易和指令的结构">2. 交易和指令的结构</h2>
<blockquote>
<p><strong>初学者须知</strong>：Solana交易是不可变的指令集合，一旦提交就必须整体成功或失败。了解交易结构对于调试问题和优化执行至关重要。交易大小限制和账户包含方式都会影响应用设计决策。</p>
</blockquote>
<h3 id="2-1-交易的版本">2.1 交易的版本</h3>
<p>Solana 目前支持的交易版本实际上只有两种：</p>
<ol>
<li><strong>Legacy 版本</strong>：较旧的交易格式，没有额外的功能特性</li>
<li><strong>版本 0（Version 0）</strong>：新增了对地址查找表（Address Lookup Tables）的支持</li>
</ol>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://solana.com/zh/developers/guides/advanced/versions">https://solana.com/zh/developers/guides/advanced/versions</a> 指出当使用 RPC 请求获取交易数据时，必须通过 <code>maxSupportedTransactionVersion</code> 选项指定您的应用程序支持的最高交易版本，否则如果返回了版本 0 的交易，而您没有设置支持该版本，请求就会失败。</p>
<p>ALT 允许交易引用存储在链上的账户地址，而不必在每笔交易中包含完整的地址。过去每个地址是完整 32 字节，版本 0 交易可以使用短索引（通常只需 1 字节）。实际完整的交易存储在特殊的帐户里，叫做Address Lookup Table Account。这样可以实现重复使用，减小交易大小。同时由于交易大小有限制（通常是1232字节，来源于 IPv6 MTU 大小（1280 字节）减去网络头部（48 字节）），这直接限制了一个交易可以包含的账户数量，32字节变成1字节，能够处理的账户数量从几十上升到几百。</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://solscan.io/tx/3TJB6skkXLyDKxxjREX3tGcMt1DHJxnWoK74KPkoDwNUniXJuhXhKbNrHp4qrqeZofD9gQH7gpX7jfi5RBRxV7uH">https://solscan.io/tx/3TJB6skkXLyDKxxjREX3tGcMt1DHJxnWoK74KPkoDwNUniXJuhXhKbNrHp4qrqeZofD9gQH7gpX7jfi5RBRxV7uH</a> 里就用到了 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://solscan.io/account/2Kzkpo4uvvZLCysuJY8mhjVDr4LLDJnXfBJJs5TEmRxH">https://solscan.io/account/2Kzkpo4uvvZLCysuJY8mhjVDr4LLDJnXfBJJs5TEmRxH</a> ，里面有256个帐户。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">solana address-lookup-table get 2Kzkpo4uvvZLCysuJY8mhjVDr4LLDJnXfBJJs5TEmRxH</span><br><span class="line"></span><br><span class="line">Lookup Table Address: 2Kzkpo4uvvZLCysuJY8mhjVDr4LLDJnXfBJJs5TEmRxH</span><br><span class="line">Authority: 9RAufBfjGQjDfrwxeyKmZWPADHSb8HcoqCdrmpqvCr1g</span><br><span class="line">Deactivation Slot: None (still active)</span><br><span class="line">Last Extended Slot: 316103504</span><br><span class="line">Address Table Entries:</span><br><span class="line"></span><br><span class="line">  Index  Address</span><br><span class="line">  0      TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb</span><br><span class="line">  1      C4LzKsC9rmAEnr8MohSmz82oc3EUuSWidASubPhJPZAX</span><br><span class="line">  2      A5PEzX4vSy4k9mQAaL3SHGdp4rMiKcom3UC8D5DVkmbd</span><br><span class="line">  3      C3hgpaU9er7Uy7cuMUMCBbwyAfUexQa5wrJrJqPRt5XE</span><br><span class="line">  4      5F76B9a5pyv3iV7xS15fu8FTE2EVXVA8sG436VFkGE5e</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>在addressTableLookups 指定了的账户，会拼接到 account keys 后面，同样的用指令索引。参考后面的交易结构。</p>
<h3 id="2-2-交易的结构">2.2 交易的结构</h3>
<p>对于已经确认过的交易，也就是历史交易，会包括 slot, 区块时间、交易版本（Legacy 或者是 version 0）。最重要的是交易体和元信息。交易体主要是，参考<a target="_blank" rel="noopener external nofollow noreferrer" href="https://solana.com/zh/docs/core/transactions">https://solana.com/zh/docs/core/transactions</a></p>
<ul>
<li><strong>签名（Signatures）</strong>：交易签名数组，每个签名 64 字节</li>
<li><strong>消息（Message）</strong>：交易的实际内容，包含所有执行信息</li>
</ul>
<img src="https://cdn.blog-blockchain.xyz/2025/05/65cf606b73a7ffc5962754290edfeab7.png" alt="image-20250518222439672" style="zoom: 33%;">
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Message</span> {</span><br><span class="line">    <span class="keyword">pub</span> header: MessageHeader,</span><br><span class="line">    <span class="keyword">pub</span> account_keys: <span class="type">Vec</span>&lt;Pubkey&gt;,</span><br><span class="line">    <span class="keyword">pub</span> recent_blockhash: Hash,</span><br><span class="line">    <span class="keyword">pub</span> instructions: <span class="type">Vec</span>&lt;CompiledInstruction&gt;,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<img src="https://cdn.blog-blockchain.xyz/2025/05/8c7f229679a18c38126a27ab1f2d2d83.png" alt="image-20250518222504385" style="zoom:33%;">
<ul>
<li>
<p>消息头（Header）</p>
<p>：描述账户权限和签名要求。这里只定义了数量，那么还要排序机制来识别账户类型，所以账户地址是有顺序的。</p>
<ul>
<li><strong>num_required_signatures</strong>：交易需要的签名数量</li>
<li><strong>num_readonly_signed_accounts</strong>：只读且需要签名的账户数量</li>
<li><strong>num_readonly_unsigned_accounts</strong>：只读且不需要签名的账户数量</li>
</ul>
</li>
<li>
<p><strong>账户地址（Account Keys）</strong>：交易涉及的所有账户地址列表。[可写且是签名者的账户, 只读且是签名者的账户, 可写但不是签名者的账户, 只读且不是签名者的账户]，Solana 可以将账户数组分成四个区域（可写+签名、只读+签名、可写+不签名、只读+不签名），好做并发处理。</p>
</li>
<li>
<p><strong>最近区块哈希（Recent Blockhash）</strong>：交易的时间戳。</p>
</li>
<li>
<p><strong>编译指令（Compiled Instructions）</strong>：要执行的指令列表。</p>
</li>
<li>
<p>address_table_lookups：这个是可选的，Legacy交易没有。可以有多个ALT账户，折合account keys 是独立的。每个账户会指明</p>
<ul>
<li><strong>account_key: Pubkey：</strong> 查找表账户的公钥地址。</li>
<li><strong>writable_indexes: Vec<u8>：</u8></strong> 用于加载可写账户地址的索引列表。</li>
<li><strong>readonly_indexes: Vec<u8>：</u8></strong> 用于加载只读账户地址的索引列表</li>
</ul>
</li>
</ul>
<p>指令是最关键的，在account keys里，程序的索引，帐户的索引，以及输入参数。</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub struct CompiledInstruction <span class="punctuation">{</span></span><br><span class="line">    pub program_id_index<span class="punctuation">:</span> u8<span class="punctuation">,</span></span><br><span class="line">    pub accounts<span class="punctuation">:</span> Vec&lt;u8&gt;<span class="punctuation">,</span></span><br><span class="line">    pub data<span class="punctuation">:</span> Vec&lt;u8&gt;<span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-3-RPC返回结果">2.3 RPC返回结果</h3>
<blockquote>
<p><strong>什么是RPC</strong>：RPC（Remote Procedure Call，远程过程调用）是与Solana区块链交互的主要方式。开发者通过RPC接口发送交易和查询区块链状态。当你使用钱包发送SOL或调用智能合约时，底层都是通过RPC请求完成的。交易确认状态、账户数据查询和程序调用都通过RPC节点处理，理解RPC是开发Solana应用的基础。</p>
</blockquote>
<p>交易执行后，还会有交易执行结果的元数据，包含了交易执行前后的状态变化以及执行过程中的详细信息。</p>
<ul>
<li><strong>err: Option<transactionerror>：</transactionerror></strong> 交易执行是否出错，如果有错误则包含错误类型。为 None 表示交易成功执行。</li>
<li><strong>status: TransactionResult&lt;()&gt;：</strong> 注释标明此字段已弃用，保留是为了向后兼容</li>
<li><strong>fee: u64：</strong> 交易实际支付的费用（以 lamports 为单位）</li>
<li><strong>pre_balances / post_balances: Vec<u64>：</u64></strong> 交易执行前后所有相关账户的余额（以 lamports 为单位），顺序与交易的 account_keys 相同</li>
<li><strong>inner_instructions: OptionSerializer&lt;Vec<uiinnerinstructions>&gt;。</uiinnerinstructions></strong> 交易内部执行的指令（例如一个指令可能触发其他程序的指令）</li>
<li><strong>log_messages: OptionSerializer&lt;Vec<string>&gt;，</string></strong> 交易执行过程中程序输出的日志消息，开发者常用这些日志进行调试。</li>
<li>pre_token_balances / post_token_balances: OptionSerializer&lt;Vec<uitransactiontokenbalance>&gt;
<ul>
<li>交易执行前后相关账户的代币余额</li>
<li>仅适用于涉及 SPL 代币的交易</li>
</ul>
</uitransactiontokenbalance></li>
<li><strong>rewards: OptionSerializer<rewards> ：</rewards></strong> 交易执行过程中分配的奖励（通常用于验证者奖励）</li>
<li><strong>loaded_addresses: OptionSerializer<uiloadedaddresses>：</uiloadedaddresses></strong> 通过地址查找表加载的额外地址。版本 0 交易特有的字段</li>
<li><strong>return_data: OptionSerializer<uitransactionreturndata>：</uitransactionreturndata></strong> 程序执行返回的数据</li>
<li><strong>compute_units_consumed: OptionSerializer<u64>：</u64></strong> 交易执行消耗的计算单元数量。用于了解交易的计算复杂度</li>
</ul>
<p>这里比较关键的是内部指令。当一个 Solana 程序（智能合约）执行时，它可以通过跨程序调用（Cross-Program Invocation, CPI）调用其他程序。这些被调用的指令就是"内部指令"。</p>
<ul>
<li><code>index</code>: 表示触发这些内部指令的原始交易指令的索引。</li>
<li><code>instructions</code>: 包含所有被触发的内部指令列表。</li>
</ul>
<p>比较有趣的是，内部指令的嵌套关系主要通过 <code>stackHeight</code> 字段来表示，而不是通过 JSON 的物理结构。solscan上也没有体现嵌套。</p>
<p>看一个复杂的例子，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://gist.github.com/learnerLj/872c4831f0b6a8d93096f13105da1b89%E3%80%82">https://gist.github.com/learnerLj/872c4831f0b6a8d93096f13105da1b89。</a></p>
<ul>
<li>第1个账户 (<code>ERtGUg2LUTdWKQDpHGZSwZpuZMYvTVqE22Lub1XCmP1f</code>): 可写 + 需要签名（唯一需要签名的账户）</li>
<li>第2-8个账户 (从 <code>6WLBpdFzC5td9H62ZdAFmMS5hrK12sTCs1BjdmKZK2ep</code> 到 <code>Hx7Q2g7KPRB9J2b7yS1gk8K9X9aPT2XzZMhUVjFYcTYg</code>): 可写 + 不需要签名</li>
<li>最后7个账户 (从 <code>11111111111111111111111111111111</code> 到 <code>J2nUHEAgZFRyuJbFjdqPrAa9gyWDuc7hErtDQHPhsYRp</code>): 只读 + 不需要签名。</li>
</ul>
<h2 id="3-交易的流程">3. 交易的流程</h2>
<p>Solana 的交易执行流程主要分为以下几个阶段：</p>
<ol>
<li><strong>交易构造</strong>：用户创建交易，指定目标程序、相关账户和指令数据，并用私钥签名。</li>
<li><strong>交易提交</strong>：钱包或应用程序将交易提交到 Solana 节点（RPC 服务器）。</li>
<li><strong>交易验证</strong>：节点检查交易的签名、账户权限和余额等。</li>
<li><strong>交易执行</strong>：按指令调用目标程序，并在 Solana 的并行运行时中执行。</li>
<li><strong>交易确认</strong>：如果交易成功执行并最终写入区块，返回交易哈希作为确认。</li>
</ol>
<h3 id="3-1-准备">3.1 准备</h3>
<p><strong>签名（Signatures）</strong>：交易需要由 <strong>发送方钱包</strong> 使用私钥签名，以证明交易的合法性。 一个交易可以包含多个签名（例如，多重签名交易）。</p>
<p><strong>消息（Message）</strong>：描述交易的细节，包括目标程序（Program ID）、相关账户及操作指令。</p>
<p><strong>账户列表（Account Keys）</strong>：指定交易涉及的所有账户，包括程序账户、数据账户、用户账户等。在交易执行时，这些账户会被<strong>预加载</strong>到内存，使 Solana 能够<strong>并行处理</strong>交易，而不会因为未预先声明的账户访问而引发冲突。</p>
<p>消息中的指令，是对程序的具体调用请求，包含：</p>
<ul>
<li><strong>目标程序（Program ID）</strong>：需要调用的智能合约。</li>
<li><strong>账户列表</strong>：程序需要访问的账户。</li>
<li><strong>指令数据（Instruction Data）</strong>：具体操作的参数或方法标识。</li>
</ul>
<img src="https://cdn.blog-blockchain.xyz/2025/05/e086d7b5ab1cc9f1a321bb7eb59ee88b.png" alt="image-20250518222624081" style="zoom:33%;">
<h3 id="3-2-发送交易">3.2 发送交易</h3>
<p>客户端将交易发送到本地的 RPC 节点（通常由钱包或 DApp 提供）。RPC 节点会将交易广播到整个 Solana 网络的验证器节点。验证通过的交易会被添加到候选区块中，等待领导节点（Leader Node）将其提交到区块链。</p>
<p>你可以看到当前的leader以及他们的位置 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://app.marinade.finance/network/">https://app.marinade.finance/network/</a> , 可以发现德国、法国、荷兰、美国东部是出现概率最高的。</p>
<h3 id="3-3-调用合约（智能合约执行）">3.3 调用合约（智能合约执行）</h3>
<p>交易执行时，验证节点从链上加载交易涉及的所有账户数据（包括程序账户和数据账户）到内存中。账户数据包含程序代码（如果是程序账户）和存储的状态信息（如果是数据账户）。</p>
<p>Solana 的运行时调用目标合约的代码（程序账户中存储的字节码），并传入以下参数：</p>
<ul>
<li>交易中指定的账户列表，所有涉及的账户必须被正确声明，并满足访问权限。</li>
<li>指令数据（包含调用方法及其参数）。</li>
<li>程序在运行时中执行逻辑，访问和修改相关账户的状态。</li>
</ul>
<p>如果程序需要调用其他合约，可以通过 <strong>Cross-Program Invocation（CPI）</strong> 实现。当前程序暂停执行，将控制权转交给目标合约。完成后，返回执行结果，继续当前程序的逻辑。</p>
<h3 id="3-3-返回结果与确认">3.3 返回结果与确认</h3>
<blockquote>
<p><strong>交易确认与前端设计</strong>：理解Solana的确认级别对前端开发至关重要。例如，处理一笔支付时，你可能希望在显示"处理中"状态后，收到"乐观确认"（约1秒）时更新为"正在确认"，最终在"最终确认"（约16秒）后更新为"已完成"。不同应用场景需要不同的确认级别，正确选择可以在安全性和用户体验间取得平衡。</p>
</blockquote>
<p>程序执行完成后，将结果（如账户状态更新、事件触发）写入到内存中的账户数据。如果发生错误（如参数无效或余额不足），交易会被回滚，账户数据恢复到初始状态。成功的交易会被记录在区块链上，生成交易哈希（Transaction Hash）。<strong>失败的交易不会被记录</strong>，但错误信息会返回给客户端。</p>
<p>在 Solana 上，交易的确认由 <strong>多个层级</strong> 决定，主要包括：</p>
<ol>
<li><strong>单次确认（Single Confirmation）</strong></li>
<li><strong>乐观确认（Optimistic Confirmation）</strong></li>
<li><strong>最终确认（Final Confirmation）</strong></li>
</ol>
<p>不同的确认级别提供了不同的交易安全性保证，应用可以根据需求选择适当的确认方式。Solana 的 <strong>RPC 服务</strong> 允许开发者查询交易状态，并提供三种主要的 commitment 级别，与确认层级相对应：</p>
<table>
<thead>
<tr>
<th><strong>确认级别</strong></th>
<th>处理过程</th>
<th>特点</th>
<th><strong>相关 RPC commitment</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>单次确认（Single Confirmation）</strong></td>
<td>1. 交易被提交到 <strong>Leader（当前区块生产者）</strong> 处理。2. Leader 节点打包交易，并将其包含在最新的区块中。3. 交易的区块被广播到网络，<strong>但尚未被其他验证者确认</strong>。</td>
<td>交易 <strong>已经进入区块</strong>，但未经过验证者共识确认。可能会因为 <strong>网络分叉</strong> 而被回滚。适用于<strong>低延迟、高频交易场景</strong>（如 DEX 下单）。</td>
<td>processed</td>
</tr>
<tr>
<td><strong>乐观确认（Optimistic Confirmation）</strong></td>
<td>1. 交易所在的区块 <strong>已经被至少 1 个后续区块确认</strong>。2. 交易的成功率大幅提高，因为网络中大多数验证者已经接受了该区块。3. <strong>回滚的可能性大幅降低</strong>，但仍然存在极端情况下的分叉风险。</td>
<td>交易大概率不会被回滚，适合<strong>普通 DeFi 交易</strong>（如借贷、流动性操作）。交易的确认速度很快，通常在 <strong>400ms - 1s</strong> 之间完成。适用于 <strong>中等安全性场景</strong>。</td>
<td>confirmed</td>
</tr>
<tr>
<td><strong>最终确认（Final Confirmation）</strong></td>
<td>1. 交易被<strong>32 个后续区块确认</strong>（约 16 秒后）。2. 交易进入 <strong>区块历史（Ledger History）</strong>，不可逆转。3. 由于 Solana 采用 <strong>Tower BFT</strong> 共识机制，一旦 32 个区块确认，意味着 <strong>整个网络都达成了一致</strong>。</td>
<td>交易<strong>100% 不可逆</strong>，不会因分叉被撤销。适用于<strong>提款、结算等高安全性操作</strong>。一般情况下，大约 <strong>16 秒</strong> 内可达最终确认。</td>
<td>finalized</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更加详细见：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.helius.dev/blog/solana-commitment-levels">https://www.helius.dev/blog/solana-commitment-levels</a></p>
</blockquote>
<h2 id="4-链上程序">4 链上程序</h2>
<p>建议学习 anchor <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.anchor-lang.com/">https://www.anchor-lang.com/</a> , 完成下面的示例： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://beta.solpg.io/tutorials/hello-anchor">https://beta.solpg.io/tutorials/hello-anchor</a></p>
<h3 id="4-1-基本结构">4.1 基本结构</h3>
<img src="https://cdn.blog-blockchain.xyz/2025/05/37b5e55348ff614a5f2e0ae0b422cf56.png" alt="image-20250518223540100" style="zoom:33%;">
<p>line 4 的 id 就是程序的公钥，也是程序的ID。 <code>#[derive(Accounts)]</code> 是交互的上下文，因为不需要额外控制，所以为空即可。因为不需要数据的输入，我们没有定义数据账户。</p>
<h3 id="4-2-解读指令">4.2 解读指令</h3>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://solscan.io/tx/56SyMzu5DfoPK8xwNytg5iH6s1K4KGhWwDitwp3F8FvAPn9HGAi9LuySJvLUQrXxZhHKKFVR9fbUPo7Um2mE4Jag?cluster=devnet">https://solscan.io/tx/56SyMzu5DfoPK8xwNytg5iH6s1K4KGhWwDitwp3F8FvAPn9HGAi9LuySJvLUQrXxZhHKKFVR9fbUPo7Um2mE4Jag?cluster=devnet</a></p>
<p>看部署结果，大概消耗了2.54 sol。下面是<strong>相关账户字段</strong>：</p>
<img src="https://cdn.blog-blockchain.xyz/2025/05/9f474fcceaa84662060efeff6feffa45.png" alt="image-20250518223554241" style="zoom:33%;">
<ol>
<li>4T3p是我的地址，资金来源。</li>
<li>Nyy8 是程序账户，程序ID。</li>
<li>FHnS 是程序的可执行数据账户，存储BPF字节码。</li>
<li>Qfu4 是缓冲区账户。</li>
<li>System Program 是 系统程序（用于账户创建和资金转移）</li>
<li>BPF Upgradeable Loader 负责加载和管理 BPF 智能合约</li>
<li>Sysvar: Clock 是系统时钟账户，获取时间戳</li>
<li>Sysvar: Rent 是租金计算账户（用于确定账户是否需要支付租金）</li>
</ol>
<p>下面是<strong>指令字段</strong>：</p>
<p><strong>📌 指令 1：创建程序账户</strong></p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"info"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"lamports"</span><span class="punctuation">:</span> <span class="number">1398960</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"newAccount"</span><span class="punctuation">:</span> <span class="string">"Nyy8sfuyeXq15QHiwaM1eKcVLnQ95EDdXdZ6XujeiHV"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"owner"</span><span class="punctuation">:</span> <span class="string">"BPFLoaderUpgradeab1e11111111111111111111111"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"source"</span><span class="punctuation">:</span> <span class="string">"4T3phH9RxrwXJGftJfGk2G8iC6JXCvRyZF2vjMycJera"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"space"</span><span class="punctuation">:</span> <span class="number">36</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"createAccount"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>指令类型：系统程序 createAccount</li>
<li>创建 Nyy8 作为 程序账户（Program Account）。</li>
<li>账户所有者设为 BPF Upgradeable Loader，表示它是一个可升级合约。</li>
<li>我的4T3p调用的</li>
<li>分配 36 字节的空间，这只是程序账户的元数据，实际代码会存储在 Program Data Account。</li>
</ul>
<p><strong>📌 指令 2：使用 BPF Upgradeable Loader 部署程序</strong></p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"info"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"authority"</span><span class="punctuation">:</span> <span class="string">"4T3phH9RxrwXJGftJfGk2G8iC6JXCvRyZF2vjMycJera"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"bufferAccount"</span><span class="punctuation">:</span> <span class="string">"Qfu4TnxzsWD52zkLpHrNMKe81K5sEAvHTQE3h2xCtYq"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"clockSysvar"</span><span class="punctuation">:</span> <span class="string">"SysvarC1ock11111111111111111111111111111111"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"maxDataLen"</span><span class="punctuation">:</span> <span class="number">365136</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"payerAccount"</span><span class="punctuation">:</span> <span class="string">"4T3phH9RxrwXJGftJfGk2G8iC6JXCvRyZF2vjMycJera"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"programAccount"</span><span class="punctuation">:</span> <span class="string">"Nyy8sfuyeXq15QHiwaM1eKcVLnQ95EDdXdZ6XujeiHV"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"programDataAccount"</span><span class="punctuation">:</span> <span class="string">"FHnSpFSK8tuy51NKK37yEEAECb2ujmav88JCGcKRuksg"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"rentSysvar"</span><span class="punctuation">:</span> <span class="string">"SysvarRent111111111111111111111111111111111"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"systemProgram"</span><span class="punctuation">:</span> <span class="string">"11111111111111111111111111111111"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"deployWithMaxDataLen"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>从缓冲区账户 (Qfu4) 读取 BPF 代码。</li>
<li>创建 FHnS 作为可执行数据账户，用于存放 BPF 代码。</li>
<li>将 BPF 代码写入 Program Data Account，然后把 Program Account 设置为 executable = true，让它变成可执行合约。</li>
<li>Authority 由 4T3p 设定，表示该账户有权限升级合约。</li>
</ul>
<p><strong>📌 指令 2.1（内部指令）：创建 Program Data Account</strong></p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"info"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"lamports"</span><span class="punctuation">:</span> <span class="number">2542550640</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"newAccount"</span><span class="punctuation">:</span> <span class="string">"FHnSpFSK8tuy51NKK37yEEAECb2ujmav88JCGcKRuksg"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"owner"</span><span class="punctuation">:</span> <span class="string">"BPFLoaderUpgradeab1e11111111111111111111111"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"source"</span><span class="punctuation">:</span> <span class="string">"4T3phH9RxrwXJGftJfGk2G8iC6JXCvRyZF2vjMycJera"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"space"</span><span class="punctuation">:</span> <span class="number">365181</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"createAccount"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>指令类型：系统程序 createAccount</li>
<li><strong>创建 Program Data Account（FHnS）</strong>，存放合约的 BPF 代码。</li>
<li><strong>转移 2.54 SOL 以支付存储租金</strong>，因为 Solana 账户必须存足够的 SOL 以维持存活。</li>
<li>分配 365181 字节的空间。</li>
</ul>
<h3 id="4-3-ETH开发者FAQ">4.3 ETH开发者FAQ</h3>
<p>❓我们首先疑惑，<strong>为什么需要 365KB 这么大</strong>来存储极端简单的 hello world 程序。如果是类似EVM的字节码不可能这么大。</p>
<ol>
<li>Solana BPF 程序的存储对齐。Solana 要求程序代码存储在 1KB 对齐的存储块中，所以即使你的代码实际只有 150KB，最终可能会被填充到 365KB。这类似于 操作系统的页面对齐，有助于 高效的内存访问和程序加载。</li>
<li>Rust 编译的 BPF 代码体积较大。由于 Rust 的安全性和泛型特性，编译出来的 BPF 代码往往比手写汇编代码要大。</li>
<li>BPF 代码还存在代码段等信息。代码段（.text）：存储指令（占用最大）。数据段（.data）：存储常量数据、全局变量。只读数据段（.rodata）：存储只读字符串和常量。符号表（.symtab）：用于调试和符号解析。</li>
</ol>
<p>❓<strong>为什么 Solana 交易会有子指令（Inner Instructions）？</strong></p>
<p>子指令（Inner Instructions）是 Solana 某些程序在执行过程中调用其他程序或系统指令时产生的内部指令。在 Solana 交易执行时：</p>
<ul>
<li>外部指令（Top-level Instructions） 由用户提交的交易指定。</li>
<li>子指令（Inner Instructions） 是智能合约或 Solana 内部机制在执行外部指令时，调用其他指令 产生的。</li>
</ul>
<p>在部署智能合约的交易中：用户调用 deployWithMaxDataLen 来部署 BPF 程序（外部指令）。这个过程内部需要 创建 Program Data Account，因此 BPF Upgradeable Loader 触发了 createAccount 子指令。 BPF Upgradeable Loader（合约管理程序） 调用了 System Program（系统程序）。</p>
<p>❓<strong>BPF 代码是什么？</strong></p>
<p>BPF 是一种低级的字节码格式，最初用于<strong>操作系统内核中的网络数据包过滤</strong>（比如 tcpdump、eBPF）。Solana 采用<strong>BPF 作为智能合约执行格式</strong>，但进行了优化，以支持高效的并行执行。</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>Solana BPF</strong></th>
<th><strong>以太坊 EVM</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>执行方式</strong></td>
<td>预编译的 BPF 字节码</td>
<td>逐条解释执行 EVM 字节码</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高效（基于 eBPF JIT 编译）</td>
<td>慢（逐条解释执行）</td>
</tr>
<tr>
<td><strong>并行执行</strong></td>
<td><strong>支持</strong>（Sealevel）</td>
<td><strong>不支持</strong>（单线程）</td>
</tr>
<tr>
<td><strong>计算模型</strong></td>
<td>账户模型，基于租金（Rent）</td>
<td>账户模型，基于 Gas</td>
</tr>
<tr>
<td><strong>编译语言</strong></td>
<td>Rust, C, C++</td>
<td>Solidity, Vyper</td>
</tr>
<tr>
<td><strong>程序存储</strong></td>
<td>Program Data Account（不可变）</td>
<td>智能合约账户</td>
</tr>
</tbody>
</table>
<p>❓<strong>Fee（交易费用）—— 为什么这笔交易消耗 0.00001 SOL？</strong></p>
<p>Solana 交易费用由以下两部分组成：</p>
<ul>
<li><strong>基础交易费（Base Fee）</strong>：Solana 的每笔交易至少需要 0.00001 SOL（10,000 lamports）。这个基础费用是所有交易的最低成本，无论计算复杂度如何，都必须支付。</li>
<li><strong>计算单元消耗（Compute Units Consumed）</strong>：Solana 交易的执行成本是基于 Compute Units（计算单元）计算的，每个计算单元的消耗会影响交易费用，但<strong>只要在基本限额内，就不会额外收费（除非动态费用模型生效）</strong>。目前该交易消耗了 2,670 个计算单元，但仍然处于最低交易费用标准 0.00001 SOL 内，因此不会额外增加费用。</li>
</ul>
<blockquote>
<p><strong>优先级费用（Prioritization Fee）解释</strong>：<br>
在网络拥堵时，Solana允许用户支付额外的优先级费用来提高交易被处理的优先级。这类似于以太坊的gas price机制，用户可以在基础费用之上支付额外的费用来"插队"。计算公式为：<code>优先级费用 = 每计算单元的价格 × 消耗的计算单元数量</code>。例如，如果你设置每计算单元价格为1 micro-lamport (0.000001 lamport)，消耗了100,000计算单元，那么优先级费用为0.1 lamport。</p>
</blockquote>
<p>❓<strong>Compute Units Consumed（计算单元消耗）—— 为什么消耗 2,670 计算单元？</strong></p>
<p>计算单元（CU，Compute Unit）是 Solana 交易的执行成本度量单位，类似于以太坊的 Gas。每个 Solana 交易都消耗一定数量的计算单元，用于执行智能合约、验证账户权限、读取数据等。计算单元决定了交易的执行复杂度，计算越复杂，消耗的 CU 越多。</p>
<p>默认每个交易最多可以使用 200,000 CU。如果一个交易消耗过多计算单元，它可能会因为超出限制而失败。Solana 提供 prioritization fee 机制，高价值交易可以支付更高费用，提高计算单元上限。</p>
<p>❓<strong>为什么提示 Transaction Version（交易版本）？</strong></p>
<p>Solana 交易格式随着协议升级而不断演进，目前有 两种主要交易版本：</p>
<ul>
<li>Legacy（传统版本）。旧版本交易格式，兼容早期 Solana 交易规则。交易结构较简单，但缺少部分新功能（如可变费用）。</li>
<li>V0（版本 0，现代化交易格式）。支持 Address Lookup Table（地址查找表），减少交易体积，提升效率。支持更复杂的动态费用结构，适用于高价值交易。</li>
</ul>
<p>V0 版本的主要优势是"地址查找表"（减少交易大小），但合约部署涉及的账户较少，legacy 版本足够。如果你希望使用 V0 交易，可以在提交交易时，指定 --with-address-lookup-table 或者直接使用支持 V0 交易的 RPC 客户端。</p>
<h3 id="4-4-调用合约">4.4 调用合约</h3>
<p>直接使用 playground里提供的ts代码调用。</p>
<img src="https://cdn.blog-blockchain.xyz/2025/05/18eb974aa7e158663b73098f634f470a.png" alt="image-20250518223629813" style="zoom:33%;">
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://solscan.io/tx/5wYU6EX9sbfQT9GBPz7kyeQXpsfjuP9UhFRvcECv1hPHapHVaoTsPACmendiV3TgQEiNyacvRxzDiviJompZqcQ7?cluster=devnet">https://solscan.io/tx/5wYU6EX9sbfQT9GBPz7kyeQXpsfjuP9UhFRvcECv1hPHapHVaoTsPACmendiV3TgQEiNyacvRxzDiviJompZqcQ7?cluster=devnet</a></p>
<p>由于没有验证合约，所以参数没有解码，从执行结果上知道，我们的日志成功打印了。</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ solana confirm -v 5wYU6EX9sbfQT9GBPz7kyeQXpsfjuP9UhFRvcECv1hPHapHVaoTsPACmendiV3TgQEiNyacvRxzDiviJompZqcQ7</span><br><span class="line">RPC URL: &lt;https://api.devnet.solana.com&gt;</span><br><span class="line">Default Signer: Playground Wallet</span><br><span class="line">Commitment: confirmed</span><br><span class="line"></span><br><span class="line">Transaction executed <span class="keyword">in</span> slot 358613949:</span><br><span class="line">  Block Time: 2025-02-04T02:43:29+08:00</span><br><span class="line">  Version: legacy</span><br><span class="line">  Recent Blockhash: 9sJABN5sM6chgkmpVKDxuHK4GYXqMmdx8mMwRQWxcc9t</span><br><span class="line">  Signature 0: 5wYU6EX9sbfQT9GBPz7kyeQXpsfjuP9UhFRvcECv1hPHapHVaoTsPACmendiV3TgQEiNyacvRxzDiviJompZqcQ7</span><br><span class="line">  Account 0: srw- 4T3phH9RxrwXJGftJfGk2G8iC6JXCvRyZF2vjMycJera (fee payer)</span><br><span class="line">  Account 1: -r-x Nyy8sfuyeXq15QHiwaM1eKcVLnQ95EDdXdZ6XujeiHV</span><br><span class="line">  Instruction 0</span><br><span class="line">    Program:   Nyy8sfuyeXq15QHiwaM1eKcVLnQ95EDdXdZ6XujeiHV (1)</span><br><span class="line">    Data: [149, 118, 59, 220, 196, 127, 161, 179]</span><br><span class="line">  Status: Ok</span><br><span class="line">    Fee: ◎0.000005</span><br><span class="line">    Account 0 balance: ◎17.4550854 -&gt; ◎17.4550804</span><br><span class="line">    Account 1 balance: ◎0.00139896</span><br><span class="line">  Log Messages:</span><br><span class="line">    Program Nyy8sfuyeXq15QHiwaM1eKcVLnQ95EDdXdZ6XujeiHV invoke [1]</span><br><span class="line">    Program <span class="built_in">log</span>: Instruction: Hello</span><br><span class="line">    Program <span class="built_in">log</span>: Hello, World!</span><br><span class="line">    Program Nyy8sfuyeXq15QHiwaM1eKcVLnQ95EDdXdZ6XujeiHV consumed 443 of 200000 compute units</span><br><span class="line">    Program Nyy8sfuyeXq15QHiwaM1eKcVLnQ95EDdXdZ6XujeiHV success</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-5-IDL">4.5 IDL</h3>
<p>在<strong>以太坊（EVM）<strong>中，智能合约使用</strong>ABI（Application Binary Interface）<strong>规定消息的调用格式，例如</strong>函数选择器（Function Selector）<strong>和</strong>参数编码规则（ABI Encoding）</strong>。</p>
<p>那么，Solana<strong>如何规定智能合约的调用格式</strong>？Solana<strong>没有 ABI</strong>，而是使用了一种<strong>更灵活的方式</strong>来处理合约的调用数据。</p>
<ul>
<li>在<strong>原生 Solana SDK</strong>（不使用 Anchor）中，调用合约的指令格式是完全<strong>手动定义</strong>的。</li>
<li>在<strong>Anchor 框架</strong>中，使用 <strong>IDL（Interface Description Language，接口描述语言）</strong> 来定义和标准化智能合约的调用格式。</li>
</ul>
<p>IDL（接口描述语言）是<strong>Anchor 框架</strong>用来<strong>描述智能合约 API</strong>的标准格式。它类似于<strong>以太坊的 ABI</strong>，但更强大：</p>
<ul>
<li>IDL 让 Solana 智能合约具备结构化的 API，便于解析和调用。</li>
<li>IDL 主要用于 Anchor 框架，但也可用于其他框架来生成合约调用代码。</li>
<li>IDL 采用 JSON 格式，详细描述了合约的函数、账户结构和返回数据格式。</li>
</ul>
<p>IDL 包含以下主要部分：</p>
<ol>
<li>name：合约的名称</li>
<li>instructions：定义了智能合约支持的所有函数（方法）</li>
<li>accounts：定义了智能合约需要访问的账户结构</li>
<li>types：定义复杂数据结构（类似 Solidity 的 struct）</li>
<li>events：定义事件（类似 Solidity 的 event）</li>
<li>errors：定义错误类型</li>
</ol>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"0.1.0"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"hello_world"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"instructions"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"sendMessage"</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"accounts"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"user"</span><span class="punctuation">,</span> <span class="attr">"isMut"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">"isSigner"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"messageAccount"</span><span class="punctuation">,</span> <span class="attr">"isMut"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">"isSigner"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span> <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"args"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"message"</span><span class="punctuation">,</span> <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"string"</span> <span class="punctuation">}</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"accounts"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"MessageAccount"</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"type"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"kind"</span><span class="punctuation">:</span> <span class="string">"struct"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"fields"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"message"</span><span class="punctuation">,</span> <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"string"</span> <span class="punctuation">}</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>这个 IDL 代表的功能</strong></p>
<ul>
<li><strong>合约名称：</strong> hello_world</li>
<li><strong>方法 sendMessage</strong></li>
<li>需要两个账户：
<ul>
<li>user：用户账户（需要签名）</li>
<li>messageAccount：存储消息的账户</li>
</ul>
</li>
<li>需要 <strong>一个参数</strong>：message（字符串类型）</li>
<li><strong>accounts</strong>：定义了 MessageAccount 结构体，用于存储消息。</li>
</ul>
<p>Anchor 提供了 <strong>TypeScript SDK</strong>，可以用 IDL 自动生成智能合约调用代码：</p>
<figure class="highlight tsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { <span class="title class_">Program</span>, <span class="title class_">AnchorProvider</span>, web3 } <span class="keyword">from</span> <span class="string">"@project-serum/anchor"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 IDL</span></span><br><span class="line"><span class="keyword">import</span> idl <span class="keyword">from</span> <span class="string">"./hello_world.json"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接 Solana 钱包</span></span><br><span class="line"><span class="keyword">const</span> provider = <span class="title class_">AnchorProvider</span>.<span class="title function_">env</span>();</span><br><span class="line"><span class="keyword">const</span> programId = <span class="keyword">new</span> web3.<span class="title class_">PublicKey</span>(idl.<span class="property">metadata</span>.<span class="property">address</span>);</span><br><span class="line"><span class="keyword">const</span> program = <span class="keyword">new</span> <span class="title class_">Program</span>(idl, programId, provider);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用合约方法</span></span><br><span class="line"><span class="keyword">await</span> program.<span class="property">rpc</span>.<span class="title function_">sendMessage</span>(<span class="string">"Hello, Solana!"</span>, {</span><br><span class="line">  <span class="attr">accounts</span>: {</span><br><span class="line">    <span class="attr">user</span>: provider.<span class="property">wallet</span>.<span class="property">publicKey</span>,</span><br><span class="line">    <span class="attr">messageAccount</span>: messageAccountPubkey,</span><br><span class="line">  },</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<p>在build那一块，还有一个 <strong>IDL initialize。</strong> 在 Anchor 框架中，<strong>每个智能合约都可以新创建一个数据账户，存储它的 IDL</strong>，这样客户端（如前端应用）可以自动查询合约的调用方法，而不需要提前知道函数签名。下面的交易就把 IDL 写入了程序可执行数据，同时也是初始化合约：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://solscan.io/tx/56iyiL1K5LJ6ieToWsEaPZABTWoJ1jhf3GTdPvDZ3VQ8CQ1QTd5gJ4SU8EurhuGzm9nmZkthNXoLjmDe8rVtKDr?cluster=devnet">https://solscan.io/tx/56iyiL1K5LJ6ieToWsEaPZABTWoJ1jhf3GTdPvDZ3VQ8CQ1QTd5gJ4SU8EurhuGzm9nmZkthNXoLjmDe8rVtKDr?cluster=devnet</a></p>
<img src="https://cdn.blog-blockchain.xyz/2025/05/7f276736af4538af2134e935c4736503.png" alt="image-20250518223856453">
<figure class="highlight tsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ anchor idl fetch <span class="title class_">Nyy8</span>sfuyeXq15QHiwaM1eKcVLnQ95EDdXdZ6XujeiHV</span><br><span class="line">{</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"hello_world"</span>,</span><br><span class="line">  <span class="string">"instructions"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"hello"</span>,</span><br><span class="line">      <span class="string">"accounts"</span>: [],</span><br><span class="line">      <span class="string">"args"</span>: []</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这就是IDL存储的账户 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://solscan.io/account/5FM1QHSWeVZVx3v37CezJcXv4VJstN1F7jmGoLwbt7Ck?cluster=devnet">https://solscan.io/account/5FM1QHSWeVZVx3v37CezJcXv4VJstN1F7jmGoLwbt7Ck?cluster=devnet</a> ，</p>
<figure class="highlight tsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ solana account 5FM1QHSWeVZVx3v37CezJcXv4VJstN1F7jmGoLwbt7Ck --output json</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">  <span class="string">"pubkey"</span>: <span class="string">"5FM1QHSWeVZVx3v37CezJcXv4VJstN1F7jmGoLwbt7Ck"</span>,</span><br><span class="line">  <span class="string">"account"</span>: {</span><br><span class="line">    <span class="string">"lamports"</span>: <span class="number">2394240</span>,</span><br><span class="line">    <span class="string">"data"</span>: [</span><br><span class="line">      <span class="string">"GEZivzqQe54zP1pfirECcDdGqmQMSSKrf+6UjiGboWnSBMxnCs/vR1YAAAB4nFWKQQqAIBBF7zLrENt6lZAQkxJsBsaxFuLdm9q1+++/1+FKXDMhOLBmNhYmwHAmxSOVQutNXDY9M1bhFkXTCm7pv0p9iJEayuu8Eu/fGn48MYwgrwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span>,</span><br><span class="line">      <span class="string">"base64"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"owner"</span>: <span class="string">"Nyy8sfuyeXq15QHiwaM1eKcVLnQ95EDdXdZ6XujeiHV"</span>,</span><br><span class="line">    <span class="string">"executable"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"rentEpoch"</span>: <span class="number">18446744073709551615</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-6-PDA（Program-Derived-Address，程序派生地址）">4.6 PDA（Program Derived Address，程序派生地址）</h3>
<p>上面存储IDL就是使用了PDA，程序控制这个地址。它由特定的种子（seeds）和程序ID（Program ID）通过确定性算法计算出来。PDA 允许程序生成可预测但安全的地址，用于存储状态数据，而无需用户手动创建账户或提供签名。</p>
<ul>
<li>PDA 是由种子（seeds）+ Program ID 确定性派生出的唯一地址。</li>
<li>PDA 不是普通公私钥对生成的，它没有对应的私钥，只能由特定的 Solana 程序（Program）管理。</li>
<li>PDA 账户只能由程序自身（Program）签名，而不能由外部私钥签名，这确保了只有合约代码能够修改 PDA。</li>
</ul>
<p>这里有2个参数：</p>
<ul>
<li><strong>种子（Seeds）</strong>：可以是静态值（如 “hello_world”）或动态值（如用户的公钥）。</li>
<li><strong>bump（防撞值）</strong>：一个自动计算的<strong>额外字节</strong>，确保生成的地址不落在 Ed25519 曲线上，以防止被外部签名。</li>
</ul>
<blockquote>
<p><strong>bump值详解</strong>：<br>
bump值是一个0-255之间的数字，用于确保生成的PDA不在Ed25519椭圆曲线上（即没有对应的私钥）。为什么需要这个bump值？因为如果PDA落在了曲线上，理论上有人可以找到其私钥并直接签名，这会破坏PDA的安全模型。</p>
<p>Solana在生成PDA时，从255开始递减bump值，直到找到一个不在曲线上的地址。在实践中，findProgramAddress函数会自动执行这个过程并返回找到的第一个有效bump值（通常称为"canonical bump"）。</p>
<p>当程序需要验证PDA时，它会重新计算地址（使用相同的种子和bump值），确保请求来自合法的程序。这整个机制使得PDA可以"代表"程序进行签名操作，而无需实际私钥。</p>
</blockquote>
<p>在 Solana 上，智能合约不能直接修改用户的账户数据，而是使用 <strong>PDA（Program Derived Address）</strong> 作为合约的状态存储。例如：</p>
<ul>
<li><strong>在 SPL Token 程序中，每个用户的 amount 存在 PDA 账户</strong>。</li>
<li><strong>在 NFT 合约中，元数据（Metadata）存储在 PDA 账户</strong>。</li>
<li><strong>在 DeFi 应用中，用户的流动性仓位信息存储在 PDA</strong>。</li>
</ul>
<blockquote>
<p><strong>PDA的实际应用场景</strong>：</p>
<ol>
<li><strong>确定性地址生成</strong>：为每个用户生成唯一且可预测的账户地址</li>
<li><strong>跨程序权限</strong>：允许一个程序代表另一个程序签名和操作账户</li>
<li><strong>数据关联</strong>：将相关数据组织在一起，例如用户A在项目B中的仓位数据</li>
<li><strong>省去交易签名</strong>：用户只需授权程序一次，后续操作可由程序通过PDA完成</li>
</ol>
</blockquote>
<h3 id="4-7-CPI-跨程序调用">4.7 CPI 跨程序调用</h3>
<blockquote>
<p><strong>CPI解决的核心问题</strong>：CPI允许程序间合作，就像Web2中的API调用。这使得区块链上可以构建复杂的应用生态系统，一个程序可以利用另一个程序已经实现的功能。</p>
</blockquote>
<p>在 Solana 上，每个智能合约（Program）都是<strong>独立的 BPF 程序</strong>，默认情况下，程序<strong>只能操作它自己拥有的账户</strong>，不能直接修改<strong>其他程序管理的账户</strong>。但 Solana 允许一个<strong>智能合约调用另一个智能合约的指令</strong>，这就是 <strong>CPI（跨程序调用）</strong>。</p>
<p>你的合约可以调用 <strong>系统程序（System Program）</strong> 的 transfer 指令进行 SOL 转账。你的合约可以调用 <strong>SPL Token Program</strong>，直接管理 SPL 代币账户（比如 mint、transfer）。你的合约可以与 <strong>其他 DeFi 合约</strong> 交互，实现组合式金融（Composability）。</p>
<blockquote>
<p><strong>CPI实际应用示例</strong>：</p>
<p><strong>DEX与流动性池</strong>：当你在Jupiter等DEX上交换代币时，底层涉及多个程序间的CPI调用：</p>
<ol>
<li>用户交易程序调用SPL Token程序转移用户代币</li>
<li>用户交易程序调用流动性池程序执行兑换</li>
<li>流动性池程序再次调用SPL Token程序发送交换后的代币</li>
</ol>
<p><strong>NFT铸造过程</strong>：</p>
<ol>
<li>NFT铸造程序调用System Program创建新的Metadata账户</li>
<li>NFT铸造程序调用Token-Metadata程序初始化NFT元数据</li>
<li>NFT铸造程序调用SPL Token程序铸造唯一代币</li>
</ol>
<p>这种程序间协作能力是Solana生态系统强大的核心原因之一。</p>
</blockquote>
<p>由于 CPI 允许<strong>一个合约调用另一个合约</strong>，这可能带来<strong>权限问题</strong>。Solana 采用 <strong>PDA（Program Derived Address）+ invoke_signed</strong> 作为签名方式，确保：</p>
<p>✅ 只有<strong>特定的合约可以执行某些操作</strong>。</p>
<p>✅ PDA 作为<strong>程序管理的账户</strong>，由特定合约控制。</p>
<h3 id="4-8-调用上下文">4.8 调用上下文</h3>
<blockquote>
<p><strong>Context的重要性</strong>：调用上下文是Solana程序安全性的基础。它明确规定了程序可以访问哪些账户、哪些账户需要签名以及哪些账户可以被修改。这种显式的账户访问控制是Solana能够实现并行处理的关键前提，也大大减少了智能合约漏洞的风险。</p>
</blockquote>
<p>我们提到Solana的程序分成3个部分，程序逻辑，链上数据结构，调用上下文。下面来学习这个上下文。</p>
<p>在 Solana 上，<strong>每个交易都会传递一个调用上下文（Context）</strong>，它包含：</p>
<ul>
<li>当前交易涉及的所有账户信息（AccountInfo）。</li>
<li>交易签名者信息（Signer）。</li>
<li>程序调用的依赖（如 System Program）。</li>
</ul>
<blockquote>
<p><strong>与以太坊的区别</strong>：在以太坊中，合约可以在执行过程中动态访问任何存储位置或调用任何合约，这限制了并行执行能力。而Solana要求预先声明所有需要访问的账户，这使运行时能够预先检测并发冲突，实现真正的并行处理。</p>
</blockquote>
<p><strong>1️⃣ Context<t> 结构解析</t></strong></p>
<p>以这个项目为例子：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://beta.solpg.io/66df2751cffcf4b13384d35a">https://beta.solpg.io/66df2751cffcf4b13384d35a</a></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sol_transfer</span>(ctx: Context&lt;SolTransfer&gt;, amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; {</span><br></pre></td></tr></tbody></table></figure>
<p>调用上下文是通过 Context<t> 传递的，Context<soltransfer>，包含当前指令需要的账户。</soltransfer></t></p>
<p><strong>2️⃣ Accounts 结构解析</strong></p>
<p>SolTransfer 结构定义了<strong>所有需要的账户信息</strong>。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SolTransfer</span>&lt;<span class="symbol">'info</span>&gt; {</span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    sender: Signer&lt;<span class="symbol">'info</span>&gt;, <span class="comment">// 交易发起者，必须是签名者</span></span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    recipient: SystemAccount&lt;<span class="symbol">'info</span>&gt;, <span class="comment">// 接收 SOL 的账户</span></span><br><span class="line">    system_program: Program&lt;<span class="symbol">'info</span>, System&gt;, <span class="comment">// 系统程序</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Signer 表示这个账户必须提供交易签名，否则交易会失败。mut（可变）意味着交易可能会修改 sender 的 SOL 余额。</li>
<li>SystemAccount 是普通 SOL 账户，只能存 SOL，不能存储其他数据。普通 SOL账户的管理者是 System Program。</li>
<li>Program&lt;'info, System&gt; 代表 System Program，用于调用系统指令（如 transfer）。这个账户的 owner 必须是 BPFLoader，否则交易会失败。</li>
</ul>
<p><strong>3️⃣ 通过 Context 获取账户信息</strong></p>
<p>在合约函数中，我们可以通过 ctx.accounts 访问传入的账户。 to_account_info() 的作用是转化成AccountInfo，Solana 底层账户对象，包含：key（公钥）、lamports（SOL 余额）、owner（账户所属的合约）、is_signer（是否是签名者）。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sol_transfer</span>(ctx: Context&lt;SolTransfer&gt;, amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">from_pubkey</span> = ctx.accounts.sender.<span class="title function_ invoke__">to_account_info</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">to_pubkey</span> = ctx.accounts.recipient.<span class="title function_ invoke__">to_account_info</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">program_id</span> = ctx.accounts.system_program.<span class="title function_ invoke__">to_account_info</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4️⃣ CpiContext::new 创建调用上下文</strong></p>
<p>CpiContext::new 用于构造 CPI（跨程序调用）所需的 <strong>调用上下文</strong>，它告诉 Solana：</p>
<ol>
<li><strong>我要调用哪个合约（Program ID）？</strong></li>
<li><strong>我要传递哪些账户？</strong></li>
<li><strong>我是否需要 PDA 作为签名者？（可选）</strong></li>
</ol>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">cpi_context</span> = CpiContext::<span class="title function_ invoke__">new</span>(</span><br><span class="line">    program_id, <span class="comment">// 要调用的合约（System Program）</span></span><br><span class="line">    Transfer { <span class="comment">//  System Program 的 SOL 转账指令</span></span><br><span class="line">        from: from_pubkey, <span class="comment">// 付款账户</span></span><br><span class="line">        to: to_pubkey, <span class="comment">// 接收账户</span></span><br><span class="line">    },</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>5️⃣执行指令</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行转账</span></span><br><span class="line"><span class="title function_ invoke__">transfer</span>(cpi_context, amount)?;</span><br></pre></td></tr></tbody></table></figure>
<p>回顾IDL知识：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"version"</span><span class="punctuation">:</span> <span class="string">"0.1.0"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"cpi"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"instructions"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"solTransfer"</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"accounts"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"sender"</span><span class="punctuation">,</span> <span class="attr">"isMut"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">"isSigner"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"recipient"</span><span class="punctuation">,</span> <span class="attr">"isMut"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">"isSigner"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span> <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"systemProgram"</span><span class="punctuation">,</span> <span class="attr">"isMut"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="attr">"isSigner"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span> <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"args"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">{</span> <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"amount"</span><span class="punctuation">,</span> <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"u64"</span> <span class="punctuation">}</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://solscan.io/tx/3vzVz8EHT5DQYgzbJmW8GbjZCST8LbadsVD37fzCFNKKiDEWXdnokqbtn7DVdN86AdKCgdesDBa9FPX6WvAfgiwi?cluster=devnet">https://solscan.io/tx/3vzVz8EHT5DQYgzbJmW8GbjZCST8LbadsVD37fzCFNKKiDEWXdnokqbtn7DVdN86AdKCgdesDBa9FPX6WvAfgiwi?cluster=devnet</a> 调用后就成功转账了。</p>
<p>除了上面的创建上下文的调用方式，可以直接组装指令的形式，然后调用，比如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sol_transfer_two</span>(ctx: Context&lt;SolTransfer&gt;, amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">from_pubkey</span> = ctx.accounts.sender.<span class="title function_ invoke__">to_account_info</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">to_pubkey</span> = ctx.accounts.recipient.<span class="title function_ invoke__">to_account_info</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">program_id</span> = ctx.accounts.system_program.<span class="title function_ invoke__">to_account_info</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">instruction</span> =</span><br><span class="line">        &amp;system_instruction::<span class="title function_ invoke__">transfer</span>(&amp;from_pubkey.<span class="title function_ invoke__">key</span>(), &amp;to_pubkey.<span class="title function_ invoke__">key</span>(), amount);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">invoke</span>(instruction, &amp;[from_pubkey, to_pubkey, program_id])?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面是利用已知的指令结构，填入对应字段组装的。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sol_transfer_three</span>(ctx: Context&lt;SolTransfer&gt;, amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">from_pubkey</span> = ctx.accounts.sender.<span class="title function_ invoke__">to_account_info</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">to_pubkey</span> = ctx.accounts.recipient.<span class="title function_ invoke__">to_account_info</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">program_id</span> = ctx.accounts.system_program.<span class="title function_ invoke__">to_account_info</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare instruction AccountMetas</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">account_metas</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new</span>(from_pubkey.<span class="title function_ invoke__">key</span>(), <span class="literal">true</span>),</span><br><span class="line">        AccountMeta::<span class="title function_ invoke__">new</span>(to_pubkey.<span class="title function_ invoke__">key</span>(), <span class="literal">false</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SOL transfer instruction discriminator</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">instruction_discriminator</span>: <span class="type">u32</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare instruction data</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">instruction_data</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">4</span> + <span class="number">8</span>);</span><br><span class="line">    instruction_data.<span class="title function_ invoke__">extend_from_slice</span>(&amp;instruction_discriminator.<span class="title function_ invoke__">to_le_bytes</span>());</span><br><span class="line">    instruction_data.<span class="title function_ invoke__">extend_from_slice</span>(&amp;amount.<span class="title function_ invoke__">to_le_bytes</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create instruction</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">instruction</span> = Instruction {</span><br><span class="line">        program_id: program_id.<span class="title function_ invoke__">key</span>(),</span><br><span class="line">        accounts: account_metas,</span><br><span class="line">        data: instruction_data,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke instruction</span></span><br><span class="line">    <span class="title function_ invoke__">invoke</span>(&amp;instruction, &amp;[from_pubkey, to_pubkey, program_id])?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面则是直接手动填充指令字节。但是注意，不能用完整的 AccountInfo了，而是要用 AccountMeta。</p>
<p>指令的结构是：[方法 ID (4字节)] + [方法参数 (Borsh 编码)]。在Anchor中，指令的标识是用指令的位置索引。</p>
<h3 id="4-9-invoke-signed">4.9 invoke_signed</h3>
<p>上面的例子，我们是要求 from_pubkey 是可签名的，也就是EOA。但是如果是程序控制的PDA，是没有自己的私钥的，也就是无法作为signer。那么需要另外的机制来实现。invoke_signed 允许 PDA<strong>在没有私钥的情况下</strong>作为<strong>签名者</strong>，执行合约调用。具体来说让<strong>Solana 根据 PDA 账户的 seeds 和 bump 验证身份</strong>。</p>
<p>代码例子参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://beta.solpg.io/66df2bd2cffcf4b13384d35b">https://beta.solpg.io/66df2bd2cffcf4b13384d35b</a></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#[account(</span></span><br><span class="line"><span class="meta">    mut,</span></span><br><span class="line"><span class="meta">    seeds = [b<span class="string">"pda"</span>, recipient.key().as_ref()]</span>,</span><br><span class="line">    bump,</span><br><span class="line">)]</span><br><span class="line">pda_account: SystemAccount&lt;<span class="symbol">'info</span>&gt;,</span><br></pre></td></tr></tbody></table></figure>
<p>相比一般的账户，添加了seeds， <code>pda</code> 作为计算基础，recipient 账户的公钥作为动态种子。bump：自动计算的值，保证 PDA 地址是有效的 Solana 账户地址。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">seed</span> = to_pubkey.<span class="title function_ invoke__">key</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">bump_seed</span> = ctx.bumps.pda_account;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">signer_seeds</span>: &amp;[&amp;[&amp;[<span class="type">u8</span>]]] = &amp;[&amp;[<span class="string">b"pda"</span>, seed.<span class="title function_ invoke__">as_ref</span>(), &amp;[bump_seed]]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">cpi_context</span> = CpiContext::<span class="title function_ invoke__">new</span>(</span><br><span class="line">    program_id,</span><br><span class="line">    Transfer {</span><br><span class="line">        from: from_pubkey,</span><br><span class="line">        to: to_pubkey,</span><br><span class="line">    },</span><br><span class="line">)</span><br><span class="line">.<span class="title function_ invoke__">with_signer</span>(signer_seeds);</span><br></pre></td></tr></tbody></table></figure>
<p>程序解析的时候，计算这个signer_seeds。如果程序和声明的 seeds 和 bump 不匹配，就会生成错误的PDA，交易失败。</p>
<p>根据测试用例，我们首先计算的PDA，依赖钱包地址生成的。</p>
<p>交易：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://solscan.io/tx/5PL2Q4ALWKNSgz3htANjexPyZm43tfnT8XsTGgBwdV5EjKBXb4TKimUGz4JKhgZUMTXJhtK6Mg5KtNQd9pQyXLh4?cluster=devnet">https://solscan.io/tx/5PL2Q4ALWKNSgz3htANjexPyZm43tfnT8XsTGgBwdV5EjKBXb4TKimUGz4JKhgZUMTXJhtK6Mg5KtNQd9pQyXLh4?cluster=devnet</a></p>
<p>PDA: <a target="_blank" rel="noopener external nofollow noreferrer" href="https://solscan.io/account/AMtiaEmz3NhhV3KFbTkSXYP1AraCLdR9n4AiB3zHNTw?cluster=devnet">https://solscan.io/account/AMtiaEmz3NhhV3KFbTkSXYP1AraCLdR9n4AiB3zHNTw?cluster=devnet</a></p>
<p><img src="https://cdn.blog-blockchain.xyz/2025/05/7f276736af4538af2134e935c4736503.png" alt="image-20250518231045670"></p>
<p>可以发现PDA这里 <code>isOnCurve</code> 是 False，说明没有私钥控制。</p>
<p>❓为什么转给PDA时，我并没有看到创建PDA数据账户的指令？</p>
<p>我们提到系统程序控制PDA的生成，但是我们没看到createAccount指令。这是因为PDA 在 Solana 里默认是"懒创建（Lazy Initialization）"的！</p>
<p>在 Solana，账户的创建方式有两种：</p>
<ol>
<li>System Program::CreateAccount 用于创建新的可写账户，必须初始化 lamports 和 space。</li>
<li>直接向账户转账 SOL 只要账户不存在，Solana 允许它作为"空账户"存储 lamports 但不存储数据。</li>
</ol>
<p><strong>如果 PDA 账户没有存储数据（空账户），它可以直接接受 SOL，而不需要 createAccount！</strong></p>
<p>❓为什么我的地址能控制PDA？</p>
<p>因为计算PDA时使用了我的地址和程序ID共同生成地址，程序验证的时候使用的是 <code>to_pubkey.key()</code>，那么这个PDA只能给我转账。也就是说，任何人可以转给PDA，但是这个PDA里的金额，只能由我转出。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [PDA] = PublicKey.<span class="title function_ invoke__">findProgramAddressSync</span>(</span><br><span class="line">  [Buffer.<span class="title function_ invoke__">from</span>(<span class="string">"pda"</span>), wallet.publicKey.<span class="title function_ invoke__">toBuffer</span>()],</span><br><span class="line">  program.programId</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>❓那其他程序能控制这个地址吗？如果其他程序也能生成同样的PDA，是不是也可以控制了呢？</p>
<p>不能。可以简化PDA的计算公式 <code>PDA = hash(seeds + Program ID) + bump</code> ，这个哈希碰撞是几乎不可能发生的。</p>
<p>如果用invoke的方式调用，则是先创建指令，相比invoke多出了一个PDA签名。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">instruction</span> =</span><br><span class="line">    &amp;system_instruction::<span class="title function_ invoke__">transfer</span>(&amp;from_pubkey.<span class="title function_ invoke__">key</span>(), &amp;to_pubkey.<span class="title function_ invoke__">key</span>(), amount);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">invoke_signed</span>(instruction, &amp;[from_pubkey, to_pubkey, program_id], signer_seeds)?;</span><br></pre></td></tr></tbody></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz">Michael L</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz/solana/solana-basic/">https://www.blog-blockchain.xyz/solana/solana-basic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/solana/">solana</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.blog-blockchain.xyz/2025/05/a8ff2c0938675dd107393164903785c8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/solana/solana-flashloan-1/" title="Solana flashloan 原理和设计"><img class="cover" src="https://cdn.blog-blockchain.xyz/2025/05/a8ff2c0938675dd107393164903785c8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Solana flashloan 原理和设计</div></div><div class="info-2"><div class="info-item-1">深入探讨Solana区块链上闪电贷的设计原理与实现方法。分析Solana独特的账户模型和交易结构如何支持无抵押借贷，详细阐述基于Sysvar指令的还款验证机制，并与以太坊实现进行对比。涵盖套利、清算、债务重组等应用场景，为开发者提供构建高效安全闪电贷应用的完整技术方案。</div></div></div></a><a class="pagination-related" href="/career/ai-chat-philosophy/" title="一个初代AI聊天机器人的故事。人性的弱点碰上了人工智能的哲学。"><img class="cover" src="https://cdn.blog-blockchain.xyz/2025/06/b4a3b8645810b021a67ae726b9734632.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">一个初代AI聊天机器人的故事。人性的弱点碰上了人工智能的哲学。</div></div><div class="info-2"><div class="info-item-1">我们不是被AI征服的，我们是主动投降的。认知的投降：思考的外包，情感的投降：孤独的逃避，道德的投降：责任的消失。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/solana/solana-flashloan-1/" title="Solana flashloan 原理和设计"><img class="cover" src="https://cdn.blog-blockchain.xyz/2025/05/a8ff2c0938675dd107393164903785c8.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-17</div><div class="info-item-2">Solana flashloan 原理和设计</div></div><div class="info-2"><div class="info-item-1">深入探讨Solana区块链上闪电贷的设计原理与实现方法。分析Solana独特的账户模型和交易结构如何支持无抵押借贷，详细阐述基于Sysvar指令的还款验证机制，并与以太坊实现进行对比。涵盖套利、清算、债务重组等应用场景，为开发者提供构建高效安全闪电贷应用的完整技术方案。</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">Michael L</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">102</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/learnerLj"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:luoshitou9@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">从技术到商业，从产品到设计，从生活到未来，我会在这里分享我的所思所想，欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Solana-%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. Solana 账户模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Native-Programs"><span class="toc-text">1.1 Native Programs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%EF%BC%88System-Program%EF%BC%89"><span class="toc-text">1.2 系统程序（System Program）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%EF%BC%88Programs%EF%BC%89"><span class="toc-text">1.3 智能合约（Programs）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%95%B0%E6%8D%AE%E8%B4%A6%E6%88%B7%EF%BC%88Data-Accounts%EF%BC%89"><span class="toc-text">1.4 数据账户（Data Accounts）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BA%A4%E6%98%93%E5%92%8C%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">2. 交易和指令的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BA%A4%E6%98%93%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-text">2.1 交易的版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BA%A4%E6%98%93%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">2.2 交易的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-RPC%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-text">2.3 RPC返回结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%A4%E6%98%93%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">3. 交易的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%87"><span class="toc-text">3.1 准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8F%91%E9%80%81%E4%BA%A4%E6%98%93"><span class="toc-text">3.2 发送交易</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6%EF%BC%88%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-text">3.3 调用合约（智能合约执行）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%A1%AE%E8%AE%A4"><span class="toc-text">3.3 返回结果与确认</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%93%BE%E4%B8%8A%E7%A8%8B%E5%BA%8F"><span class="toc-text">4 链上程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">4.1 基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%A7%A3%E8%AF%BB%E6%8C%87%E4%BB%A4"><span class="toc-text">4.2 解读指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-ETH%E5%BC%80%E5%8F%91%E8%80%85FAQ"><span class="toc-text">4.3 ETH开发者FAQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6"><span class="toc-text">4.4 调用合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-IDL"><span class="toc-text">4.5 IDL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-PDA%EF%BC%88Program-Derived-Address%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%B4%BE%E7%94%9F%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="toc-text">4.6 PDA（Program Derived Address，程序派生地址）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-CPI-%E8%B7%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8"><span class="toc-text">4.7 CPI 跨程序调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E8%B0%83%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">4.8 调用上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-invoke-signed"><span class="toc-text">4.9 invoke_signed</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/dev/immortalwrt-ax6000-upgrade/" title="Xiaomi Redmi Router AX6000 ImmortalWrt 升级记录"><img src="https://cdn.blog-blockchain.xyz/2026/02/30b64e37b39e0b482a817643d8100e5d.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Xiaomi Redmi Router AX6000 ImmortalWrt 升级记录"></a><div class="content"><a class="title" href="/dev/immortalwrt-ax6000-upgrade/" title="Xiaomi Redmi Router AX6000 ImmortalWrt 升级记录">Xiaomi Redmi Router AX6000 ImmortalWrt 升级记录</a><time datetime="2026-02-19T13:43:00.000Z" title="Created 2026-02-19 21:43:00">2026-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/defi/permit-ecdsa-cryptography/" title="ERC-20 Permit 与 ECDSA 密码学原理"><img src="https://cdn.blog-blockchain.xyz/2026/01/7926570b23eeb56169050989a441e0a6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ERC-20 Permit 与 ECDSA 密码学原理"></a><div class="content"><a class="title" href="/defi/permit-ecdsa-cryptography/" title="ERC-20 Permit 与 ECDSA 密码学原理">ERC-20 Permit 与 ECDSA 密码学原理</a><time datetime="2026-01-09T02:00:00.000Z" title="Created 2026-01-09 10:00:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/career/structural-thoughts-after-one-and-half-years-at-work/" title="职业增长的数学模型：从log(x)到eˣ的跃迁代价"><img src="https://cdn.blog-blockchain.xyz/2026/02/57338184b4fb276c89fe5e77277a4f37.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="职业增长的数学模型：从log(x)到eˣ的跃迁代价"></a><div class="content"><a class="title" href="/career/structural-thoughts-after-one-and-half-years-at-work/" title="职业增长的数学模型：从log(x)到eˣ的跃迁代价">职业增长的数学模型：从log(x)到eˣ的跃迁代价</a><time datetime="2025-12-13T16:00:00.000Z" title="Created 2025-12-14 00:00:00">2025-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/career/find-gold-then-build-factory/" title="困境：从「想明白」到「做出来」的鸿沟"><img src="https://cdn.blog-blockchain.xyz/2026/02/131dd24e0445c2bc1422ed04d661be85.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="困境：从「想明白」到「做出来」的鸿沟"></a><div class="content"><a class="title" href="/career/find-gold-then-build-factory/" title="困境：从「想明白」到「做出来」的鸿沟">困境：从「想明白」到「做出来」的鸿沟</a><time datetime="2025-10-27T17:11:20.000Z" title="Created 2025-10-28 01:11:20">2025-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/finance/fundiing-rate/" title="资金费率套利完整指南"><img src="https://cdn.blog-blockchain.xyz/2026/02/2882ad3aa493489c4cb0d9c60a862bb8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="资金费率套利完整指南"></a><div class="content"><a class="title" href="/finance/fundiing-rate/" title="资金费率套利完整指南">资金费率套利完整指南</a><time datetime="2025-10-05T10:26:20.000Z" title="Created 2025-10-05 18:26:20">2025-10-05</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2020 - 2026 By Michael L</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.9/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js?v=1771518382866"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="local-search-input"><input placeholder="Search for Posts" type="text"></div><hr><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div></div></div><script src="/bundle.js"></script><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})();
(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})();
(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '467d9506710fff22dc33',
      clientSecret: '2a3e530b895af9c94d4bbe95fe78c69317f4d76e',
      repo: 'blog-gitalk',
      owner: 'learnerLj',
      admin: ['learnerLj'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'f89480bd87fb5d3cff4b32d63ad630b2'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></body></html>