<!DOCTYPE html><html lang="default" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>（三）Datalog和程序分析 | Jiahao Luo</title><meta name="author" content="Michael(Jiahao) Luo"><meta name="copyright" content="Michael(Jiahao) Luo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="（一）初识软件分析（二）数据流分析基础（三）Datalog和程序分析（四）静态单赋值和稀疏分析（五）过程间分析（六）指向分析（七）抽象解释（八）SMT和符号执行（九）体验静态分析工具（十）Fuzzing 基础  前言 笔者在学习 Datalog 之前，已经学习过数据流分析，也学习过一门函数式编程语言，所以能够较为快速地接受新概念。如果读者觉得有些概念比较难以理解，可以搜索关键词学习。 文章引用部">
<meta property="og:type" content="article">
<meta property="og:title" content="（三）Datalog和程序分析">
<meta property="og:url" content="https://www.blog-blockchain.xyz/pl/LP-souffle/index.html">
<meta property="og:site_name" content="Jiahao Luo">
<meta property="og:description" content="（一）初识软件分析（二）数据流分析基础（三）Datalog和程序分析（四）静态单赋值和稀疏分析（五）过程间分析（六）指向分析（七）抽象解释（八）SMT和符号执行（九）体验静态分析工具（十）Fuzzing 基础  前言 笔者在学习 Datalog 之前，已经学习过数据流分析，也学习过一门函数式编程语言，所以能够较为快速地接受新概念。如果读者觉得有些概念比较难以理解，可以搜索关键词学习。 文章引用部">
<meta property="og:locale">
<meta property="og:image" content="https://www.blog-blockchain.xyz/images/pa.png">
<meta property="article:published_time" content="2022-10-04T13:54:33.000Z">
<meta property="article:modified_time" content="2024-11-15T14:30:54.926Z">
<meta property="article:author" content="Michael(Jiahao) Luo">
<meta property="article:tag" content="program language">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.blog-blockchain.xyz/images/pa.png"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://www.blog-blockchain.xyz/pl/LP-souffle/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css?v=5.2.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?372b8854d18acf62880149b1e08e1901";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=QXcJQjXxTMeUwnWykFW2xw"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'QXcJQjXxTMeUwnWykFW2xw')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'QXcJQjXxTMeUwnWykFW2xw', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '（三）Datalog和程序分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Jiahao Luo" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/site-avator.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jiahao Luo</span></a><a class="nav-page-title" href="/"><span class="site-name">（三）Datalog和程序分析</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archive</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">（三）Datalog和程序分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-10-04T13:54:33.000Z" title="Created 2022-10-04 21:54:33">2022-10-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-15T14:30:54.926Z" title="Updated 2024-11-15 22:30:54">2024-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/program-language/">program language</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>31mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><blockquote>
<ol class="series-items"><li><a href="/pl/understanding-program-analysis/" title="（一）初识软件分析">（一）初识软件分析</a></li><li><a href="/pl/data-flow-analysis/" title="（二）数据流分析基础">（二）数据流分析基础</a></li><li><a href="/pl/LP-souffle/" title="（三）Datalog和程序分析">（三）Datalog和程序分析</a></li><li><a href="/pl/ssa-and-sparse-analysis/" title="（四）静态单赋值和稀疏分析">（四）静态单赋值和稀疏分析</a></li><li><a href="/pl/Interprocedural-DFA/" title="（五）过程间分析">（五）过程间分析</a></li><li><a href="/pl/points-to-analysis/" title="（六）指向分析">（六）指向分析</a></li><li><a href="/pl/abstract-interpretation/" title="（七）抽象解释">（七）抽象解释</a></li><li><a href="/pl/SMT-and-symbolic-excution/" title="（八）SMT和符号执行">（八）SMT和符号执行</a></li><li><a href="/pl/static-analysis-tools/" title="（九）体验静态分析工具">（九）体验静态分析工具</a></li><li><a href="/pl/fuzzing-introduction/" title="（十）Fuzzing 基础">（十）Fuzzing 基础</a></li></ol>
</blockquote>
<h1>前言</h1>
<p>笔者在学习 Datalog 之前，已经学习过数据流分析，也学习过一门函数式编程语言，所以能够较为快速地接受新概念。如果读者觉得有些概念比较难以理解，可以搜索关键词学习。</p>
<p>文章引用部分较多中英夹杂，因为没有必要花时间翻译了，我只是在末尾简要用中文提炼我认为的重点，帮助读者理解。笔者没有刻意中英夹杂的意思，提高英文能力对深入最先进的或者较为小领域的知识，是非常重要的。</p>
<p>笔者并没有很扎实的数理逻辑知识，只学过本科计算机专业课离散数学，所以部分概念理解可能不准确。笔者也只是刚入门程序分析，并没有形成整个领域的系统认识，也不了解术语规定。如果发现有任何错误，请不吝斧正。</p>
<p>稳定翻译这篇更加全一些：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://jckling.github.io/2021/11/22/Other/Datalog%20%E5%BC%95%E6%93%8E%20Souffl%C3%A9%20%E6%8C%87%E5%8D%97/">《Datalog 引擎 Soufflé 指南》</a></p>
<h1>预备知识</h1>
<h2 id="逻辑式语言">逻辑式语言</h2>
<p>在之前我们完成了函数式编程 Haskell 的学习之后，开始接触逻辑式编程语言。直接看 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Logic_programming">wiki</a> 上的介绍：</p>
<blockquote>
<p><strong>Logic programming</strong> is a <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Programming_paradigm">programming paradigm</a> which is largely based on formal <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Logic">logic</a>. Any program written in a logic <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Programming_language">programming language</a> is a set of sentences in logical form, expressing facts and rules about some problem domain. Major logic programming language families include <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Prolog">Prolog</a>, <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Answer_set_programming">answer set programming</a> (ASP) and <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Datalog">Datalog</a>. In all of these languages, rules are written in the form of _<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Clause_(logic)">clauses</a>_:</p>
</blockquote>
<p>看起来会和离散数学比较相关，我们这次入手的主要是 Datalog</p>
<blockquote>
<p>In ASP and Datalog, logic programs have only a <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Declarative_programming">declarative</a> reading, and their execution is performed by means of a proof procedure or model generator whose behaviour is not meant to be controlled by the programmer. However, in the Prolog family of languages, logic programs also have a <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Procedural_programming">procedural</a> interpretation as goal-reduction procedures:</p>
</blockquote>
<p>其中首先要了解 declarative reading ，declarative programming 没有控制流，只用于描述程序处理特定问题时必须实现的东西，比如 SQL 就是这样的语言。也就是说，datalog 实际上并不是靠程序员控制行为，而是根据命题公式去执行。但是 Prolog 也存在 Procedural programming 范式的过程调用，类似于 C 语言中的函数或者子程序，把一个问题拆分成多个小问题。</p>
<blockquote>
<p>The declarative reading of logic programs can be used by a programmer to verify their correctness. Moreover, logic-based <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Program_transformation">program transformation</a> techniques can also be used to transform logic programs into logically equivalent programs that are more efficient.</p>
</blockquote>
<p>因此，datalog 这种形式逻辑定义的语言，就很合适用于判断程序的执行是否和期望一致，并 datalog 还支持编译成等价的程序，提高性能。</p>
<p>以上涉及到一些数理逻辑术语，可以查看附录一。</p>
<h2 id="Datalog">Datalog</h2>
<p>wiki 介绍：</p>
<blockquote>
<p>It is often used as a <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Query_language">query language</a> for <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Deductive_database">deductive databases</a>. In recent years, Datalog has found new application in <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Data_integration">data integration</a>, <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Information_extraction">information extraction</a>, <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Computer_network">networking</a>, <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Program_analysis">program analysis</a>, <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Security">security</a>, <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Cloud_computing">cloud computing</a> and <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Machine_learning">machine learning</a>.[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Datalog#cite_note-1">1]</a>[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Datalog#cite_note-2">2]</a></p>
</blockquote>
<p>特点：</p>
<ol>
<li>statements of a Datalog program can be stated in any order.</li>
<li>Datalog queries on <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Finite_sets">finite sets</a> are guaranteed to <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Algorithm#Termination">terminate</a>. This makes Datalog a fully <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Declarative_language">declarative language</a>.</li>
<li>disallows complex terms as arguments of <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Predicate_(logic)">predicates</a>, e.g., <code>p(1, 2)</code> is admissible but not <code>p(f(1), 2)</code></li>
<li>imposes certain <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Stratification_(mathematics)">stratification</a> restrictions on the use of negation and <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Recursion">recursion</a>. 谓词上的环状依赖不能包含否定规则，简单的说，不管如何推理，不能最终出现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>P</mi><mo>→</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">\lnot P\rightarrow P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>，这样矛盾的形式。</li>
<li>requires that every variable that appears in the head of a <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Clause_(logic)">clause</a> also appear in a nonarithmetic positive (i.e. not negated) <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Literal_(mathematical_logic)">literal</a> in the body of the clause。这需要了解逻辑式语言的一般形式，可以见 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Logic_programming">wiki</a> 最开头的说明。目的就是避免无意义的永真或者永假，或者真值无法通过给出的变量确定的情况。</li>
<li>requires that every variable appearing in a negative literal in the body of a clause also appear in some positive literal in the body of the clause[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Datalog#cite_note-5">5]</a>（暂时不懂为啥这么定义）</li>
<li>Query evaluation with Datalog is based on <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/First-order_logic">first-order logic</a>, and is thus <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Soundness">sound</a> and <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Completeness_(logic)">complete</a>. 先解释 first-oder logic，中文叫做一阶逻辑或者谓词逻辑。sound 指上近似，程序分析术语，大致意思是按照规则筛选，那么结果一定是复合预期的。complete 指符合规则的一定会被全部筛选出来。</li>
<li>Datalog is not <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a>, and is thus used as a <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Domain-specific_language">domain-specific language</a> that can take advantage of efficient algorithms developed for query resolution.</li>
<li>Solving the boundedness problem on arbitrary Datalog programs is <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Undecidable_problem">undecidable</a>,[<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Datalog#cite_note-10">10]</a> but it can be made decidable by restricting to some fragments of Datalog. 不可判定性的处理，这里 <strong>fragment</strong> of a logical language or <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Theory_(mathematical_logic)">theory</a> is a subset of this logical language obtained by imposing <a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Syntax">syntactical</a> restrictions on the language.</li>
</ol>
<p>一个来自 wiki 的例子可以介绍基本的用法和思想：</p>
<h2 id="逻辑式语言例子">逻辑式语言例子</h2>
<p>These two lines define two <em>facts</em>, i.e. things that always hold:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent(xerces, brooke).</span><br><span class="line">parent(brooke, damocles).</span><br></pre></td></tr></table></figure>
<p>This is what they mean: <em>xerces is a parent of brooke</em> and <em>brooke is a parent of damocles</em>. The names are written in lowercase because strings beginning with an uppercase letter stand for variables.</p>
<p>These two lines define <em>rules</em>, which define how new facts can be inferred from known facts.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ancestor(X, Y) :- parent(X, Y).</span><br><span class="line">ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).</span><br></pre></td></tr></table></figure>
<p>meaning:</p>
<ul>
<li><em>X is an ancestor of Y if X is a parent of Y.</em></li>
<li><em>X is an ancestor of Y if X is a parent of some Z, and Z is an ancestor of Y.</em></li>
</ul>
<p>This line is a query:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?- ancestor(xerces, X).</span><br></pre></td></tr></table></figure>
<p>It asks the following: <em>Who are all the X that xerces is an ancestor of?</em> It would return <em>brooke</em> and <em>damocles</em> when posed against a Datalog system containing the facts and rules described above.</p>
<h1>souffle</h1>
<h2 id="介绍">介绍</h2>
<p>开始正式的学习吧，来看看特性</p>
<blockquote>
<p>Soufflé is a logic programming language inspired by Datalog. It overcomes some of the limitations in classical Datalog. For example, programmers are not restricted to finite domains, and the usage of functors (intrinsic, user-defined, records/constructors, etc.) is permitted.</p>
<p>One of the major challenges in logic programming is performance and scalability. Soufflé applies advanced compilation techniques for logic programs. We use a range of techniques to achieve high-performance.</p>
<p>declarative rules are efficiently translated to efficient C++ programs on modern computer hardware, including multi-core computers</p>
</blockquote>
<p>支持非有限域（关于有限域可以学习近世代数），而且允许过程调用，不要求完全都是声明式。（如果您对这些概念陌生，可以仔细阅读预备知识或者相关 wiki)</p>
<p>用途：</p>
<blockquote>
<p>Soufflé was initially designed for crafting static analysis in logic at Oracle Labs. Since then, there have been many other applications written in the Soufflé language, including applications in reverse engineering, network analysis and data analytics.</p>
</blockquote>
<p>使用了 souffle 的项目：（可以有一定基础后观摩学习）：</p>
<blockquote>
<p>Soufflé provides the ability to rapid prototype and make deep design space explorations possible. A wide range of <a target="_blank" rel="noopener external nofollow noreferrer" href="https://souffle-lang.github.io/applications">applications</a> have been implemented in the Soufflé language, e.g., static program analysis for Java <a target="_blank" rel="noopener external nofollow noreferrer" href="https://bitbucket.org/yanniss/doop">DOOP</a>, parallelizing compiler framework <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.insieme-compiler.org/">Insieme</a>, binary disassembler <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/GrammaTech/ddisasm">DDISASM</a>, <a target="_blank" rel="noopener external nofollow noreferrer" href="https://link.springer.com/chapter/10.1007%2F978-3-030-25543-5_14">security analysis for cloud computing</a>, and security analysis for smart contracts <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/nevillegrech/gigahorse-toolchain">Gigahorse</a>, <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/eth-sri/securify">Securify</a>, <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/eth-sri/securify2">Secuify V2.0</a>, <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/usyd-blockchain/vandal">VANDAL</a>. More applications are listed <a target="_blank" rel="noopener external nofollow noreferrer" href="https://souffle-lang.github.io/applications">here</a>.</p>
</blockquote>
<h2 id="安装">安装</h2>
<p>没有看到 windows 版本的直接安装的办法，只能从源码构建，但是比较容易出问题，并且新手难以解决。所以建议使用 linux 系统。按照<a target="_blank" rel="noopener external nofollow noreferrer" href="https://souffle-lang.github.io/install">教程</a>即可。</p>
<h1>基础使用</h1>
<h2 id="程序示例">程序示例</h2>
<p>以下内容来自<a target="_blank" rel="noopener external nofollow noreferrer" href="https://souffle-lang.github.io/simple">官网</a>，表达了传递闭包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// example.dl</span><br><span class="line"></span><br><span class="line">// 声明，edge是关系，可以理解为一阶逻辑里的二元关系</span><br><span class="line">.decl edge(x:number, y:number)</span><br><span class="line">//表示从文件读取</span><br><span class="line">.input edge</span><br><span class="line"></span><br><span class="line">//声明，path也可以理解成二元关系</span><br><span class="line">.decl path(x:number, y:number)</span><br><span class="line">//表示会写入磁盘</span><br><span class="line">.output path</span><br><span class="line"></span><br><span class="line">//这就是一般的 H if B1 B2 B3的形式，表示(B1 B2 B3)蕴含H</span><br><span class="line">//这里是如果存在边x到有的边，那么就存在x到y的路径。</span><br><span class="line">//即满足于关系path(x,y)，当且仅当满足edge(x, y)或者path(x, z), edge(z, y)</span><br><span class="line">//注意定义联系的时候都会有点结尾。</span><br><span class="line">path(x, y) :- edge(x, y).</span><br><span class="line">path(x, y) :- path(x, z), edge(z, y).</span><br></pre></td></tr></table></figure>
<p>定义输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//edge.facts</span><br><span class="line">//将会从这个文件读取，facts是无论如何为真的命题公式</span><br><span class="line">1	2</span><br><span class="line">2	3</span><br></pre></td></tr></table></figure>
<p>详细的命令可以输入 <code>souffle --help</code> 查看。运行之后可以得到输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">souffle -F. -D. example.dl</span><br></pre></td></tr></table></figure>
<p>但是可能得到的是压缩包，也可能不是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  souffle_test souffle -F . -D . example.dl</span><br><span class="line">(base) ➜  souffle_test ls</span><br><span class="line">edge.facts  example.dl  path.csv.gz</span><br></pre></td></tr></table></figure>
<p>还需要解压缩就可以查看内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  souffle_test gzip -d path.csv.gz</span><br><span class="line">(base) ➜  souffle_test ls</span><br><span class="line">edge.facts  example.dl  path.csv</span><br></pre></td></tr></table></figure>
<p>一般情况，可以直接标准输出，即输出的文件夹设置为 <code>-</code>，在控制台打印</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  introduction souffle example.dl -D -</span><br><span class="line">---------------</span><br><span class="line">path</span><br><span class="line">x       y</span><br><span class="line">===============</span><br><span class="line">1       2</span><br><span class="line">1       3</span><br><span class="line">2       3</span><br><span class="line">===============</span><br></pre></td></tr></table></figure>
<h2 id="编译">编译</h2>
<p>之前是直接以解释器(Interpreter)运行，虽然不需要编译时间，但是效率可能不是很高。可以编译成 C++后运行。<code>souffle -F . -D . -o example example.dl</code> 之后就会生成 cpp 源码和二进制的 cpp 文件。可执行文件也有 help 选项。</p>
<p><code>-c</code> 的功能和 <code>-o</code> 类似，差别在于 <code>-c</code> 会在编译之后，立刻执行程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  souffle_test ./example --help</span><br><span class="line">./example: unrecognized option &#x27;--help&#x27;</span><br><span class="line">====================================================================</span><br><span class="line"> Datalog Program: example.dl</span><br><span class="line"> Usage: ./example [OPTION]</span><br><span class="line"></span><br><span class="line"> Options:</span><br><span class="line">    -D &lt;DIR&gt;, --output=&lt;DIR&gt;     -- Specify directory for output relations</span><br><span class="line">                                    (default: )</span><br><span class="line">                                    (suppress output with &quot;&quot;)</span><br><span class="line">    -F &lt;DIR&gt;, --facts=&lt;DIR&gt;      -- Specify directory for fact files</span><br><span class="line">                                    (default: )</span><br><span class="line">    -j &lt;NUM&gt;, --jobs=&lt;NUM&gt;       -- Specify number of threads</span><br><span class="line">                                    (default: 1)</span><br><span class="line">    -h                           -- prints this help page.</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"> Copyright (c) 2016-22 The Souffle Developers.</span><br><span class="line"> Copyright (c) 2013-16 Oracle and/or its affiliates.</span><br><span class="line"> All rights reserved.</span><br><span class="line">====================================================================</span><br></pre></td></tr></table></figure>
<h2 id="调试和日志分析">调试和日志分析</h2>
<p>生成 html 调试日志 <code>souffle -F . -D . -r example.html example.dl</code>，有非常详细的分析报告。</p>
<p>也可以简要生成日志，然后用附带的专门的分析工具 <code>souffleprof</code> 分析性能.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  souffle_test souffle -F . -D . -p example.log example.dl</span><br><span class="line">(base) ➜  souffle_test souffleprof example.log</span><br></pre></td></tr></table></figure>
<h2 id="其他功能">其他功能</h2>
<p>所有的选项如下表，还是挺丰富的。一些高阶选项后面会接触，大家可以现在都看一遍。</p>
<p><img src="http://cdn.blog-blockchain.xyz/202209242353850.png" alt="image-20220924235354703"></p>
<h1>语法</h1>
<p>先看一般的介绍：</p>
<blockquote>
<p>Facts are just atomic formulas, rules are atomic formulas followed by a condition — one or more atomic formulas conjoined. Explicit disjunctions are not needed. A question consists of one or more atomic formulas conjoined.</p>
</blockquote>
<blockquote>
<p>Atomic formulas consist of a <em>predicate</em>, optionally followed by a parenthesised list of one or more parameters separated by commas.</p>
</blockquote>
<blockquote>
<p>Parameters are individual constants — now called <em>names</em>, starting with a lowercase letter, or they are individual variables — or just <em>variables</em>, starting with an uppercase letter. Names have their obvious meaning, whereas variables are either quantified — in facts and rules, or they are to be bound in queries.</p>
</blockquote>
<p>请注意用于数据库查询的 datalog 和用于程序分析的 datalog 有一些差别。数据库查询的方面，有个不错的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://nickelsworth.github.io/sympas/16-datalog.html">博客</a>。</p>
<blockquote>
<p>There is no unified standard for the specification of Datalog syntax. Thus, each implementation of Datalog may differ. A principle goal of the Soufflé project is speed, tailoring program execution to multi-core servers with large amounts of memory.</p>
</blockquote>
<p>文件名一般是 <code>&lt;program.dl&gt;</code>，<strong>语句并不是顺序执行</strong>，程序的整个组成部分如下，有个大致印象即可：</p>
<p><img src="http://cdn.blog-blockchain.xyz/202210041417336.svg+xml" alt="Program"></p>
<h2 id="注释">注释</h2>
<p>注释的格式和 C 语言完全一致。<code>//</code> 或者是 <code>/**/</code></p>
<h2 id="数据类型">数据类型</h2>
<p>静态类型系统。只有四类基础类型，<code>symbols</code> 相当于字符串，<code>number</code> 是数字。<code>unsigned</code> 和 <code>float</code> 用的较少。</p>
<p><code>number </code>可以是 10 进制，2 进制，16 进制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.decl A(x:number)</span><br><span class="line">A(4711).</span><br><span class="line">A(0b101).</span><br><span class="line">A(0xaffe).</span><br></pre></td></tr></table></figure>
<h2 id="IO">IO</h2>
<p>facts 可以直接写在程序里，也可以通过 <code>.input</code> 从文件读取，默认的间隔用 <code>TAB</code>，输入的文件名字必须和 <code>.decl</code> 名字相同，而且后缀是 <code>.fact</code></p>
<h2 id="一阶逻辑">一阶逻辑</h2>
<p><code>:-</code> 是逻辑推导的符号，表示 <code>.decl</code> 定义的关系之间的联系，而且定义方式相当自由，允许递归等形式，但是不能是互相矛盾的式子。</p>
<h3 id="数据结构">数据结构</h3>
<p>一般默认关系的数组结构是自然平衡树 <code>btree</code>，也可以强制地显式指定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.decl A(x:number, y:symbol) btree</span><br></pre></td></tr></table></figure>
<p>另外也存在特殊地用于数据密集型地数据结构 <code>Brie</code>，这是一种特殊的 <code>Trie</code>，默认读者熟悉前缀树。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.decl A(x:number, y:symbol) brie</span><br></pre></td></tr></table></figure>
<h3 id="等价关系">等价关系</h3>
<p>默认读者熟悉等价关系，可见 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://zh.m.wikipedia.org/zh/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">wiki</a>。等价关系非常常用，所以加了特殊的关键字 <code>eqrel</code>，下面给两个程序是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.decl eqrel_fast(x : number, y : number) eqrel</span><br><span class="line">eqrel_fast(a,b) :- rel1(a), rel2(b).</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.decl equivalence(x:number, y:number)</span><br><span class="line">equivalence(a, b) :- rel1(a), rel2(b).      // every element of rel1 is equivalent to every element of rel2</span><br><span class="line"></span><br><span class="line">equivalence(a, a) :- equivalence(a, _).     // reflexivity</span><br><span class="line">equivalence(a, b) :- equivalence(b, a).     // symmetry</span><br><span class="line">equivalence(a, c) :- equivalence(a, b), equivalence(b, c).  // transitivity</span><br></pre></td></tr></table></figure>
<h3 id="inline">inline</h3>
<p>和 C 语言类似，<code>inline</code> 将会在评估的时候直接展开，而不是单独的存储数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.decl natural_number(x:number)</span><br><span class="line">natural_number(0).</span><br><span class="line">natural_number(x+1) :- natural_number(x), x &lt; 10000.</span><br><span class="line"></span><br><span class="line">.decl natural_pairs(x:number, y:number) inline</span><br><span class="line">natural_pairs(x,y) :- natural_number(x), natural_number(y).</span><br><span class="line"></span><br><span class="line">.decl query(x:number)</span><br><span class="line">query(x) :- natural_pairs(x,y), x &lt; 5, y &lt; x.</span><br></pre></td></tr></table></figure>
<p>相当于下面的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.decl natural_number(x:number)</span><br><span class="line">natural_number(0).</span><br><span class="line">natural_number(x+1) :- natural_number(x), x &lt; 10000.</span><br><span class="line"></span><br><span class="line">.decl query(x:number)</span><br><span class="line">query(x) :- natural_number(x), natural_number(y), x &lt; 5, y &lt; x.</span><br></pre></td></tr></table></figure>
<p>这样子会避免计算并且存储大量的 <code>natural_pairs</code>。但是可以知道，这必然会带来一定用法上的限制，我们暂时略过。</p>
<h3 id="析取">析取</h3>
<p>一般来说，Datalog 都是采取合取，但是也支持析取的语法。也就是 yong <code>;</code> 而不是 <code>,</code> 间隔。</p>
<p>例如，假设对于是否能进入房子分成三类人，<code>Housemate</code> 和 <code> Owner</code> 可以进入，但是 <code>Stranger</code> 不可以。就可以得到下面的程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.type Owner &lt;: symbol</span><br><span class="line">.type Housemate &lt;: symbol</span><br><span class="line">.type Building &lt;: symbol</span><br><span class="line">.type Stranger &lt;: symbol</span><br><span class="line"></span><br><span class="line">.type Human = Housemate|Owner|Stranger</span><br><span class="line"></span><br><span class="line">.decl IsHousemate(x:Housemate,y:Building)</span><br><span class="line">.decl IsOwner(x:Owner,y:Building)</span><br><span class="line">.decl IsStranger(x:Stranger,y:Building)</span><br><span class="line"></span><br><span class="line">IsHousemate(&quot;Bob&quot;,&quot;partment123&quot;).</span><br><span class="line">IsOwner(&quot;Alice&quot;,&quot;partment123&quot;).</span><br><span class="line">IsStranger(&quot;Eric&quot;,&quot;partment123&quot;).</span><br><span class="line"></span><br><span class="line">.decl accessable(x:Human,y:Building)</span><br><span class="line">.output accessable</span><br><span class="line">accessable(x,y) :- IsHousemate(x,y);IsOwner(x,y),!IsStranger(x,y).</span><br></pre></td></tr></table></figure>
<h2 id="算术表达式">算术表达式</h2>
<p>souffle 做了一定的函子拓展，支持部分内置算术表达式。例如，可以在推导时加上条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.decl A(n: number)</span><br><span class="line">.output A</span><br><span class="line">A(1).</span><br><span class="line">A(x+1) :- A(x), x &lt; 9.</span><br></pre></td></tr></table></figure>
<h3 id="算术操作">算术操作</h3>
<ul>
<li>Addition: <code>x + y</code></li>
<li>Subtraction: <code>x - y</code></li>
<li>Division: <code>x / y</code></li>
<li>Multiplication: <code>x * y</code></li>
<li>Modulo: <code>a % b</code></li>
<li>Power: <code>a ^ b</code></li>
<li>Counter: <code>autoinc()</code></li>
<li>Bit operations: <code>x band y</code>, <code>x bor y</code>, <code>x bxor y</code>, and <code>bnot x</code></li>
<li>Logical operations: <code>x land y</code>, <code>x lor y</code>, and <code>lnot x</code></li>
</ul>
<h3 id="算术比较">算术比较</h3>
<p>The following arithmetic constraints are allowed in Soufflé:</p>
<ul>
<li>Less than: <code>a &lt; b</code></li>
<li>Less than or equal to: <code>a &lt;= b</code></li>
<li>Equal to: <code>a = b</code></li>
<li>Not equal to: <code>a != b</code></li>
<li>Greater than or equal to: <code>a &gt;= b</code></li>
<li>Greater than: <code>a &gt; b</code></li>
</ul>
<h2 id="内置函子">内置函子</h2>
<p>比较特殊的是，<code>autonic()</code> 函子，相当于创建随机数。</p>
<p><strong><code>ord()</code></strong> 会生成此程序中这个 <code>symbol</code> 类型的序号，比如 <code>a</code> 的序号应该小于 <code>b</code>。</p>
<p>还有一些聚合函数，聚合函数的概念在数据库中应该学习过，就是一个集合中提取出来一个信息。</p>
<p><strong><code>cout</code></strong>: 统计满足条件的 fact 个数，基本语法是 <code>count:&#123;集合与条件&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.decl Car(name: symbol, colour:symbol)</span><br><span class="line">Car(&quot;Audi&quot;, &quot;blue&quot;).</span><br><span class="line">Car(&quot;VW&quot;, &quot;red&quot;).</span><br><span class="line">Car(&quot;BMW&quot;, &quot;blue&quot;).</span><br><span class="line"></span><br><span class="line">.decl BlueCarCount(x: number)</span><br><span class="line">BlueCarCount(c) :- c = count:&#123;Car(x,&quot;blue&quot;),ord(x)&gt;ord(&quot;Audi&quot;)&#125;.</span><br><span class="line">.output BlueCarCount</span><br></pre></td></tr></table></figure>
<p><strong><code>max</code></strong>: 很好理解，注意还要制定选择哪一个变量。</p>
<p><strong><code>min</code></strong>: 和 max 用法完全相同。</p>
<p><strong><code>sum</code></strong>: 也需要指定变量。</p>
<p>三者的用法见程序:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.decl A(n:number, w:symbol)</span><br><span class="line">A(1, &quot;a&quot;). A(10, &quot;b&quot;). A(100, &quot;c&quot;).</span><br><span class="line"></span><br><span class="line">.decl MaxA(x: number,w:symbol)</span><br><span class="line">.output MaxA</span><br><span class="line">MaxA(y, w) :- y = max x:&#123;A(x, w)&#125;.</span><br><span class="line"></span><br><span class="line">.decl MinA(x: number,w:symbol)</span><br><span class="line">.output MinA</span><br><span class="line">MinA(y, w) :- y = min x:&#123;A(x, w)&#125;.</span><br><span class="line"></span><br><span class="line">.decl Sum(s:number)</span><br><span class="line">.output Sum</span><br><span class="line">Sum(s) :- s = sum x:&#123;A(x,_)&#125;.</span><br></pre></td></tr></table></figure>
<p>得到的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  exp1 souffle max-min-sum.dl -D -</span><br><span class="line">---------------</span><br><span class="line">MaxA</span><br><span class="line">x       w</span><br><span class="line">===============</span><br><span class="line">100     c</span><br><span class="line">===============</span><br><span class="line">---------------</span><br><span class="line">MinA</span><br><span class="line">x       w</span><br><span class="line">===============</span><br><span class="line">1       a</span><br><span class="line">===============</span><br><span class="line">---------------</span><br><span class="line">Sum</span><br><span class="line">s</span><br><span class="line">===============</span><br><span class="line">111</span><br><span class="line">===============</span><br></pre></td></tr></table></figure>
<p><strong><code>contains(string1, string2)</code></strong> : string2 是否包含 string1</p>
<p><strong><code>match</code></strong>: 含有通配符的匹配，但是文档里没有说明有哪些通配符，读者暂时只记住下面的例子即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.decl inputData(t:symbol)</span><br><span class="line">.decl outputData(t:symbol)</span><br><span class="line">.output outputData</span><br><span class="line">outputData(x) :- inputData(x), match(&quot;a.*&quot;,x).</span><br><span class="line">inputData(&quot;aaaa&quot;).</span><br><span class="line">inputData(&quot;abba&quot;).</span><br><span class="line">inputData(&quot;bcab&quot;).</span><br><span class="line">inputData(&quot;bdab&quot;).</span><br></pre></td></tr></table></figure>
<h2 id="自定义数据类型">自定义数据类型</h2>
<h3 id="基本语法">基本语法</h3>
<p>主要类似结构体，这虽然会影响性能，但是拓展了可用性。基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.type &lt;name&gt; = [ &lt;name_1&gt;: &lt;type_1&gt;, ..., &lt;name_k&gt;: &lt;type_k&gt; ]</span><br></pre></td></tr></table></figure>
<p>看下面的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Pair of numbers</span><br><span class="line">.type Pair = [a:number, b:number]</span><br><span class="line"></span><br><span class="line">.decl A(p: Pair)  // declare a set of pairs</span><br><span class="line">A([1,2]).</span><br><span class="line">A([3,4]).</span><br><span class="line">A([4,5]).</span><br><span class="line"></span><br><span class="line">.output A</span><br><span class="line"></span><br><span class="line">// 扁平化</span><br><span class="line">.decl Flatten(a:number, b:number) output</span><br><span class="line">Flatten(a,b) :- A([a,b]).</span><br></pre></td></tr></table></figure>
<p>也可以定义<strong>类型别名</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.type myNumber = number</span><br></pre></td></tr></table></figure>
<p>特殊地，还存在<strong>子类型</strong>，每个子类型都是原来类型地严格子集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.type EvenNumber &lt;: number</span><br><span class="line">.type OddNumber &lt;: number</span><br><span class="line">.type MultiplesOfFour &lt;: myEvenNumber</span><br></pre></td></tr></table></figure>
<p>为什么要存在子类型呢，因为这样可取区分不同的类型，比如 <code>EvenNumber</code> 和 <code>OddNumber</code> 就区分开了，在大型的项目中有利于减少错误。</p>
<p>实际的存储方式其实是通过记录 <code>p</code> 然后映射</p>
<p><img src="https://souffle-lang.github.io/img/record_table.png" alt="Record table example"></p>
<h3 id="Union-类型">Union 类型</h3>
<p>这类似于模式匹配，或者说 C 语言的联合体。具体语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.type &lt;ident&gt; = &lt;ident-1&gt; | &lt;ident-2&gt; | ... | &lt;ident-k&gt;</span><br></pre></td></tr></table></figure>
<p>例如地点可以分成多种类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.type City &lt;: symbol</span><br><span class="line">.type Town &lt;: symbol</span><br><span class="line">.type Village &lt;: symbol</span><br><span class="line">.type Place = City | Town | Village</span><br></pre></td></tr></table></figure>
<p>定义的时候，需要注意，所有类别都应该是同一种基础类型，比如上面的 <code>City</code>、<code>Town</code>、<code>Village</code> 都是基础类型 <code>symbol</code> 的子集。</p>
<p>前面提到了<strong>子类型</strong>，那么就要注意类型的默认转换规则，子类型或者同样的类型，才可以赋值，比如 B=&gt;A 中，A 中 <code>x</code> 的参数类型必须包含 A 中 <code>x</code> 的类型，才可以给 A 赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.type even = number</span><br><span class="line">.type odd = number</span><br><span class="line">.decl A(x:even)</span><br><span class="line">.decl B(x:odd)</span><br><span class="line">A(X) :- B(X).</span><br></pre></td></tr></table></figure>
<p>如果是这样就会报错.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.type even &lt;: number</span><br><span class="line">.type odd &lt;: number</span><br><span class="line">.decl A(x:even)</span><br><span class="line"></span><br><span class="line">.decl B(x:odd)</span><br><span class="line">.output A</span><br><span class="line">B(1). B(3).</span><br><span class="line">A(X) :- B(X).</span><br></pre></td></tr></table></figure>
<p><strong>类型转换</strong>，但是 <code>as(&lt;expr&gt;, &lt;new-type&gt;)</code> 可以进行类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.type even &lt;: number</span><br><span class="line">.type odd &lt;: number</span><br><span class="line">.decl A(x:even)</span><br><span class="line"></span><br><span class="line">.decl B(x:number)</span><br><span class="line">.output A</span><br><span class="line">B(1). B(3).</span><br><span class="line">A(as(X,even)) :-  B(X).</span><br></pre></td></tr></table></figure>
<h3 id="代数数据类型">代数数据类型</h3>
<p>他就更加类似模式匹配了，如果模式匹配不熟悉，可以稍微了解 Haskell，博客中也有所涉及。基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.type &lt;new-adt&gt; = &lt;branch-id&gt; &#123; &lt;name_1&gt;: &lt;type_1&gt;, ..., &lt;name_k&gt;: &lt;type_k&gt; &#125; | ...</span><br></pre></td></tr></table></figure>
<p>例如，不同的代数数据类型，甚至可以<strong>表示</strong>简单的数的操作，逐渐有其他语言中 <code>class</code> 类型的味道。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.type T = A &#123; x: number &#125;</span><br><span class="line">        | B &#123; x: symbol &#125;</span><br><span class="line"></span><br><span class="line">.type Nat = S &#123;x : Nat&#125;</span><br><span class="line">          | Zero &#123;&#125;</span><br><span class="line"></span><br><span class="line">.type Expression = Number &#123; x : number &#125;</span><br><span class="line">                 | Variable &#123; v : symbol&#125;</span><br><span class="line">                 | Add &#123;e_1 : Expression, e_2 :Expression&#125;</span><br><span class="line">                 | Minus &#123;e_1 : Expression, e_2 : Expression&#125;</span><br><span class="line">                 | Mult &#123;e_1 : Expression, e_2 : Expression&#125;</span><br><span class="line">                 | Divide &#123;e_1 : Expression, e_2 : Expression&#125;</span><br><span class="line"></span><br><span class="line">.type Tree = Empty &#123;&#125;</span><br><span class="line">           | Node &#123;t1: Tree, val: unsigned, t2: Tree&#125;</span><br></pre></td></tr></table></figure>
<p>上面 使用的是 <code>Empty</code> 表示空，因为不能够出现 <code>nil</code>。</p>
<p>使用的时候，采用这样的格式 <code>$branch_constructor(args...)</code> 指定选择哪一个分支。每个分支的名字在整个程序的范围内，都必须不能重复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.type Expression = Number &#123; x : number &#125;</span><br><span class="line">                 | Variable &#123; v : symbol&#125;</span><br><span class="line">                 | Add &#123;e_1 : Expression, e_2 :Expression&#125;</span><br><span class="line">                 | Imaginary &#123;&#125;</span><br><span class="line"></span><br><span class="line">.decl A(x:Expression)</span><br><span class="line">A($Number(10)).</span><br><span class="line">A($Add($Number(10),$Imaginary())).</span><br><span class="line">A($Add($Number(10), $Variable(&quot;x&quot;))).</span><br><span class="line">A($Number(x+1)) :- A($Number(x)), x &lt; 20.</span><br><span class="line"></span><br><span class="line">.output A</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  exp1 souffle test.dl -D -</span><br><span class="line">---------------</span><br><span class="line">A</span><br><span class="line">x</span><br><span class="line">===============</span><br><span class="line">$Number(10)</span><br><span class="line">$Add($Number(10), $Imaginary)</span><br><span class="line">$Add($Number(10), $Variable(x))</span><br><span class="line">$Number(11)</span><br><span class="line">$Number(12)</span><br><span class="line">$Number(13)</span><br><span class="line">$Number(14)</span><br><span class="line">$Number(15)</span><br><span class="line">$Number(16)</span><br><span class="line">$Number(17)</span><br><span class="line">$Number(18)</span><br><span class="line">$Number(19)</span><br><span class="line">$Number(20)</span><br><span class="line">===============</span><br></pre></td></tr></table></figure>
<h3 id="递归类型">递归类型</h3>
<p>既然可以使用结构体了，那么就看看能不能支持递归，比如链表和二叉树可以视作是递归类型，但是由于命令式编程语言一切都可以用内存去理解，所以往往不会那么直接的视作递归类型。</p>
<p>例如下面的代码，核心看递归的层面，满足 L 的 fact <code>r1</code>，且 <code>r1</code> 中的 <code>x</code> 小于 30，那么就存在新的 L 的 fact <code>L([r1,x+10])</code>。这里需要注意，<code>r2</code> 可能并不是一层，可能是嵌套的 <code>IntList</code> 类型。</p>
<p>最后，Flatten 把每一个 IntList 中的 <code>x</code> 提取出来。上面提到了 p=&gt;Pair 的映射，所以根据编号，也是有顺序的。</p>
<p>特别注意， nil 类型，用于递归类型最初始的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.type IntList = [next: IntList, x: number]</span><br><span class="line">.decl L(l: IntList)</span><br><span class="line">L([nil,10]).</span><br><span class="line">L([r1,x+10]) :- L(r1), r1=[r2,x], x &lt; 30.</span><br><span class="line"></span><br><span class="line">.output  L</span><br><span class="line">.decl Flatten(x: number)</span><br><span class="line">Flatten(x) :- L([_,x]).</span><br><span class="line">.output Flatten</span><br></pre></td></tr></table></figure>
<p>来看结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  exp1 souffle list.dl -D -</span><br><span class="line">Warning: Variable r2 only occurs once in file list.dl at line 4</span><br><span class="line">L([r1,x+10]) :- L(r1), r1=[r2,x], x &lt; 30.</span><br><span class="line">---------------------------^--------------</span><br><span class="line">---------------</span><br><span class="line">L</span><br><span class="line">l</span><br><span class="line">===============</span><br><span class="line">[nil, 10]</span><br><span class="line">[[nil, 10], 20]</span><br><span class="line">[[[nil, 10], 20], 30]</span><br><span class="line">===============</span><br><span class="line">---------------</span><br><span class="line">Flatten</span><br><span class="line">x</span><br><span class="line">===============</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">===============</span><br></pre></td></tr></table></figure>
<hr>
<p>更多的语法知识，可以查看官方文档的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://souffle-lang.github.io/program">语法部分</a>和<a target="_blank" rel="noopener external nofollow noreferrer" href="https://souffle-lang.github.io/autotuning">高级主题部分</a>。笔者将会逐渐深入学习理论，然后开始进行实际智能合约的分析，后续会逐渐完善这个系列。</p>
<h1>应用实例</h1>
<h2 id="传递闭包和对称">传递闭包和对称</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.decl edge(n: symbol, m: symbol)</span><br><span class="line"> /* facts of edge */</span><br><span class="line">edge(&quot;a&quot;, &quot;b&quot;).</span><br><span class="line">edge(&quot;b&quot;, &quot;c&quot;).</span><br><span class="line">edge(&quot;c&quot;, &quot;b&quot;).</span><br><span class="line">edge(&quot;c&quot;, &quot;d&quot;).</span><br><span class="line">/*relations*/</span><br><span class="line">.decl reachable (n: symbol, m: symbol)</span><br><span class="line">.output reachable // output relation reachable</span><br><span class="line">reachable(x, y):- edge(x, y). // base rule</span><br><span class="line">reachable(x, z):- edge(x, y), reachable(y, z). // inductive rule</span><br><span class="line"></span><br><span class="line">// 对称</span><br><span class="line">.decl SCC(n:symbol,m:symbol)</span><br><span class="line">.output SCC</span><br><span class="line">SCC(x,y) :- reachable(x,y), reachable(y,x).</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  exp1 souffle test.dl -D -</span><br><span class="line">---------------</span><br><span class="line">reachable</span><br><span class="line">n       m</span><br><span class="line">===============</span><br><span class="line">a       b</span><br><span class="line">a       c</span><br><span class="line">a       d</span><br><span class="line">b       b</span><br><span class="line">b       c</span><br><span class="line">b       d</span><br><span class="line">c       b</span><br><span class="line">c       c</span><br><span class="line">c       d</span><br><span class="line">===============</span><br><span class="line">---------------</span><br><span class="line">SCC</span><br><span class="line">n       m</span><br><span class="line">===============</span><br><span class="line">b       b</span><br><span class="line">b       c</span><br><span class="line">c       b</span><br><span class="line">c       c</span><br><span class="line">===============</span><br></pre></td></tr></table></figure>
<h2 id="寻找深度相同节点">寻找深度相同节点</h2>
<p>对于一颗树，寻找深度相同的节点。</p>
<p><img src="https://souffle-lang.github.io/img/same_generation_graph.jpg" alt="Example graph"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.decl Parent(n: symbol, m: symbol)</span><br><span class="line">Parent(&quot;d&quot;, &quot;b&quot;). Parent(&quot;e&quot;, &quot;b&quot;). Parent(&quot;f&quot;,&quot;c&quot;).</span><br><span class="line">Parent(&quot;g&quot;, &quot;c&quot;). Parent(&quot;b&quot;, &quot;a&quot;). Parent(&quot;c&quot;,&quot;a&quot;).</span><br><span class="line">.decl Person(n: symbol)</span><br><span class="line">Person(x) :- Parent(x, _).</span><br><span class="line">Person(x) :- Parent(_, x).</span><br><span class="line">.decl SameGeneration (n: symbol, m: symbol)</span><br><span class="line">SameGeneration(x, x):- Person(x).</span><br><span class="line">// 关键在于下面的逻辑推导，如果x,y是同级别的，那么它们的父节点也是同级别的</span><br><span class="line">SameGeneration(x, y):- Parent(x,p), SameGeneration(p,q), Parent(y,q).</span><br><span class="line">.output SameGeneration</span><br></pre></td></tr></table></figure>
<p>可以发现，推导是允许递归的。</p>
<h2 id="数据流分析">数据流分析</h2>
<p>data-flow analysis（DFA），数据流分析基于控制流图，是比较典型的用节点和图表示程序运行过程的分析方法。具体可以见博客的<a href="https://www.blog-blockchain.xyz/tags/program-language/">软件分析</a>部分。</p>
<p>这下面是一个可达性分析（也被叫做 liveness 分析，笔者不是很清楚其中区别），可以理解为一个带着分支的循环，d1 和 d2 都定义了变量 v，然后 B3 节点可达的变量 v 一定是在 B4 节点中的 d2。</p>
<p><img src="http://cdn.blog-blockchain.xyz/202210032209864.jpeg" alt="Reaching definition example"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// define control flow graph</span><br><span class="line">// via the Edge relation</span><br><span class="line">.decl Edge(n: symbol, m: symbol)</span><br><span class="line">Edge(&quot;start&quot;, &quot;b1&quot;).</span><br><span class="line">Edge(&quot;b1&quot;, &quot;b2&quot;).</span><br><span class="line">Edge(&quot;b1&quot;, &quot;b3&quot;).</span><br><span class="line">Edge(&quot;b2&quot;, &quot;b4&quot;).</span><br><span class="line">Edge(&quot;b3&quot;, &quot;b4&quot;).</span><br><span class="line">Edge(&quot;b4&quot;, &quot;b1&quot;).</span><br><span class="line">Edge(&quot;b4&quot;, &quot;end&quot;).</span><br><span class="line"></span><br><span class="line">// 重新定义变量v的节点和声明编号</span><br><span class="line">.decl GenDef(n: symbol, d:symbol)</span><br><span class="line">GenDef(&quot;b2&quot;, &quot;d1&quot;).</span><br><span class="line">GenDef(&quot;b4&quot;, &quot;d2&quot;).</span><br><span class="line"></span><br><span class="line">// 可以删除对之前的引用，比如b4节点可以删除之前的d1定义的变量v</span><br><span class="line">.decl KillDef(n: symbol, d:symbol)</span><br><span class="line">KillDef(&quot;b4&quot;, &quot;d1&quot;).</span><br><span class="line">KillDef(&quot;b2&quot;, &quot;d2&quot;).</span><br><span class="line"></span><br><span class="line">// Reachable</span><br><span class="line">.decl Reachable(n: symbol, d:symbol)</span><br><span class="line">Reachable(u,d) :- GenDef(u,d). // 定义变量的节点必然是可达的</span><br><span class="line">// 当存在节点 u 可以到达v，而且u也是可到达v的，u不会覆盖或者删除对定义d的引用</span><br><span class="line">Reachable(v,d) :- Edge(u,v), Reachable(u,d), !KillDef(u,d).</span><br><span class="line"></span><br><span class="line">.output Reachable</span><br></pre></td></tr></table></figure>
<p>这样，就清楚在每一个节点，某一个变量来自于哪一个定义了。这里必须补充一下，变量并不是和变量名绑定，而是说对应的内存中的对象，如果修改了内存，就是新的对象了，也可以称作是定义。可达性分析可以知道当前语句中的某个变量，来自于哪一个定义的地方。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  exp1 souffle DFA.dl -D -</span><br><span class="line">---------------</span><br><span class="line">Reachable</span><br><span class="line">n       d</span><br><span class="line">===============</span><br><span class="line">b1      d2</span><br><span class="line">b2      d1</span><br><span class="line">b2      d2</span><br><span class="line">b3      d2</span><br><span class="line">b4      d1</span><br><span class="line">b4      d2</span><br><span class="line">end     d2</span><br><span class="line">===============</span><br></pre></td></tr></table></figure>
<h2 id="偏序关系">偏序关系</h2>
<blockquote>
<p>Given a set A(x:symbol), create a successor relation Succ(x:symbol, y:symbol) such that the first argument contains an element x in A, and the second argument contains the successor of x, which is also an element of A. For example, the set A = {“a”, “b”, “c”, “d”} would have successor relation Succ=((“a”, “b”), (“b”, “c”), (“c”, “d”)}. Assume that the total order of an element (a symbol in this case) is given by its ordinal number, its internal representation as a number. For example, ord(“hello”) returns the ordinal number of string “hello” for a given program.</p>
</blockquote>
<p>题目来自 souffle 官方教程，默认读者已经熟悉前驱、后继关系，其实相当于偏序关系中的大于和小于，但是更加一般化和理论化了。讲解见注释。</p>
<p>更加进一步，我们再去找到最大和最小的元素。可以这样表示最大值，记 $$P:x\leqslant a$$，则</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">(</mo><mi mathvariant="normal">∀</mi><mi>x</mi><mo fence="true">)</mo></mrow><mi>P</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>A</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>A</mi><mrow><mo fence="true">(</mo><mi>a</mi><mo fence="true">)</mo></mrow><mo>→</mo><mi>a</mi><mtext>是最大值</mtext></mrow><annotation encoding="application/x-tex">\left( \forall x \right) P\left( x \right) ,A\left( x \right) ,A\left( a \right) \rightarrow a\text{是最大值}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">∀</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">a</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord text"><span class="mord cjk_fallback">是最大值</span></span></span></span></span></span></p>
<p>**但是 Datalog 只有存在量词。**根据摩根律推广：</p>
<img src="http://cdn.blog-blockchain.xyz/202210040039840.png" alt="image-20221004003949770" style="zoom:67%;" />
<p>原来的推导等价于下面的 E2：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mn>1</mn><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>:</mo><mrow><mo fence="true">(</mo><mi mathvariant="normal">∃</mi><mi>x</mi><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mi>x</mi><mo>&gt;</mo><mi>a</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>A</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>A</mi><mrow><mo fence="true">(</mo><mi>a</mi><mo fence="true">)</mo></mrow><mspace linebreak="newline"></mspace><mi>E</mi><mn>2</mn><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>:</mo><mi mathvariant="normal">¬</mi><mi>E</mi><mn>1</mn><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>A</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>→</mo><mi>a</mi><mtext>是最大值</mtext></mrow><annotation encoding="application/x-tex">E1\left( x \right) : \left( \exists x \right) \left( x&gt;a \right) ,A\left( x \right) ,A\left( a \right)
\\
E2\left( x \right) : \lnot E1\left( x \right) ,A\left( x \right) \rightarrow a\text{是最大值}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">∃</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">a</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">2</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord text"><span class="mord cjk_fallback">是最大值</span></span></span></span></span></span></p>
<p>最小值同理也可得。</p>
<blockquote>
<p>感谢这一篇<a target="_blank" rel="noopener external nofollow noreferrer" href="https://qa.1r1g.com/sf/ask/1353816481/">博客</a>帮助我我快速地解决了问题。</p>
</blockquote>
<p><strong>所有定义必须大写字母开头</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 定义集合 A, 从文件输入 facts/</span><br><span class="line">.decl A(x:symbol)</span><br><span class="line">.input A</span><br><span class="line">// 定义偏序小于，比如字母表顺序 &#x27;a&#x27;&lt;&#x27;b&#x27;，那么就可以将 symbol 用 ord() 转换成次序。</span><br><span class="line">.decl Less(x:symbol, y:symbol)</span><br><span class="line">Less(x,y) :- A(x), A(y), ord(x) &lt; ord(y).</span><br><span class="line"></span><br><span class="line">// 传递性</span><br><span class="line">.decl Transitive(x:symbol, y:symbol)</span><br><span class="line">Transitive(x,z) :- Less(x,y), Less(y,z).</span><br><span class="line"></span><br><span class="line">// x 后继y，需要满足 y 直接小于 x,而不能传递小于 x</span><br><span class="line">.decl Succ(x:symbol, y:symbol)</span><br><span class="line">Succ(x,y) :- Less(x,y), !Transitive(x,y).</span><br><span class="line"></span><br><span class="line">//最大元素</span><br><span class="line">.decl Nmax(x:symbol)</span><br><span class="line">Nmax(x) :- Less(x,u),A(x),A(u).</span><br><span class="line"></span><br><span class="line">.decl Max(x:symbol)</span><br><span class="line">Max(x) :- !Nmax(x),A(x).</span><br><span class="line">.output Max</span><br><span class="line"></span><br><span class="line">.decl Nmin(x:symbol)</span><br><span class="line">Nmin(x) :- Less(u,x),A(x),A(u).</span><br><span class="line"></span><br><span class="line">.decl Min(x:symbol)</span><br><span class="line">Min(x) :- !Nmin(x),A(x).</span><br><span class="line">.output Min</span><br><span class="line"></span><br><span class="line">.output Less, Transitive, Succ</span><br></pre></td></tr></table></figure>
<p>给定输入的数据 <code>A.facts</code>，注意一个 fact 一行，然后每个 fact 不同的参数用 TAB，不过这里只有一个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  successor souffle successor-relation.dl -F . -D -</span><br><span class="line">---------------</span><br><span class="line">Less</span><br><span class="line">x       y</span><br><span class="line">===============</span><br><span class="line">a       b</span><br><span class="line">a       c</span><br><span class="line">a       d</span><br><span class="line">a       e</span><br><span class="line">b       c</span><br><span class="line">b       d</span><br><span class="line">b       e</span><br><span class="line">c       d</span><br><span class="line">c       e</span><br><span class="line">d       e</span><br><span class="line">===============</span><br><span class="line">---------------</span><br><span class="line">Max</span><br><span class="line">x</span><br><span class="line">===============</span><br><span class="line">e</span><br><span class="line">===============</span><br><span class="line">---------------</span><br><span class="line">Min</span><br><span class="line">x</span><br><span class="line">===============</span><br><span class="line">a</span><br><span class="line">===============</span><br><span class="line">---------------</span><br><span class="line">Transitive</span><br><span class="line">x       y</span><br><span class="line">===============</span><br><span class="line">a       c</span><br><span class="line">a       d</span><br><span class="line">a       e</span><br><span class="line">b       d</span><br><span class="line">b       e</span><br><span class="line">c       e</span><br><span class="line">===============</span><br><span class="line">---------------</span><br><span class="line">Succ</span><br><span class="line">x       y</span><br><span class="line">===============</span><br><span class="line">a       b</span><br><span class="line">b       c</span><br><span class="line">c       d</span><br><span class="line">d       e</span><br><span class="line">===============</span><br></pre></td></tr></table></figure>
<h2 id="简单指针分析和别名分析">简单指针分析和别名分析</h2>
<p>指针分析和别名分析（aliases)有很多相似之处，但是指针分析并不等于别名分析，二者区别如下：</p>
<ul>
<li>指针分析解答的是一个指针可能指向哪个对象的问题</li>
<li>别名分析解答的是两个指针是否能指向同一个对象的问题，如果是就认为二者互为别名。</li>
</ul>
<p>注意，下面的分析都是 may 分析，只是说 <strong>可能</strong> 指向同一个对象。</p>
<p>需要分析的代码片段如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">v1 = h1();</span><br><span class="line">v2 = h2();</span><br><span class="line">v1 = v2;</span><br><span class="line">v3 = h3();</span><br><span class="line">v1.f = v3;</span><br><span class="line">v4 = v1.f;</span><br></pre></td></tr></table></figure>
<p>详细解释见代码注释，代码执行顺序有非对称的关系就可以了，简单说就是有向图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.type var &lt;: symbol</span><br><span class="line">.type obj &lt;: symbol</span><br><span class="line">.type field &lt;: symbol</span><br><span class="line"></span><br><span class="line">// -- inputs --</span><br><span class="line">.decl assign( a:var, b:var )</span><br><span class="line">.decl new( v:var, o:obj )</span><br><span class="line">.decl ld( a:var, b:var, f:field )</span><br><span class="line">.decl st( a:var, f:field, b:var )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// -- facts --</span><br><span class="line">// 赋值</span><br><span class="line">assign(&quot;v1&quot;,&quot;v2&quot;).</span><br><span class="line">// 新建变量</span><br><span class="line">new(&quot;v1&quot;,&quot;h1&quot;).</span><br><span class="line">new(&quot;v2&quot;,&quot;h2&quot;).</span><br><span class="line">new(&quot;v3&quot;,&quot;h3&quot;).</span><br><span class="line">// st 表示变量的某个域（比如结构体里面的元素）被另外一个变量赋值了</span><br><span class="line">// ld 表示变量被另外一个变量的某个域赋值了</span><br><span class="line">st(&quot;v1&quot;,&quot;f&quot;,&quot;v3&quot;).</span><br><span class="line">ld(&quot;v4&quot;,&quot;v1&quot;,&quot;f&quot;).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// -- analysis --</span><br><span class="line">// 别名分析</span><br><span class="line">.decl alias( a:var, b:var )</span><br><span class="line">.output alias</span><br><span class="line">// 如果直接赋值，那么就是别名</span><br><span class="line">alias(X,X) :- assign(X,_).</span><br><span class="line">alias(X,X) :- assign(_,X).</span><br><span class="line">alias(X,Y) :- assign(X,Y).</span><br><span class="line">// 如果 x=A.F 而 A 和 B 可以指向同样的变量，B.F = Y，那么 X,Y 也是别名</span><br><span class="line">alias(X,Y) :- ld(X,A,F), alias(A,B), st(B,F,Y).</span><br><span class="line"></span><br><span class="line">.decl pointsTo( a:var, o:obj )</span><br><span class="line">.output pointsTo</span><br><span class="line">// 直接新建对象，当然是别名</span><br><span class="line">pointsTo(X,Y) :- new(X,Y).</span><br><span class="line">// 或者 X 和 Z指向同一个变量，而Z指向对象Y，那么X也指向变量Y</span><br><span class="line">pointsTo(X,Y) :- alias(X,Z), pointsTo(Z,Y).</span><br></pre></td></tr></table></figure>
<p>更多的例子见：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://souffle-lang.github.io/examples#defuse-chains-with-composed-types">https://souffle-lang.github.io/examples#defuse-chains-with-composed-types</a></p>
<p>笔者以应用为主，当学习到对应的部分，就会实现对应的代码。接下来继续学习理论。</p>
<h1>参考</h1>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://souffle-lang.github.io/docs.html">https://souffle-lang.github.io/docs.html</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://nickelsworth.github.io/sympas/16-datalog.html">http://nickelsworth.github.io/sympas/16-datalog.html</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://qa.1r1g.com/sf/ask/1353816481/">https://qa.1r1g.com/sf/ask/1353816481/</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://blogs.evergreen.edu/sosw/files/2014/04/Green-Vol5-DBS-017.pdf">Datalog and Recursive Query Processing</a> 建议当作工具书去查，除非你要深入研究 datalog</li>
</ul>
<h1>附录一数理逻辑定义</h1>
<ol>
<li>literal: 原子公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 或者是原子公式的否定式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\lnot x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬</span><span class="mord mathnormal">x</span></span></span></span></li>
<li>clause: 有限的 literal 和逻辑连接词构成的命题公式。</li>
<li>facts：绝对成立的命题。</li>
<li>monotonic：因为蕴含而保持“单调的”</li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Sequent_calculus">sequent calculi</a> ：根据单调关系推导</li>
<li>Non-monotonic logic：非单调逻辑，简单地说结论不是蕴含关系。</li>
<li>words: 也叫做 string，也就是一系列的字符。</li>
<li>letters: 也叫做 symbol，非常基础的东西，可以理解为符号。</li>
<li>formal language: 由 words 构成的规则集合，words 由 letters 构成，letters 从给定的字符集中选取。</li>
<li>Well-formed formula: 形式语言字符集中的字符以特定规则构成的有限的命题公式。缩写 WFF。</li>
<li>sentence: 无自由变量的 WFF。</li>
<li>Stratification</li>
</ol>
<p>更多的东西属于数学的范围了，笔者暂时不会深入，因为主要是先用起来再说。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz">Michael(Jiahao) Luo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://www.blog-blockchain.xyz/pl/LP-souffle/">https://www.blog-blockchain.xyz/pl/LP-souffle/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/program-language/">program language</a></div><div class="post-share"><div class="social-share" data-image="/images/pa.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/pl/data-flow-analysis/" title="（二）数据流分析基础"><img class="cover" src="/images/pa.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">（二）数据流分析基础</div></div><div class="info-2"><div class="info-item-1"> （一）初识软件分析（二）数据流分析基础（三）Datalog和程序分析（四）静态单赋值和稀疏分析（五）过程间分析（六）指向分析（七）抽象解释（八）SMT和符号执行（九）体验静态分析工具（十）Fuzzing 基础  数据流分析 基本思想：程序视作状态和状态的转移两部分组成，忽视状态转移的条件，分析状态转移时的变化。 近似的两种方案：  忽略程序的条件判断，认为程序的所有分支都有可能到达。 **控制流分叉合并。**这会大大的减少计算量。  这些性质在后面会解释。 符号分析 思想：对变量进行抽象，分析输入的符号和输出的符号，得到抽象的结果。在此基础上可自定义分类和类似地拓展，用更加抽象和概括的符号。例如，对于整数类型，我们可以分成零、正、负、未知四种输入和结果，而不考虑具体的数值。 按照状态转移，我们可能有多条执行路径能够到达目的点 A。例如，if 语句是典型的区分执行路径的的方式。由于未知结果的函数 func1 和 func2，a 最终的符号可能是正、负或者未知。那么，我们可以得到 2 条可能的执行路径(0、5、1、未知)或者执行路径(0、-1、1、...</div></div></div></a><a class="pagination-related" href="/pl/ssa-and-sparse-analysis/" title="（四）静态单赋值和稀疏分析"><img class="cover" src="/images/pa.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">（四）静态单赋值和稀疏分析</div></div><div class="info-2"><div class="info-item-1"> （一）初识软件分析（二）数据流分析基础（三）Datalog和程序分析（四）静态单赋值和稀疏分析（五）过程间分析（六）指向分析（七）抽象解释（八）SMT和符号执行（九）体验静态分析工具（十）Fuzzing 基础  简介 这一章是对数据流分析的拓展和补充，基本内容如下： 首先从 Def-Use...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/pl/Interprocedural-DFA/" title="（五）过程间分析"><img class="cover" src="/images/pa.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-23</div><div class="info-item-2">（五）过程间分析</div></div><div class="info-2"><div class="info-item-1"> （一）初识软件分析（二）数据流分析基础（三）Datalog和程序分析（四）静态单赋值和稀疏分析（五）过程间分析（六）指向分析（七）抽象解释（八）SMT和符号执行（九）体验静态分析工具（十）Fuzzing 基础  之前我们所有的分析都是没有函数调用的，也就是之前考虑的情况都是「过程内」的调用。本章将会考虑函数调用，开始「过程间」分析（Whole Program Analysis 或者 Link-time Analysis）的学习。 基本思路 每个过程内分析对应一个抽象域，然后函数调用时，每个函数都是新的过程内分析。那么，只要考虑两个过程内分析的衔接即可。例如对下面的程序，在函数 A 内调用函数 B 时，其实就是过程间分析，调用和返回时对节点进行转换即可。 1234567891011int B(x,y)&#123;    z = x+y;    return z;&#125;int A()&#123;    int a = 10;    int b = 20;    int c = B(a,b);    return...</div></div></div></a><a class="pagination-related" href="/pl/abstract-interpretation/" title="（七）抽象解释"><img class="cover" src="/images/pa.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-07</div><div class="info-item-2">（七）抽象解释</div></div><div class="info-2"><div class="info-item-1"> （一）初识软件分析（二）数据流分析基础（三）Datalog和程序分析（四）静态单赋值和稀疏分析（五）过程间分析（六）指向分析（七）抽象解释（八）SMT和符号执行（九）体验静态分析工具（十）Fuzzing 基础  前言 这一文章是理论课，对之前的程序分析的合理性和思路，进行了理论上的分析和论证，有助于读者培养程序分析的思维。程序分析的很多思路都是对具体的值具体的表达式进行了抽象，建立了具体空间和抽象空间的关系，抽象解释理论就是解释映射函数。  这个映射主要分成两部分：  具体化函数 γ\gammaγ 将抽象值映射为具体值的集合 抽象化函数 α\alphaα 将具体值的集合映射为抽象值  伽罗瓦连接 Galois Connection 假设抽象域上存在偏序关系。简便起见，这里假设具体值集合上的偏序关系为子集关系。但抽象解释理论支持其他偏序关系，比如超集。 注意下面特殊的字 虚 表示抽象域集合，甲 表示抽象域集合中的元素。任取两个集合中各自一个元素 X 和...</div></div></div></a><a class="pagination-related" href="/pl/data-flow-analysis/" title="（二）数据流分析基础"><img class="cover" src="/images/pa.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-04</div><div class="info-item-2">（二）数据流分析基础</div></div><div class="info-2"><div class="info-item-1"> （一）初识软件分析（二）数据流分析基础（三）Datalog和程序分析（四）静态单赋值和稀疏分析（五）过程间分析（六）指向分析（七）抽象解释（八）SMT和符号执行（九）体验静态分析工具（十）Fuzzing 基础  数据流分析 基本思想：程序视作状态和状态的转移两部分组成，忽视状态转移的条件，分析状态转移时的变化。 近似的两种方案：  忽略程序的条件判断，认为程序的所有分支都有可能到达。 **控制流分叉合并。**这会大大的减少计算量。  这些性质在后面会解释。 符号分析 思想：对变量进行抽象，分析输入的符号和输出的符号，得到抽象的结果。在此基础上可自定义分类和类似地拓展，用更加抽象和概括的符号。例如，对于整数类型，我们可以分成零、正、负、未知四种输入和结果，而不考虑具体的数值。 按照状态转移，我们可能有多条执行路径能够到达目的点 A。例如，if 语句是典型的区分执行路径的的方式。由于未知结果的函数 func1 和 func2，a 最终的符号可能是正、负或者未知。那么，我们可以得到 2 条可能的执行路径(0、5、1、未知)或者执行路径(0、-1、1、...</div></div></div></a><a class="pagination-related" href="/pl/SMT-and-symbolic-excution/" title="（八）SMT和符号执行"><img class="cover" src="/images/pa.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-23</div><div class="info-item-2">（八）SMT和符号执行</div></div><div class="info-2"><div class="info-item-1"> （一）初识软件分析（二）数据流分析基础（三）Datalog和程序分析（四）静态单赋值和稀疏分析（五）过程间分析（六）指向分析（七）抽象解释（八）SMT和符号执行（九）体验静态分析工具（十）Fuzzing 基础  前言 我们程序分析的学习进入了下一个阶段。在第一篇文章中提到程序分析可以大体分成抽象和搜索两部分，之前都是学习了抽象的部分。我们从数据流分析开始，讨论了抽象的基本思想，分支（包括循环）如何合并，节点如何更新等知识。从理论层面，探讨了数据流分析的的抽象和转换函数必须满足的条件以及数据流分析的性质，因此我们介绍了格理论。特别地，详细介绍了 widening 和 narrowing 的方法。在这一部分，我们建立了对于抽象的方法的基本认识。 然后，我们学习的 Datalog ，从基本数理逻辑出发介绍了逻辑式编程语言，接着介绍了典型的 Souffle 语言和它在程序分析上的应用。 在数据流分析中有几种很典型的方法Def-use 和 SSA，Def-use...</div></div></div></a><a class="pagination-related" href="/pl/fuzzing-introduction/" title="（十）Fuzzing 基础"><img class="cover" src="/images/pa.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-21</div><div class="info-item-2">（十）Fuzzing 基础</div></div><div class="info-2"><div class="info-item-1"> （一）初识软件分析（二）数据流分析基础（三）Datalog和程序分析（四）静态单赋值和稀疏分析（五）过程间分析（六）指向分析（七）抽象解释（八）SMT和符号执行（九）体验静态分析工具（十）Fuzzing 基础   这主要是[1]的阅读总结  Fuzzing 是什么 在众多软件测试技术中，Fuzzing 因其概念的简单性、易于部署以及在发现实际软件漏洞方面的有效性而受到广泛青睐。简而言之，Fuzzing 是使用异常或非预期的输入（称为“fuzz 输入”）来运行待测试的程序（Program Under Test, PUT）的过程。这种 fuzz 输入是 PUT 可能没有预料到的，也就是说，它可能会使 PUT 处理不当，从而触发开发者未预期的行为。 定义 1 (Fuzzing)：Fuzzing 是指使用从所谓的“fuzz 输入空间”中抽取的输入来执行 PUT 的过程，这个输入空间超出了 PUT 的预期输入范围。 定义 2 (Fuzz Testing)：Fuzz 测试是利用 fuzzing 来检查 PUT 是否违反了某些特定的正确性策略。 定义 3 (Fuzzer)：Fuzzer...</div></div></div></a><a class="pagination-related" href="/pl/ssa-and-sparse-analysis/" title="（四）静态单赋值和稀疏分析"><img class="cover" src="/images/pa.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-10</div><div class="info-item-2">（四）静态单赋值和稀疏分析</div></div><div class="info-2"><div class="info-item-1"> （一）初识软件分析（二）数据流分析基础（三）Datalog和程序分析（四）静态单赋值和稀疏分析（五）过程间分析（六）指向分析（七）抽象解释（八）SMT和符号执行（九）体验静态分析工具（十）Fuzzing 基础  简介 这一章是对数据流分析的拓展和补充，基本内容如下： 首先从 Def-Use...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/site-avator.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Michael(Jiahao) Luo</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/LearnerLj"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://www.linkedin.com/in/jiahao-michael-luo-8ba5942a3" rel="external nofollow noreferrer" target="_blank" title="Linkedin"><i class="fa-brands fa-linkedin"></i></a><a class="social-icon" href="https://github.com/learnerLj" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:luoshitou9@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">从技术到商业，从产品到设计，从生活到未来，我会在这里分享我的所思所想，欢迎关注！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%BC%8F%E8%AF%AD%E8%A8%80"><span class="toc-number">2.1.</span> <span class="toc-text">逻辑式语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Datalog"><span class="toc-number">2.2.</span> <span class="toc-text">Datalog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.</span> <span class="toc-text">逻辑式语言例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">souffle</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">3.2.</span> <span class="toc-text">安装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.1.</span> <span class="toc-text">程序示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">4.2.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%92%8C%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text">调试和日志分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD"><span class="toc-number">4.4.</span> <span class="toc-text">其他功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">5.1.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-number">5.3.</span> <span class="toc-text">IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91"><span class="toc-number">5.4.</span> <span class="toc-text">一阶逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB"><span class="toc-number">5.4.2.</span> <span class="toc-text">等价关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inline"><span class="toc-number">5.4.3.</span> <span class="toc-text">inline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E5%8F%96"><span class="toc-number">5.4.4.</span> <span class="toc-text">析取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.5.</span> <span class="toc-text">算术表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">5.5.1.</span> <span class="toc-text">算术操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%AF%94%E8%BE%83"><span class="toc-number">5.5.2.</span> <span class="toc-text">算术比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E5%AD%90"><span class="toc-number">5.6.</span> <span class="toc-text">内置函子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.7.</span> <span class="toc-text">自定义数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">5.7.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Union-%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.7.2.</span> <span class="toc-text">Union 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.7.3.</span> <span class="toc-text">代数数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.7.4.</span> <span class="toc-text">递归类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85%E5%92%8C%E5%AF%B9%E7%A7%B0"><span class="toc-number">6.1.</span> <span class="toc-text">传递闭包和对称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E6%B7%B1%E5%BA%A6%E7%9B%B8%E5%90%8C%E8%8A%82%E7%82%B9"><span class="toc-number">6.2.</span> <span class="toc-text">寻找深度相同节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-number">6.3.</span> <span class="toc-text">数据流分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB"><span class="toc-number">6.4.</span> <span class="toc-text">偏序关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%92%8C%E5%88%AB%E5%90%8D%E5%88%86%E6%9E%90"><span class="toc-number">6.5.</span> <span class="toc-text">简单指针分析和别名分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">附录一数理逻辑定义</span></a></li></ol></div></div><div class="card-widget card-post-series"><div class="item-headline"><i class="fa-solid fa-layer-group"></i><span>Post Series</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/pl/understanding-program-analysis/" title="（一）初识软件分析"><img src="/images/pa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（一）初识软件分析"></a><div class="content"><a class="title" href="/pl/understanding-program-analysis/" title="（一）初识软件分析">（一）初识软件分析</a><time datetime="2022-08-24T13:30:33.000Z" title="Created 2022-08-24 21:30:33">2022-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pl/data-flow-analysis/" title="（二）数据流分析基础"><img src="/images/pa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（二）数据流分析基础"></a><div class="content"><a class="title" href="/pl/data-flow-analysis/" title="（二）数据流分析基础">（二）数据流分析基础</a><time datetime="2022-10-04T13:30:33.000Z" title="Created 2022-10-04 21:30:33">2022-10-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pl/LP-souffle/" title="（三）Datalog和程序分析"><img src="/images/pa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（三）Datalog和程序分析"></a><div class="content"><a class="title" href="/pl/LP-souffle/" title="（三）Datalog和程序分析">（三）Datalog和程序分析</a><time datetime="2022-10-04T13:54:33.000Z" title="Created 2022-10-04 21:54:33">2022-10-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pl/ssa-and-sparse-analysis/" title="（四）静态单赋值和稀疏分析"><img src="/images/pa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（四）静态单赋值和稀疏分析"></a><div class="content"><a class="title" href="/pl/ssa-and-sparse-analysis/" title="（四）静态单赋值和稀疏分析">（四）静态单赋值和稀疏分析</a><time datetime="2022-10-10T08:40:33.000Z" title="Created 2022-10-10 16:40:33">2022-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pl/Interprocedural-DFA/" title="（五）过程间分析"><img src="/images/pa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（五）过程间分析"></a><div class="content"><a class="title" href="/pl/Interprocedural-DFA/" title="（五）过程间分析">（五）过程间分析</a><time datetime="2022-10-23T14:00:33.000Z" title="Created 2022-10-23 22:00:33">2022-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pl/points-to-analysis/" title="（六）指向分析"><img src="/images/pa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（六）指向分析"></a><div class="content"><a class="title" href="/pl/points-to-analysis/" title="（六）指向分析">（六）指向分析</a><time datetime="2022-11-21T13:50:33.000Z" title="Created 2022-11-21 21:50:33">2022-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pl/abstract-interpretation/" title="（七）抽象解释"><img src="/images/pa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（七）抽象解释"></a><div class="content"><a class="title" href="/pl/abstract-interpretation/" title="（七）抽象解释">（七）抽象解释</a><time datetime="2022-12-07T03:09:33.000Z" title="Created 2022-12-07 11:09:33">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pl/SMT-and-symbolic-excution/" title="（八）SMT和符号执行"><img src="/images/pa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（八）SMT和符号执行"></a><div class="content"><a class="title" href="/pl/SMT-and-symbolic-excution/" title="（八）SMT和符号执行">（八）SMT和符号执行</a><time datetime="2022-12-23T02:35:30.000Z" title="Created 2022-12-23 10:35:30">2022-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pl/static-analysis-tools/" title="（九）体验静态分析工具"><img src="/images/pa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（九）体验静态分析工具"></a><div class="content"><a class="title" href="/pl/static-analysis-tools/" title="（九）体验静态分析工具">（九）体验静态分析工具</a><time datetime="2022-12-23T03:16:30.000Z" title="Created 2022-12-23 11:16:30">2022-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/pl/fuzzing-introduction/" title="（十）Fuzzing 基础"><img src="/images/pa.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="（十）Fuzzing 基础"></a><div class="content"><a class="title" href="/pl/fuzzing-introduction/" title="（十）Fuzzing 基础">（十）Fuzzing 基础</a><time datetime="2023-10-21T09:00:30.000Z" title="Created 2023-10-21 17:00:30">2023-10-21</time></div></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/dev/fast-draw/" title="Mermaid 快速绘制流程图">Mermaid 快速绘制流程图</a><time datetime="2025-01-11T15:19:20.000Z" title="Created 2025-01-11 23:19:20">2025-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/web-security/" title="如何保障个人网站的安全"><img src="https://cdn.blog-blockchain.xyz/2024/12/f936073f7e7c6bdb2aa3ea0905916957.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何保障个人网站的安全"/></a><div class="content"><a class="title" href="/dev/web-security/" title="如何保障个人网站的安全">如何保障个人网站的安全</a><time datetime="2024-12-07T01:16:20.000Z" title="Created 2024-12-07 09:16:20">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/career/academic/" title="科研小总结"><img src="https://cdn.blog-blockchain.xyz/2024/11/f52e2456bd75a61f46d60e3768543c7f.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="科研小总结"/></a><div class="content"><a class="title" href="/career/academic/" title="科研小总结">科研小总结</a><time datetime="2024-11-21T17:38:21.000Z" title="Created 2024-11-22 01:38:21">2024-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/rss/" title="RSS信息汇聚"><img src="https://cdn.blog-blockchain.xyz/2024/11/07780b2a37df07c6fe3a70d3fa78b077.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RSS信息汇聚"/></a><div class="content"><a class="title" href="/dev/rss/" title="RSS信息汇聚">RSS信息汇聚</a><time datetime="2024-11-19T15:43:20.000Z" title="Created 2024-11-19 23:43:20">2024-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/dev/crypto-practice/" title="安全加密实践-GPG"><img src="https://cdn.blog-blockchain.xyz/2024/11/ecd2b676f9bf98a607c67fc697f9ed4e.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安全加密实践-GPG"/></a><div class="content"><a class="title" href="/dev/crypto-practice/" title="安全加密实践-GPG">安全加密实践-GPG</a><time datetime="2024-11-18T09:28:20.000Z" title="Created 2024-11-18 17:28:20">2024-11-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Michael(Jiahao) Luo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.2.2"></script><script src="/js/main.js?v=5.2.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '467d9506710fff22dc33',
      clientSecret: '2a3e530b895af9c94d4bbe95fe78c69317f4d76e',
      repo: 'blog-gitalk',
      owner: 'learnerLj',
      admin: ['learnerLj'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'a852112b5c2edd4ab350436db663a224'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.2.2"></script></div></div></body></html>